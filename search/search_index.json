{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Major Author: Qiang Liu, Felix Koehler, and Nils Thuerey at Physics Based Simulation Group, Technical University of Munich <p>. We are grateful for all contributors!</p>"},{"location":"theory/","title":"Theory Introduction","text":"In\u00a0[\u00a0]: Copied! <pre># Fourier transformation of sin(x) and its derivative\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# set the grid\nL=np.pi*2\nN=100\nd=L/N\ngrid=np.arange(0,L,d)\nsinx=np.sin(grid)\n# ground truth of the sin'(x)\ncosx=np.cos(grid)\n# transform sin(x) to fourier space\nsinx_fft=np.fft.fft(sinx)\n# calculate the derivative of sin(x) in fourier space\ndsinx_dx=2*np.pi*1j*np.fft.fftfreq(N,d)*sinx_fft\n# transform back to real space\ndsinx_dx=np.fft.ifft(dsinx_dx).real\n# plot the result\nplt.plot(grid,cosx,\n         label='$[\\partial sin(x) / \\partial x ]$')\nplt.plot(grid,dsinx_dx,\n         label='$[\\partial sin(x) / \\partial x ]_{fft}$',\n         linestyle='--')\nplt.legend()\nplt.grid()\nplt.show()\n</pre> # Fourier transformation of sin(x) and its derivative import numpy as np import matplotlib.pyplot as plt  # set the grid L=np.pi*2 N=100 d=L/N grid=np.arange(0,L,d) sinx=np.sin(grid) # ground truth of the sin'(x) cosx=np.cos(grid) # transform sin(x) to fourier space sinx_fft=np.fft.fft(sinx) # calculate the derivative of sin(x) in fourier space dsinx_dx=2*np.pi*1j*np.fft.fftfreq(N,d)*sinx_fft # transform back to real space dsinx_dx=np.fft.ifft(dsinx_dx).real # plot the result plt.plot(grid,cosx,          label='$[\\partial sin(x) / \\partial x ]$') plt.plot(grid,dsinx_dx,          label='$[\\partial sin(x) / \\partial x ]_{fft}$',          linestyle='--') plt.legend() plt.grid() plt.show() <p>This also provides a very simple way to solve some time-independent PDEs with only linear terms, e.g., the Poisson's equation $\\nabla^2 \\phi(\\mathbf{x})=s(\\mathbf{x})$:</p> $$ \\phi(\\mathbf{x}) = \\mathcal{F}^{-1}[\\frac{\\mathcal{F}[s(\\mathbf{x})]}{(2\\pi i \\mathbf{f})^2}]. $$ <p>Note</p> <p>         When using the Fourier transformation to solve equations like Poisson's equation, we need to be careful with the zero division problem. In the above example, we need to pad the value artificially when $\\mathbf{f} = \\mathbf{0}$. The zero frequency component is usually called the DC component, which is the average value of the function. The derivation operation will eliminate the DC component in a signal (the average value of a field will not affect any derivative of this value), so we need to pad the DC component artificially when doing the inverse operation.     </p> <p>Usually, Poisson's equation is difficult and expensive to solve in the physical space, but it is very easy to solve in the spectral space.</p> <p>Calculating the derivatives easily in the spectral space is one of the most important advantages of the Fourier spectral method.</p> In\u00a0[\u00a0]: Copied! <pre>L=np.pi*2\nN=10\nk1=6\nassert k1 &gt;= N/2, 'No aliasing error occurs if k &lt; N/2'\nk2 = k1 % (N/2)\ngrid=np.arange(0,L,L/N)\n# plot the grid\nplt.scatter(grid,\n            np.zeros_like(grid),\n            c=\"black\")\nfor x in grid:\n    plt.axvline(x = x, \n                color = \"black\", \n                linestyle = \"--\")\n# plot the sin wave with k1 and k2\nx=np.arange(0,L,L/N*0.01)\ny1=np.sin(k1*x)\ny2=np.sin(k2*x)\nplt.plot(x,y1,label=f'k={k1}')\nplt.plot(x,y2,label=f'k={k2}')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.show()\nprint(f\"The field with wave number {k1} is overlapped with the field with wave number {k2}.\")\nprint(f\"The difference between the two fields on the grid point is {np.mean(np.abs(y1)-np.abs(y2))}\")\n</pre> L=np.pi*2 N=10 k1=6 assert k1 &gt;= N/2, 'No aliasing error occurs if k &lt; N/2' k2 = k1 % (N/2) grid=np.arange(0,L,L/N) # plot the grid plt.scatter(grid,             np.zeros_like(grid),             c=\"black\") for x in grid:     plt.axvline(x = x,                  color = \"black\",                  linestyle = \"--\") # plot the sin wave with k1 and k2 x=np.arange(0,L,L/N*0.01) y1=np.sin(k1*x) y2=np.sin(k2*x) plt.plot(x,y1,label=f'k={k1}') plt.plot(x,y2,label=f'k={k2}') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.show() print(f\"The field with wave number {k1} is overlapped with the field with wave number {k2}.\") print(f\"The difference between the two fields on the grid point is {np.mean(np.abs(y1)-np.abs(y2))}\") <pre>The field with wave number 6 is overlapped with the field with wave number 1.0.\nThe difference between the two fields on the grid point is -6.283205978117934e-06\n</pre> <p>In the above example, the values of $\\sin(k_1 x)$ and $\\sin(k_2 x)$ are the same or opposite at each grid point, i.e., they overlap. If we look back at the formula of discrete Fourier transformation, we will find out why this overlap is important. If we have a field that contains some low-frequency signals with wave number $k_1$ and high-frequency signals with wave number $k_2$ and they overlap each other, you will not able to calculate $\\hat{\\phi}_{k_1}$ accurately as both of them will contribute to the $\\phi_j$ in each grid point $j$. In the simulations, that means the low-frequency component of your field will be affected by the unresolved high-frequency component, which is the aliasing error.</p> <p>We can use another example to further illustrate the aliasing error. Like the first case, we calculate the spatial derivative with Fourier Transformation. The difference here compared with the previous case is that we can control the wave number of the signal. You can find that only when $k &lt; N/2$, the Fourier Transformation can produce the correct result.</p> In\u00a0[4]: Copied! <pre>def show_aliasing(N:int,k:int,ax=None): \n    # k need to be integer as the FFT will only consider the integer k\n    L=np.pi*2\n    d=L/N\n    grid=np.arange(0,L,d)\n    x=np.arange(0,L,0.01*d)\n    # sin(kx)\n    sinkx=np.sin(k*grid)\n    # ground truth of the sin'(kx)\n    kcoskx=k*np.cos(k*x)\n    # calculate the derivative of sin(kx) in fourier space\n    sinkx_fft=np.fft.fft(sinkx)\n    dsinkx_dx=np.fft.ifft(2*np.pi*1j*np.fft.fftfreq(N,d)*sinkx_fft).real\n    if ax is None:\n        ax=plt.gca()\n    ax.plot(x,kcoskx,\n            label='$[\\partial sin(kx) / \\partial x ]$')\n    ax.scatter(grid,dsinkx_dx,\n               label='$[\\partial sin(kx) / \\partial x ]_{fft}$',\n               color='orange')\n    ax.set_title(f'N={N}, k={k}')\n    ax.legend()\nfig,axs=plt.subplots(2,2,figsize=(10,10))\naxs=axs.flatten()\nfor i,k in enumerate([3,4,5,6]):\n    show_aliasing(10,k,ax=axs[i])\n</pre> def show_aliasing(N:int,k:int,ax=None):      # k need to be integer as the FFT will only consider the integer k     L=np.pi*2     d=L/N     grid=np.arange(0,L,d)     x=np.arange(0,L,0.01*d)     # sin(kx)     sinkx=np.sin(k*grid)     # ground truth of the sin'(kx)     kcoskx=k*np.cos(k*x)     # calculate the derivative of sin(kx) in fourier space     sinkx_fft=np.fft.fft(sinkx)     dsinkx_dx=np.fft.ifft(2*np.pi*1j*np.fft.fftfreq(N,d)*sinkx_fft).real     if ax is None:         ax=plt.gca()     ax.plot(x,kcoskx,             label='$[\\partial sin(kx) / \\partial x ]$')     ax.scatter(grid,dsinkx_dx,                label='$[\\partial sin(kx) / \\partial x ]_{fft}$',                color='orange')     ax.set_title(f'N={N}, k={k}')     ax.legend() fig,axs=plt.subplots(2,2,figsize=(10,10)) axs=axs.flatten() for i,k in enumerate([3,4,5,6]):     show_aliasing(10,k,ax=axs[i]) <p>Aliasing errors are particularly significant in nonlinear terms. As the nonlinear terms usually contain the product of two or more fields, the result of the product will contain higher frequency components. For example, if we calculate the square of the field $\\sin(kx)$, the result field is $\\frac{1-\\cos(2kx)}{2}$, which has two times the frequency of the original field. This means that the aliasing error will be more severe in the nonlinear terms. We can also illustrate this point with a simple example where we calculate the derivative of $\\sin^2(kx)$, and you will find the wave number threshold for the aliasing error is $k &lt; N/4$ due to the doubled wave number after the nonlinear operation.</p> In\u00a0[5]: Copied! <pre>def show_aliasing_nonlinear(N:int,k:int,ax=None): \n    # k need to be integer as the FFT will only consider the integer k\n    L=np.pi*2\n    d=L/N\n    grid=np.arange(0,L,d)\n    x=np.arange(0,L,d*0.01)\n    y=np.sin(k*grid)**2\n    # ground truth of the d sin^2(kx)/dx\n    gd=2*k*np.sin(k*x)*np.cos(k*x)\n    # calculate the derivative of sin^2(kx) in fourier space\n    yy_fft=np.fft.fft(y)\n    fft=np.fft.ifft(2*np.pi*1j*np.fft.fftfreq(N,d)*yy_fft).real\n    if ax is None:\n        ax=plt.gca()\n    ax.plot(x,gd,\n            label='$[\\partial sin^2(kx) / \\partial x ]$')\n    ax.scatter(grid,fft,\n               label='$[\\partial sin^2(kx) / \\partial x ]_{fft}$',linestyle='--',color=\"orange\")\n    ax.legend()\n    ax.set_title(f'N={N}, k={k}')\nfig,axs=plt.subplots(2,2,figsize=(10,10))\naxs=axs.flatten()\nfor i,k in enumerate([1,2,3,4]):\n    show_aliasing_nonlinear(10,k,ax=axs[i])\n</pre> def show_aliasing_nonlinear(N:int,k:int,ax=None):      # k need to be integer as the FFT will only consider the integer k     L=np.pi*2     d=L/N     grid=np.arange(0,L,d)     x=np.arange(0,L,d*0.01)     y=np.sin(k*grid)**2     # ground truth of the d sin^2(kx)/dx     gd=2*k*np.sin(k*x)*np.cos(k*x)     # calculate the derivative of sin^2(kx) in fourier space     yy_fft=np.fft.fft(y)     fft=np.fft.ifft(2*np.pi*1j*np.fft.fftfreq(N,d)*yy_fft).real     if ax is None:         ax=plt.gca()     ax.plot(x,gd,             label='$[\\partial sin^2(kx) / \\partial x ]$')     ax.scatter(grid,fft,                label='$[\\partial sin^2(kx) / \\partial x ]_{fft}$',linestyle='--',color=\"orange\")     ax.legend()     ax.set_title(f'N={N}, k={k}') fig,axs=plt.subplots(2,2,figsize=(10,10)) axs=axs.flatten() for i,k in enumerate([1,2,3,4]):     show_aliasing_nonlinear(10,k,ax=axs[i]) In\u00a0[\u00a0]: Copied! <pre># Apply the 2/3 rule to filter out high-frequency components\nN=10\nL=np.pi*2\nd=L/N\ngrid=np.arange(0,L,d)\nx=np.arange(0,L,d*0.01)\ny=np.sin(2*grid)+np.sin(4*grid)\n# ground truth of the d [sin(2x)+sin(4x)]^2/dx\ngd=(np.sin(2*x) + \n    np.sin(4*x))*(4*np.cos(2*x) + \n    8*np.cos(4*x))\n# ground truth at the grid point\ngd_test=(np.sin(2*grid) + \n         np.sin(4*grid))*(4*np.cos(2*grid) + \n        8*np.cos(4*grid))\n# calculate the derivative in fourier space\ny_freq=np.fft.fftfreq(N,d)\nyy_fft=np.fft.fft(y**2)\nfft=np.fft.ifft(2*np.pi*1j*y_freq*yy_fft).real\nfig,axs=plt.subplots(1,2,figsize=(10,5))\naxs[0].plot(x,gd,label='$[\\partial (\\sin(2x)+\\sin(4x)^2) / \\partial x ]$')\naxs[0].scatter(grid,fft,\n               label='$[\\partial (\\sin(2x)+\\sin(4x)^2 / \\partial x ]_{fft}$',\n               linestyle='--',color=\"orange\")\naxs[0].legend()\naxs[0].set_title('Error without dealiasing: {:.2f}'.format(np.mean(np.abs(gd_test-fft))))\n\n# calculate the derivative in fourier space with dealiasing\nwave_number_fft=np.abs(y_freq*L)\nmask=np.where(wave_number_fft&gt;N/3,0,1)\ny_masked=np.fft.ifft(np.fft.fft(y)*mask).real\nyy_fft=np.fft.fft(y_masked**2)\nfft=np.fft.ifft(2*np.pi*1j*y_freq*yy_fft).real\naxs[1].plot(x,\n            gd,\n            label='$[\\partial (\\sin(2x)+\\sin(4x)^2 / \\partial x ]$')\naxs[1].scatter(grid,\n               fft,\n               label='$[\\partial (\\sin(2x)+\\sin(4x)^2 / \\partial x ]_{fft}$',\n               linestyle='--',\n               color=\"orange\")\naxs[1].legend()\naxs[1].set_title('Error with dealiasing: {:.2f}'.format(\n    np.mean(np.abs(gd_test-fft))\n    ))\nplt.show()\n</pre> # Apply the 2/3 rule to filter out high-frequency components N=10 L=np.pi*2 d=L/N grid=np.arange(0,L,d) x=np.arange(0,L,d*0.01) y=np.sin(2*grid)+np.sin(4*grid) # ground truth of the d [sin(2x)+sin(4x)]^2/dx gd=(np.sin(2*x) +      np.sin(4*x))*(4*np.cos(2*x) +      8*np.cos(4*x)) # ground truth at the grid point gd_test=(np.sin(2*grid) +           np.sin(4*grid))*(4*np.cos(2*grid) +          8*np.cos(4*grid)) # calculate the derivative in fourier space y_freq=np.fft.fftfreq(N,d) yy_fft=np.fft.fft(y**2) fft=np.fft.ifft(2*np.pi*1j*y_freq*yy_fft).real fig,axs=plt.subplots(1,2,figsize=(10,5)) axs[0].plot(x,gd,label='$[\\partial (\\sin(2x)+\\sin(4x)^2) / \\partial x ]$') axs[0].scatter(grid,fft,                label='$[\\partial (\\sin(2x)+\\sin(4x)^2 / \\partial x ]_{fft}$',                linestyle='--',color=\"orange\") axs[0].legend() axs[0].set_title('Error without dealiasing: {:.2f}'.format(np.mean(np.abs(gd_test-fft))))  # calculate the derivative in fourier space with dealiasing wave_number_fft=np.abs(y_freq*L) mask=np.where(wave_number_fft&gt;N/3,0,1) y_masked=np.fft.ifft(np.fft.fft(y)*mask).real yy_fft=np.fft.fft(y_masked**2) fft=np.fft.ifft(2*np.pi*1j*y_freq*yy_fft).real axs[1].plot(x,             gd,             label='$[\\partial (\\sin(2x)+\\sin(4x)^2 / \\partial x ]$') axs[1].scatter(grid,                fft,                label='$[\\partial (\\sin(2x)+\\sin(4x)^2 / \\partial x ]_{fft}$',                linestyle='--',                color=\"orange\") axs[1].legend() axs[1].set_title('Error with dealiasing: {:.2f}'.format(     np.mean(np.abs(gd_test-fft))     )) plt.show() <p>As the result shows, the de-aliasing does reduce the error. However, it still provides a very rough approximation of the correct result due to the dropped high-frequency components. In the <code>TorchFSM</code>, we use this $2/3$ rule by default.</p> <p>Note</p> <p>         De-aliasing is an important and necessary technique in the Fourier spectral method, and there are many other advanced de-aliasing techniques, we would recommend the following references for more information:     </p> <p>         [1] Steven A. Orszag. \"On the Elimination of Aliasing in Finite-Difference Schemes by Filtering High-Wavenumber Components.\" Journal of the Atmospheric Sciences 28.6 (1971): 1074.     </p> <p>         [2] John C. Bowman. \u201cHow Important is Dealiasing for Turbulence Simulations?\u201d (online slides: http://helper.ipam.ucla.edu/publications/mtws1/mtws1 12187.pdf). University of Alberta (2014)     </p> <p>For now, we have introduced some basic theories on the Fourier Spectral method related to <code>TorchFSM</code>. With all these concepts, we can start to utilize <code>TorchFSM</code> to solve PDE problems.</p>"},{"location":"theory/#theory-introduction","title":"Theory Introduction\u00b6","text":"<p><code>TorchFSM</code> is a Python package designed for scientific computing, leveraging the Fourier-Spectral Method for solving partial differential equations (PDEs). In this notebook, we would like to show you a basic theoretical background of the Fourier-Spectral Method. After reading this notebook, you will be able to understand the key idea behind <code>TorchFSM</code>.</p>"},{"location":"theory/#spectral-method","title":"Spectral Method\u00b6","text":"<p>Let's first consider a general PDE for a scalar $\\phi$:</p> $$ \\begin{matrix} \\frac{\\partial \\phi (\\mathbf{x})}{\\partial t}+\\mathcal{P}(\\phi(\\mathbf{x}))=s(\\mathbf{x}), &amp; \\mathbf{x} \\in \\Omega, \\\\ \\mathcal{B}(\\phi(\\mathbf{x}))=h(\\mathbf{x}), &amp; \\mathbf{x} \\in \\partial \\Omega, \\end{matrix} $$<p>where $\\mathcal{P}$ and $\\mathcal{B}$ are spatial differential operators, $s$ and $h$ are source functions, $\\Omega$ is the spatial domain with boundary of $\\partial \\Omega$.</p> <p>In the spectral method, we use a series of trial functions $\\psi_j$ to expand the original function $\\phi(\\mathbf{x})$ on spatial space:</p> $$ \\phi(\\mathbf{x}) = \\int c_j \\psi_i(\\mathbf{x}) d_j. $$<p>Given the trial functions $\\psi_i$, solving the original PDE for the physical variable $\\phi$ reduces to finding the coefficients $c_i$ that satisfy the PDE. That is, we transform the solution domain from the physical space to the coefficient space.</p> <p>The Fourier spectral method utilizes the Fourier basis functions as the trial functions, i.e., $$ \\phi(\\mathbf{x}) = \\int \\hat{\\phi}(\\mathbf{f}) e^{2 \\pi i \\mathbf{f}\\cdot \\mathbf{x}} d\\mathbf{f}. $$ Here, $\\hat{\\phi}(\\mathbf{f})$ with the frequency $\\mathbf{f}$, as the coefficient space in our previous notation, is usually called the value of $\\phi_j(\\mathbf{x})$ in spectral space. The transformation from physical space to spectral space is the Fourier transformation: $$ \\mathcal{F}[\\phi(\\mathbf{x})] = \\hat{\\phi}(\\mathbf{f}) = \\int \\phi(\\mathbf{x}) e^{-2 \\pi i \\mathbf{f}\\cdot \\mathbf{x}} d\\mathbf{x}, $$ and the inverse Fourier transformation brings us back to the physical space from the spectral space: $$ \\mathcal{F}^{-1}[\\hat{\\phi}(\\mathbf{f})] = \\phi(\\mathbf{x}) = \\int \\hat{\\phi}(\\mathbf{f}) e^{2 \\pi i \\mathbf{f}\\cdot \\mathbf{x}} d\\mathbf{f}. $$</p> <p>The Fourier transformation assumes periodicity in the solution, meaning the solution is inherently periodic. Thus, the Fourier spectral method is usually used for problems with periodic boundary condition.</p> <p>Note</p> <p>         The trial functions of Fourier transformation are actually a series of sinusoidal functions with different wave numbers $k=H f$ where $H$ is the domain length, as $e^{i \\frac{2\\pi}{H}k x}=\\cos \\frac{2\\pi}{H}kx +\\sin \\frac{2\\pi}{H}kx$. If you are not familiar with the Fourier transformation, we can recommend this awesome video for a quick introduction.     </p>"},{"location":"theory/#linear-and-nonlinear-terms","title":"Linear and Nonlinear terms\u00b6","text":"<p>With the discussion above, we can now try to transform the PDE into the spectral space with the Fourier transformation: $$ \\frac{\\partial \\hat{\\phi}(\\mathbf{f})}{\\partial t}+ \\mathcal{F}[\\mathcal{P}(\\phi(\\mathbf{x}))-s(\\mathbf{x})]=0. $$ Once we can solve the above PDE, we can send the obtained solution back to the physical space through the inverse Fourier transformation.  The key problem here turns to how to calculate the Fourier transformation of $\\mathcal{P}(\\phi(\\mathbf{x}))-s(\\mathbf{x})$. Thanks to the linear property of the Fourier transformation, $\\mathcal{F}[a f(\\mathbf{x})+ b g(\\mathbf{x})]=a\\mathcal{F}[f(\\mathbf{x})]+b\\mathcal{F}[g(\\mathbf{x})]$, we can separate $\\mathcal{P}(\\phi(\\mathbf{x}))-s(\\mathbf{x})$ into different terms and calculate their Fourier transformation according to their properties.</p>"},{"location":"theory/#linear-terms","title":"Linear terms\u00b6","text":"<p>Linear terms refer to the terms that can be written as $L \\hat{\\phi}(\\mathbf{f})$ where $L$ is a coefficient function independent of $\\hat{\\phi}(\\mathbf{f})$. It not only includes the simple source terms, e.g., $L \\phi(x)$, but also the spatial differential operators, e.g., $\\nabla \\phi(\\mathbf{x})$, $\\nabla^2 \\phi(\\mathbf{x})$, etc. This is due to the derivative property of the Fourier transformation: $$ \\mathcal{F}[\\frac{d^n \\phi(\\mathbf{x})}{d\\mathbf{x}^n}]= (2\\pi i \\mathbf{f})^n \\hat{\\phi}(\\mathbf{f}) $$ For example, the Fourier transformation of $\\nabla \\phi (\\mathbf{x})=[\\partial \\phi/\\partial x, \\partial \\phi/\\partial y, \\cdots]^\\top$ is $\\mathcal{F}[\\nabla \\phi (\\mathbf{x})]=[2\\pi i f_x, 2\\pi i f_y, \\cdots]^\\top \\hat{\\phi}(\\mathbf{f})$.</p> <p>Below is a simple example demonstrating how to use the Fourier transformation to calculate derivatives:</p>"},{"location":"theory/#nonlinear-terms","title":"NonLinear terms\u00b6","text":"<p>Nonlinear terms refer to the terms that can not be written as $L \\hat{\\phi}(\\mathbf{f})$. In physical space, the nonlinear terms are usually terms with the product of two or more functions dependent on $\\mathbf{x}$, e.g., $\\phi^2(\\mathbf{x})$, $\\nabla \\phi(\\mathbf{x}) \\cdot \\nabla \\phi(\\mathbf{x})$, etc. In the spectral space, the Fourier transformation of the product can be calculated by the convolution theorem: $$ \\mathcal{F}[f(\\mathbf{x})g(\\mathbf{x})]=\\mathcal{F}[f(\\mathbf{x})]*\\mathcal{F}[g(\\mathbf{x})], $$ where $*$ denotes the convolution operation. However, the convolution operation is usually very expensive. Thus, we usually calculate the nonlinear terms in the physical space and then transform them back into the spectral space. For example, the Fourier transformation of $\\nabla \\phi(\\mathbf{x}) \\cdot \\nabla \\phi(\\mathbf{x})$ is: $$ \\mathcal{F}[\\nabla \\phi(\\mathbf{x}) \\cdot \\nabla \\phi(\\mathbf{x})]=\\mathcal{F}[\\mathcal{F}^{-1}[ [2\\pi i f_x, 2\\pi i f_y, \\cdots]^\\top \\hat{\\phi}(\\mathbf{f}) ]^2] $$</p> <p>Solving nonlinear terms back to the physical space is why the Fourier spectral method is usually called a pseudo-spectral method as not all operations are done in the spectral space.</p>"},{"location":"theory/#time-integration","title":"Time integration\u00b6","text":"<p>With the definition of the linear and nonlinear terms, we can turn the original PDE into the spectral space as: $$ \\frac{\\partial \\hat{\\phi}(\\mathbf{f})}{\\partial t}=L \\hat{\\phi}(\\mathbf{f})+ N(\\hat{\\phi}(\\mathbf{f})) $$ where $L$ is the linear coefficient and $N$ is the nonlinear function. The PDE is now transformed into a system of ODEs, which means we can use the ODE solvers, e.g., Euler and Runge-Kutta, to integrate the ODEs in time to get the solution of the PDE. However, in the Fourier spectral method, other groups of methods utilize the different features of linear and nonlinear terms to provide a better integration for the ODE. This kind of method is usually known as Exponential Time Differencing Runge-Kutta (ETDRK) method.</p> <p>Note</p> <p>         We will not discuss the details of the ETDRK method in this notebook. If you are interested in this topic, you can refer to the following papers:     </p> <p>         [1] Cox, Steven M., and Paul C. Matthews. \"Exponential time differencing for stiff systems.\" Journal of Computational Physics 176.2 (2002): 430-455.     </p> <p>         [2] Kassam, Aly-Khan, and Lloyd N. Trefethen. \"Fourth-order time-stepping for stiff PDEs.\" SIAM Journal on Scientific Computing 26.4 (2005): 1214-1233.     </p> <p>In <code>TorchFSM</code>, the default time integration method is the ETDRK method. But traditional ODE solvers are also provided for users to choose.</p>"},{"location":"theory/#discretization-and-aliasing-error","title":"Discretization and Aliasing error\u00b6","text":""},{"location":"theory/#aliasing-error","title":"Aliasing error\u00b6","text":"<p>Directly calculating the accurate and inverse Fourier transformations could be tricky and expensive. Thus, we usually perform a discrete Fourier transformation on a series of grid points. In a simple 1d mesh with $N$ grid points, the discrete Fourier transformation is:</p> $$\\hat{\\phi}_k = \\sum_{j=0}^{N-1} \\phi_j e^{-2\\pi i j k/N}$$<p>where $k$ is the wave number and $j$\u200b is the grid index. The Fast Fourier Transformation (FFT) algorithm can efficiently calculate the discrete Fourier transformation.</p> <p>Similar to truncation errors in the finite difference method, the Fourier spectral method is subject to aliasing errors caused by discretization. The source of aliasing errors is the fact that a mesh with a certain number of nodes can only accurately resolve signals with frequencies below a certain threshold. Let's explain this point through a very simple configuration. Consider a 1d mesh with  $N$ mesh grids and the domain length of $2\\pi$ so that we can simply give a periodic field $\\sin (kx)$ with different wavenumber $k$, i.e., different frequency. Then, the location of the $j$th grid point would be $2\\pi j/N$. Now, let's consider two sinusoidal fields with wave numbers of $k_1$ and $k_2$. Then, the value at $j$th grid point would be</p> $$ \\phi_{j,k_1}=\\sin( 2\\pi j k_1/N) $$<p>and</p> $$ \\phi_{j,k_2}=\\sin( 2\\pi j k_2/N)=\\sin[ 2\\pi j k_1/N+2\\pi j (k_2-k_1)/N] $$<p>Since $j=0,1,\\cdots N-1$, we can obtain that</p> $$ \\begin{matrix} \\phi_{j,k_1}=-\\phi_{j,k_2}, &amp; \\text{if}  &amp; j(k_2-k_1) \\in [\\frac{N}{2},\\frac{3N}{2},\\frac{5N}{2}, \\cdots] \\\\ \\phi_{j,k_1}=\\phi_{j,k_2}, &amp; \\text{if}  &amp; j(k_2-k_1) \\in [N,2N,3N, \\cdots] \\end{matrix} $$<p>So, if you have $k_2 \\geq \\frac{N}{2}$, you can always find a $k_1$ between $[0, \\frac{N}{2})$ to make $k_2-k_1$ satisfy one of the above conditions. This conclusion shows that, actually, the largest wave number that a discrete grid can resolve is $N/2$ (corresponding to Nyquist frequency). Any signal has a wavenumber larger or equal to $N/2$ will overlap to a signal whose wavenumber is smaller than $N/2$. We can use a simple code example to illustrate this point:</p>"},{"location":"theory/#de-aliasing","title":"De-aliasing\u00b6","text":"<p>To reduce the aliasing error, we can use the so-called de-aliasing technique.</p> <p>We need to point out first that the only available way to resolve the high-frequency field is to increase the number of grid points $N$. For example, you can never accurately $\\partial sin(6x) / \\partial x$ correctly with only 10 grid points using Fourier Transformation. The \"reducing aliasing errorS\" actually refers to a situation where the grid points can resolve the original field, but the new field generated by the nonlinear terms can not. Sounds a little bit confusing? Let's take an example.</p> <p>Considering that if we still have 10 grid points and the target field is $\\sin(2x)+\\sin(4x)$. The grid can resolve this field as the wave number of both fields is smaller than the threshold $N/2=5$. However, if we apply a nonlinear operator, e.g., $(\\sin(2x)+\\sin(4x))^2=\\sin^2(2x)+sin^2(4x)+2*sin(2x)*sin(4x)$, you will find that actually the later two components in the result can not be resolved by the grid points. You may think it is fine since the high-frequency components can not be resolved, and we can just drop them. However, as we have discussed before, the high-frequency components will overlap with the low-frequency components and contaminate the low-frequency components. That means the unresolved high-frequency components will affect the low-frequency components, which we should resolve accurately with the grid points. This is the aliasing error we are talking about.</p> <p>So, the aim of de-aliasing is to prevent the high-frequency components generated by the nonlinear terms from overlapping with the low-frequency components, which we are supposed to calculate accurately. The simplest approach is to filter out modes with frequencies exceeding the threshold $N/2$ after nonlinear operations. One of the most common techniques is the 2/3 rule, which filters out all modes with wave numbers larger than $2/3$ of the threshold $N/2$, i.e., $k&gt;N/3$.</p> <p>We can use some code to illustrate how the 2/3 rule works with the example we discussed above:</p>"},{"location":"apis/field/","title":"5. field","text":""},{"location":"apis/field/#torchfsm.field.diffused_noise","title":"torchfsm.field.diffused_noise","text":"<pre><code>diffused_noise(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    diffusion_coef: float = 1.0,\n    zero_centered: bool = True,\n    unit_variance: bool = True,\n    unit_magnitude: bool = True,\n    device: Optional[device] = None,\n    dtype: Optional[dtype] = None,\n    n_batch: int = 1,\n    n_channel: int = 1,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Generate a diffused noise field.     The noise is generated by integrating a Laplacian operator with a random initial condition.     The diffusion coefficient controls the amount of diffusion applied to the noise.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>The mesh to generate the noise on. If a sequence is provided, it should be in the form of [(x_min, x_max, n_points), ...].</p> required <code>diffusion_coef</code> <code>float</code> <p>The diffusion coefficient. Default is 1.0.</p> <code>1.0</code> <code>zero_centered</code> <code>bool</code> <p>If True, the noise will be zero-centered. Default is True.</p> <code>True</code> <code>unit_variance</code> <code>bool</code> <p>If True, the noise will have unit variance. Default is True.</p> <code>True</code> <code>unit_magnitude</code> <code>bool</code> <p>If True, the noise will have unit magnitude. Default is True.</p> <code>True</code> <code>device</code> <code>Optional[device]</code> <p>The device to generate the noise on. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>The data type of the generated noise. Default is None.</p> <code>None</code> <code>n_batch</code> <code>int</code> <p>The number of batches. Default is 1.</p> <code>1</code> <code>n_channel</code> <code>int</code> <p>The number of channels. Default is 1.</p> <code>1</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...]: The generated diffused noise field.</p> Source code in <code>torchfsm/field.py</code> <pre><code>def diffused_noise(\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    diffusion_coef: float = 1.0,\n    zero_centered: bool = True,\n    unit_variance: bool = True,\n    unit_magnitude: bool = True,\n    device: Optional[torch.device] = None,\n    dtype: Optional[torch.dtype] = None,\n    n_batch: int = 1,\n    n_channel: int = 1,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Generate a diffused noise field.\n        The noise is generated by integrating a Laplacian operator with a random initial condition.\n        The diffusion coefficient controls the amount of diffusion applied to the noise.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): The mesh to generate the noise on.\n            If a sequence is provided, it should be in the form of [(x_min, x_max, n_points), ...].\n        diffusion_coef (float): The diffusion coefficient. Default is 1.0.\n        zero_centered (bool): If True, the noise will be zero-centered. Default is True.\n        unit_variance (bool): If True, the noise will have unit variance. Default is True.\n        unit_magnitude (bool): If True, the noise will have unit magnitude. Default is True.\n        device (Optional[torch.device]): The device to generate the noise on. Default is None.\n        dtype (Optional[torch.dtype]): The data type of the generated noise. Default is None.\n        n_batch (int): The number of batches. Default is 1.\n        n_channel (int): The number of channels. Default is 1.\n\n    Returns:\n        SpatialTensor[\"B C H ...]: The generated diffused noise field.\n    \"\"\"\n    if device is None and (isinstance(mesh, FourierMesh) or isinstance(mesh, MeshGrid)):\n        device = mesh.device\n    if dtype is None and (isinstance(mesh, FourierMesh) or isinstance(mesh, MeshGrid)):\n        dtype = mesh.dtype\n    u_0 = torch.randn(\n        *mesh_shape(mesh, n_batch=n_batch, n_channel=n_channel),\n        device=device,\n        dtype=dtype\n    )\n    diffusion = diffusion_coef * Laplacian()\n    u_0 = diffusion.integrate(u_0, dt=1, step=1, mesh=mesh)\n    if zero_centered:\n        u_0 = u_0 - u_0.mean()\n    if unit_variance:\n        u_0 = u_0 / u_0.std()\n    if unit_magnitude:\n        u_0 = u_0 / u_0.abs().max()\n    return u_0\n</code></pre>"},{"location":"apis/field/#torchfsm.field.kolm_force","title":"torchfsm.field.kolm_force","text":"<pre><code>kolm_force(\n    x: Tensor,\n    drag_coef: float = -0.1,\n    k: float = 4.0,\n    length_scale: float = 1.0,\n) -&gt; Operator\n</code></pre> <p>Generate cosine force field for 2d kolmogorov flow in vorticity form.     It is defined as \\(a \\omega - k cos (k l x)\\)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Tensor</code> <p>The input tensor.</p> required <code>drag_coef</code> <code>float</code> <p>The drag coefficient \\(a\\). Default is -0.1.</p> <code>-0.1</code> <code>k</code> <code>float</code> <p>The wave number. Default is 4.0.</p> <code>4.0</code> <code>length_scale</code> <code>float</code> <p>The length scale \\(l\\). Default is 1.0.</p> <code>1.0</code> Source code in <code>torchfsm/field.py</code> <pre><code>def kolm_force(\n    x: torch.Tensor,\n    drag_coef: float = -0.1,\n    k: float = 4.0,\n    length_scale: float = 1.0,\n) -&gt; Operator:\n    r\"\"\"\n    Generate cosine force field for 2d kolmogorov flow in vorticity form.\n        It is defined as $a \\omega - k cos (k l x)$\n\n    Args:\n        x (torch.Tensor): The input tensor.\n        drag_coef (float): The drag coefficient $a$. Default is -0.1.\n        k (float): The wave number. Default is 4.0.\n        length_scale (float): The length scale $l$. Default is 1.0.\n    \"\"\"\n\n\n    return drag_coef * ImplicitSource() - ExplicitSource(\n        k * torch.cos(k * length_scale * x)\n    )\n</code></pre>"},{"location":"apis/field/#torchfsm.field.wave_1d","title":"torchfsm.field.wave_1d","text":"<pre><code>wave_1d(\n    x: SpatialTensor[\"B C H ...\"],\n    min_k: int = 1,\n    max_k: int = 5,\n    min_amplitude: float = 0.5,\n    max_amplitude: float = 1.0,\n    n_polynomial: int = 5,\n    zero_mean: bool = False,\n    mean_shift_coef=0.3,\n    batched: bool = False,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Generate a 1D wave field with multiple harmonics.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>SpatialTensor['B C H ...']</code> <p>The input tensor.</p> required <code>min_k</code> <code>int</code> <p>The minimum wave number. Default is 1.</p> <code>1</code> <code>max_k</code> <code>int</code> <p>The maximum wave number. Default is 5.</p> <code>5</code> <code>min_amplitude</code> <code>float</code> <p>The minimum amplitude. Default is 0.5.</p> <code>0.5</code> <code>max_amplitude</code> <code>float</code> <p>The maximum amplitude. Default is 1.0.</p> <code>1.0</code> <code>n_polynomial</code> <code>int</code> <p>The number of polynomial terms. Default is 5.</p> <code>5</code> <code>zero_mean</code> <code>bool</code> <p>If True, the mean of the wave will be zero. Default is False.</p> <code>False</code> <code>mean_shift_coef</code> <code>float</code> <p>The coefficient for mean shift. Default is 0.3.</p> <code>0.3</code> <code>batched</code> <code>bool</code> <p>If True, the input tensor is batched. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The generated wave field.</p> Source code in <code>torchfsm/field.py</code> <pre><code>def wave_1d(\n    x: SpatialTensor[\"B C H ...\"],\n    min_k: int = 1,\n    max_k: int = 5,\n    min_amplitude: float = 0.5,\n    max_amplitude: float = 1.0,\n    n_polynomial: int = 5,\n    zero_mean: bool = False,\n    mean_shift_coef=0.3,\n    batched: bool = False,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Generate a 1D wave field with multiple harmonics.\n\n    Args:\n        x (SpatialTensor[\"B C H ...\"]): The input tensor.\n        min_k (int): The minimum wave number. Default is 1.\n        max_k (int): The maximum wave number. Default is 5.\n        min_amplitude (float): The minimum amplitude. Default is 0.5.\n        max_amplitude (float): The maximum amplitude. Default is 1.0.\n        n_polynomial (int): The number of polynomial terms. Default is 5.\n        zero_mean (bool): If True, the mean of the wave will be zero. Default is False.\n        mean_shift_coef (float): The coefficient for mean shift. Default is 0.3.\n        batched (bool): If True, the input tensor is batched. Default is False.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The generated wave field.\n    \"\"\"\n    x_new = x / x.max() * torch.pi * 2\n    y = torch.zeros_like(x)\n    if not batched:\n        x_new = x_new.unsqueeze(0)\n        y = y.unsqueeze(0)\n    batch = x_new.shape[0]\n    shape = [batch, n_polynomial] + [1] * (x_new.dim() - 2)\n    k = torch.randint(min_k, max_k + 1, shape, device=x.device, dtype=x.dtype)\n    amplitude = (\n        torch.rand(*shape, device=x.device, dtype=x.dtype)\n        * (max_amplitude - min_amplitude)\n        + min_amplitude\n    )\n    shift = torch.rand(*shape, device=x.device, dtype=x.dtype) * torch.pi * 2\n    for i in range(n_polynomial):\n        y += amplitude[:, i : i + 1, ...] * torch.sin(\n            k[:, i : i + 1, ...] * (x_new + shift[:, i : i + 1, ...])\n        )\n    if not zero_mean:\n        value_shift = torch.rand(\n            [batch] + [1] * (x_new.dim() - 1), device=x.device, dtype=x.dtype\n        )\n        value_shift = (value_shift - 0.5) * 2 * (\n            max_amplitude - min_amplitude\n        ) * mean_shift_coef + min_amplitude\n        y += value_shift\n    if not batched:\n        y = y.squeeze(0)\n    return y\n</code></pre>"},{"location":"apis/functional/","title":"3. functional","text":""},{"location":"apis/functional/#torchfsm.functional.biharmonic","title":"torchfsm.functional.biharmonic","text":"<pre><code>biharmonic(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the biharmonic operator.     For details, see <code>torchfsm.operator.Biharmonic</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor['B C H ...']]</code> <p>The input field.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor['B C H ...']]</code> <p>The Fourier-transformed input field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the biharmonic operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def biharmonic(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Function form for the biharmonic operator.\n        For details, see `torchfsm.operator.Biharmonic`.\n\n    Args:\n        u (Optional[SpatialTensor[\"B C H ...\"]]): The input field.\n        u_fft (Optional[FourierTensor[\"B C H ...\"]]): The Fourier-transformed input field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the biharmonic operator to the input field.   \n    \"\"\"\n    return Biharmonic()(u=u, u_fft=u_fft, mesh=mesh)\n</code></pre>"},{"location":"apis/functional/#torchfsm.functional.conservative_convection","title":"torchfsm.functional.conservative_convection","text":"<pre><code>conservative_convection(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the conservative convection operator.     For details, see <code>torchfsm.operator.ConservativeConvection</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor['B C H ...']]</code> <p>The input field.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor['B C H ...']]</code> <p>The Fourier-transformed input field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the conservative convection operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def conservative_convection(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Function form for the conservative convection operator.\n        For details, see `torchfsm.operator.ConservativeConvection`.\n\n    Args:\n        u (Optional[SpatialTensor[\"B C H ...\"]]): The input field.\n        u_fft (Optional[FourierTensor[\"B C H ...\"]]): The Fourier-transformed input field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the conservative convection operator to the input field.\n    \"\"\"\n    return ConservativeConvection()(u=u, u_fft=u_fft, mesh=mesh)\n</code></pre>"},{"location":"apis/functional/#torchfsm.functional.convection","title":"torchfsm.functional.convection","text":"<pre><code>convection(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the convection operator.     For details, see <code>torchfsm.operator.Convection</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor['B C H ...']]</code> <p>The input field.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor['B C H ...']]</code> <p>The Fourier-transformed input field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the convection operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def convection(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Function form for the convection operator.\n        For details, see `torchfsm.operator.Convection`.\n\n    Args:\n        u (Optional[SpatialTensor[\"B C H ...\"]]): The input field.\n        u_fft (Optional[FourierTensor[\"B C H ...\"]]): The Fourier-transformed input field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the convection operator to the input field.\n    \"\"\"\n\n    return Convection()(u=u, u_fft=u_fft, mesh=mesh)\n</code></pre>"},{"location":"apis/functional/#torchfsm.functional.curl","title":"torchfsm.functional.curl","text":"<pre><code>curl(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the curl operator.     For details, see <code>torchfsm.operator.Curl</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor['B C H ...']]</code> <p>The input field.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor['B C H ...']]</code> <p>The Fourier-transformed input field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the curl operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def curl(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Function form for the curl operator.\n        For details, see `torchfsm.operator.Curl`.\n\n    Args:\n        u (Optional[SpatialTensor[\"B C H ...\"]]): The input field.\n        u_fft (Optional[FourierTensor[\"B C H ...\"]]): The Fourier-transformed input field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the curl operator to the input field.\n    \"\"\"\n\n    return Curl()(u=u, u_fft=u_fft, mesh=mesh)\n</code></pre>"},{"location":"apis/functional/#torchfsm.functional.div","title":"torchfsm.functional.div","text":"<pre><code>div(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the divergence operator.     For details, see <code>torchfsm.operator.Div</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor['B C H ...']]</code> <p>The input field.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor['B C H ...']]</code> <p>The Fourier-transformed input field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the divergence operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def div(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Function form for the divergence operator.\n        For details, see `torchfsm.operator.Div`.\n\n    Args:\n        u (Optional[SpatialTensor[\"B C H ...\"]]): The input field.\n        u_fft (Optional[FourierTensor[\"B C H ...\"]]): The Fourier-transformed input field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the divergence operator to the input field.\n    \"\"\"\n\n    return Div()(u=u, u_fft=u_fft, mesh=mesh)\n</code></pre>"},{"location":"apis/functional/#torchfsm.functional.grad","title":"torchfsm.functional.grad","text":"<pre><code>grad(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the gradient operator.     For details, see <code>torchfsm.operator.Grad</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor['B C H ...']]</code> <p>The input field.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor['B C H ...']]</code> <p>The Fourier-transformed input field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the gradient operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def grad(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Function form for the gradient operator.\n        For details, see `torchfsm.operator.Grad`.\n\n    Args:\n        u (Optional[SpatialTensor[\"B C H ...\"]]): The input field.\n        u_fft (Optional[FourierTensor[\"B C H ...\"]]): The Fourier-transformed input field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the gradient operator to the input field.\n    \"\"\"\n\n    return Grad()(u=u, u_fft=u_fft, mesh=mesh)\n</code></pre>"},{"location":"apis/functional/#torchfsm.functional.laplacian","title":"torchfsm.functional.laplacian","text":"<pre><code>laplacian(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the Laplacian operator.     For details, see <code>torchfsm.operator.Laplacian</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor['B C H ...']]</code> <p>The input field.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor['B C H ...']]</code> <p>The Fourier-transformed input field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the Laplacian operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def laplacian(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Function form for the Laplacian operator.\n        For details, see `torchfsm.operator.Laplacian`.\n\n    Args:\n        u (Optional[SpatialTensor[\"B C H ...\"]]): The input field.\n        u_fft (Optional[FourierTensor[\"B C H ...\"]]): The Fourier-transformed input field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the Laplacian operator to the input field.\n    \"\"\"\n    return Laplacian()(u=u, u_fft=u_fft, mesh=mesh)\n</code></pre>"},{"location":"apis/functional/#torchfsm.functional.spatial_derivative","title":"torchfsm.functional.spatial_derivative","text":"<pre><code>spatial_derivative(\n    dim_index: int,\n    order: int,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the spatial derivative operator.     For details, see <code>torchfsm.operator.SpatialDerivative</code>.</p> <p>Parameters:</p> Name Type Description Default <code>dim_index</code> <code>int</code> <p>The index of the dimension to take the derivative along.</p> required <code>order</code> <code>int</code> <p>The order of the derivative.</p> required <code>u</code> <code>Optional[SpatialTensor['B C H ...']]</code> <p>The input field.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor['B C H ...']]</code> <p>The Fourier-transformed input field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the spatial derivative operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def spatial_derivative(\n    dim_index: int,\n    order: int,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Function form for the spatial derivative operator.\n        For details, see `torchfsm.operator.SpatialDerivative`.\n\n    Args:\n        dim_index (int): The index of the dimension to take the derivative along.\n        order (int): The order of the derivative.\n        u (Optional[SpatialTensor[\"B C H ...\"]]): The input field.\n        u_fft (Optional[FourierTensor[\"B C H ...\"]]): The Fourier-transformed input field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the spatial derivative operator to the input field.\n    \"\"\"\n    return SpatialDerivative(dim_index, order)(u=u, u_fft=u_fft, mesh=mesh)\n</code></pre>"},{"location":"apis/functional/#torchfsm.functional.ks_convection","title":"torchfsm.functional.ks_convection","text":"<pre><code>ks_convection(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    remove_mean: bool = True,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the Kuramoto-Sivashinsky convection operator.     For details, see <code>torchfsm.operator.KSConvection</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor['B C H ...']]</code> <p>The input field.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor['B C H ...']]</code> <p>The Fourier-transformed input field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <code>remove_mean</code> <code>bool</code> <p>If True, the mean of the input field will be removed before applying the operator.</p> <code>True</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the Kuramoto-Sivashinsky convection operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def ks_convection(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    remove_mean: bool = True,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Function form for the Kuramoto-Sivashinsky convection operator.\n        For details, see `torchfsm.operator.KSConvection`.\n\n    Args:\n        u (Optional[SpatialTensor[\"B C H ...\"]]): The input field.\n        u_fft (Optional[FourierTensor[\"B C H ...\"]]): The Fourier-transformed input field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n        remove_mean (bool): If True, the mean of the input field will be removed before applying the operator.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the Kuramoto-Sivashinsky convection operator to the input field.\n    \"\"\"\n    return KSConvection(remove_mean)(u=u, u_fft=u_fft, mesh=mesh)\n</code></pre>"},{"location":"apis/functional/#torchfsm.functional.vorticity_convection","title":"torchfsm.functional.vorticity_convection","text":"<pre><code>vorticity_convection(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the vorticity convection operator.     For details, see <code>torchfsm.operator.VorticityConvection</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor['B C H ...']]</code> <p>The input field.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor['B C H ...']]</code> <p>The Fourier-transformed input field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the vorticity convection operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def vorticity_convection(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n\n    r\"\"\"\n    Function form for the vorticity convection operator.\n        For details, see `torchfsm.operator.VorticityConvection`.\n\n    Args:\n        u (Optional[SpatialTensor[\"B C H ...\"]]): The input field.\n        u_fft (Optional[FourierTensor[\"B C H ...\"]]): The Fourier-transformed input field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the vorticity convection operator to the input field.\n    \"\"\"\n    return VorticityConvection()(u=u, u_fft=u_fft, mesh=mesh)\n</code></pre>"},{"location":"apis/functional/#torchfsm.functional.vorticity2velocity","title":"torchfsm.functional.vorticity2velocity","text":"<pre><code>vorticity2velocity(\n    vorticity: Optional[Tensor] = None,\n    vorticity_fft: Optional[Tensor] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the vorticity to velocity operator.     For details, see <code>torchfsm.operator.Vorticity2Velocity</code>.</p> <p>Parameters:</p> Name Type Description Default <code>vorticity</code> <code>Optional[Tensor]</code> <p>The input vorticity field.</p> <code>None</code> <code>vorticity_fft</code> <code>Optional[Tensor]</code> <p>The Fourier-transformed vorticity field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the vorticity to velocity operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def vorticity2velocity(\n    vorticity: Optional[torch.Tensor] = None,\n    vorticity_fft: Optional[torch.Tensor] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Function form for the vorticity to velocity operator.\n        For details, see `torchfsm.operator.Vorticity2Velocity`.\n\n    Args:\n        vorticity (Optional[torch.Tensor]): The input vorticity field.\n        vorticity_fft (Optional[torch.Tensor]): The Fourier-transformed vorticity field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the vorticity to velocity operator to the input field.\n    \"\"\"\n\n    return Vorticity2Velocity()(u=vorticity, u_fft=vorticity_fft, mesh=mesh)\n</code></pre>"},{"location":"apis/functional/#torchfsm.functional.vorticity2pressure","title":"torchfsm.functional.vorticity2pressure","text":"<pre><code>vorticity2pressure(\n    vorticity: Optional[Tensor] = None,\n    vorticity_fft: Optional[Tensor] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    external_force: Optional[OperatorLike] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the vorticity to pressure operator.     For details, see <code>torchfsm.operator.Vorticity2Pressure</code>.</p> <p>Parameters:</p> Name Type Description Default <code>vorticity</code> <code>Optional[Tensor]</code> <p>The input vorticity field.</p> <code>None</code> <code>vorticity_fft</code> <code>Optional[Tensor]</code> <p>The Fourier-transformed vorticity field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <code>external_force</code> <code>Optional[OperatorLike]</code> <p>An optional external force to be applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the vorticity to pressure operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def vorticity2pressure(\n    vorticity: Optional[torch.Tensor] = None,\n    vorticity_fft: Optional[torch.Tensor] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    external_force: Optional[OperatorLike] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Function form for the vorticity to pressure operator.\n        For details, see `torchfsm.operator.Vorticity2Pressure`.\n\n    Args:\n        vorticity (Optional[torch.Tensor]): The input vorticity field.\n        vorticity_fft (Optional[torch.Tensor]): The Fourier-transformed vorticity field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n        external_force (Optional[OperatorLike]): An optional external force to be applied.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the vorticity to pressure operator to the input field.\n    \"\"\"\n\n    vorticity_fft, f_mesh = _get_fft_with_mesh(\n        value=vorticity, value_fft=vorticity_fft, mesh=mesh\n    )\n    velocity_fft = Vorticity2Velocity()(\n        u_fft=vorticity_fft, mesh=f_mesh, return_in_fourier=True\n    )\n    convection = Convection()(u_fft=velocity_fft, mesh=f_mesh, return_in_fourier=True)\n    if external_force is not None:\n        convection -= external_force(\n            u_fft=vorticity_fft, mesh=f_mesh, return_in_fourier=True\n        )\n    convection = Div()(u_fft=convection, mesh=f_mesh, return_in_fourier=True)\n    return Laplacian().solve(b_fft=-1 * convection, mesh=f_mesh, n_channel=1)\n</code></pre>"},{"location":"apis/functional/#torchfsm.functional.velocity2pressure","title":"torchfsm.functional.velocity2pressure","text":"<pre><code>velocity2pressure(\n    velocity: Optional[Tensor] = None,\n    velocity_fft: Optional[Tensor] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    external_force: Optional[OperatorLike] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Function form for the velocity to pressure operator.     For details, see <code>torchfsm.operator.Velocity2Pressure</code>.</p> <p>Parameters:</p> Name Type Description Default <code>velocity</code> <code>Optional[Tensor]</code> <p>The input velocity field.</p> <code>None</code> <code>velocity_fft</code> <code>Optional[Tensor]</code> <p>The Fourier-transformed velocity field.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>The mesh for the field.</p> <code>None</code> <code>external_force</code> <code>Optional[OperatorLike]</code> <p>An optional external force to be applied.</p> <code>None</code> <p>Returns:</p> Type Description <code>SpatialTensor['B C H ...']</code> <p>SpatialTensor[\"B C H ...\"]: The result of applying the velocity to pressure operator to the input field.</p> Source code in <code>torchfsm/functional.py</code> <pre><code>def velocity2pressure(\n    velocity: Optional[torch.Tensor] = None,\n    velocity_fft: Optional[torch.Tensor] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    external_force: Optional[OperatorLike] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Function form for the velocity to pressure operator.\n        For details, see `torchfsm.operator.Velocity2Pressure`.\n\n    Args:\n        velocity (Optional[torch.Tensor]): The input velocity field.\n        velocity_fft (Optional[torch.Tensor]): The Fourier-transformed velocity field.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): The mesh for the field.\n        external_force (Optional[OperatorLike]): An optional external force to be applied.\n\n    Returns:\n        SpatialTensor[\"B C H ...\"]: The result of applying the velocity to pressure operator to the input field.\n    \"\"\"\n\n    velocity_fft, f_mesh = _get_fft_with_mesh(\n        value=velocity, value_fft=velocity_fft, mesh=mesh\n    )\n    convection = Convection()(u_fft=velocity_fft, mesh=f_mesh, return_in_fourier=True)\n    if external_force is not None:\n        convection -= external_force(\n            u_fft=velocity_fft, mesh=f_mesh, return_in_fourier=True\n        )\n    convection = Div()(u_fft=convection, mesh=f_mesh, return_in_fourier=True)\n    return Laplacian().solve(b_fft=-1 * convection, mesh=f_mesh, n_channel=1)\n</code></pre>"},{"location":"apis/integrator/","title":"4. integrator","text":"<p>This library provides a set of integrators for simulations. The implementation of ETDRK method is modified from exponax</p>"},{"location":"apis/integrator/#etdrk","title":"ETDRK","text":""},{"location":"apis/integrator/#torchfsm.integrator.ETDRKIntegrator","title":"torchfsm.integrator.ETDRKIntegrator","text":"<p>               Bases: <code>Enum</code></p> <p>ETDRK Integrator Provides a unified interface for all ETDRK methods.</p> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>class ETDRKIntegrator(Enum):\n    \"\"\"\n    ETDRK Integrator\n    Provides a unified interface for all ETDRK methods.\n    \"\"\"\n    ETDRK0 = ETDRK0\n    ETDRK1 = ETDRK1\n    ETDRK2 = ETDRK2\n    ETDRK3 = ETDRK3\n    ETDRK4 = ETDRK4\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.ETDRKIntegrator.ETDRK0","title":"ETDRK0  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ETDRK0 = ETDRK0\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.ETDRKIntegrator.ETDRK1","title":"ETDRK1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ETDRK1 = ETDRK1\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.ETDRKIntegrator.ETDRK2","title":"ETDRK2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ETDRK2 = ETDRK2\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.ETDRKIntegrator.ETDRK3","title":"ETDRK3  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ETDRK3 = ETDRK3\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.ETDRKIntegrator.ETDRK4","title":"ETDRK4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ETDRK4 = ETDRK4\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk._ETDRKBase","title":"torchfsm.integrator._etdrk._ETDRKBase","text":"<p>               Bases: <code>ABC</code></p> <p>Solve $$ u_t=Lu+N(u) $$ using the ETDRK method.</p> <p>Parameters:</p> Name Type Description Default <code>dt(float)</code> <p>Time step.</p> required <code>linear_coef(torch.Tensor)</code> <p>Coefficient of the linear term, i.e., \\(L\\).</p> required <code>nonlinear_func(Callable[[torch.Tensor],torch.Tensor])</code> <p>Function that computes the nonlinear term, i.e., \\(N(u)\\).</p> required <code>num_circle_points(int)</code> <p>Number of points on the unit circle. See [2] for details.</p> required <code>circle_radius(float)</code> <p>Radius of the unit circle. See [2] for details.</p> required Reference <p>[1] Cox, Steven M., and Paul C. Matthews. \"Exponential time differencing for stiff systems.\" Journal of Computational Physics 176.2 (2002): 430-455. [2] Kassam, Aly-Khan, and Lloyd N. Trefethen. \"Fourth-order time-stepping for stiff PDEs.\" SIAM Journal on Scientific Computing 26.4 (2005): 1214-1233.</p> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>class _ETDRKBase(ABC):\n\n    \"\"\"\n    Solve\n    $$\n    u_t=Lu+N(u)\n    $$\n    using the ETDRK method.\n\n    Args:\n        dt(float): Time step.\n        linear_coef(torch.Tensor): Coefficient of the linear term, i.e., $L$.\n        nonlinear_func(Callable[[torch.Tensor],torch.Tensor]): Function that computes the nonlinear term, i.e., $N(u)$.\n        num_circle_points(int): Number of points on the unit circle. See [2] for details.\n        circle_radius(float): Radius of the unit circle. See [2] for details.\n\n    Reference:\n        [1] Cox, Steven M., and Paul C. Matthews. \"Exponential time differencing for stiff systems.\" Journal of Computational Physics 176.2 (2002): 430-455.\n        [2] Kassam, Aly-Khan, and Lloyd N. Trefethen. \"Fourth-order time-stepping for stiff PDEs.\" SIAM Journal on Scientific Computing 26.4 (2005): 1214-1233.\n    \"\"\"\n\n    def __init__(\n        self,\n        dt: float,\n        linear_coef:torch.Tensor,\n        nonlinear_func:Callable[[torch.Tensor],torch.Tensor],\n        num_circle_points: int = 16,\n        circle_radius: float = 1.0,\n        ):\n        self.dt = dt\n        self._nonlinear_func = nonlinear_func\n        self._exp_term = torch.exp(self.dt * linear_coef)\n        self.LR=(\n            circle_radius * roots_of_unity(num_circle_points,device=linear_coef.device,dtype=linear_coef.real.dtype)\n            + linear_coef.unsqueeze(-1) * dt\n            )\n\n    @abstractmethod\n    def step(\n        self,\n        u_hat,\n        ):\n        \"\"\"\n        Advance the state in Fourier space.\n        \"\"\"\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk._ETDRKBase.dt","title":"dt  <code>instance-attribute</code>","text":"<pre><code>dt = dt\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk._ETDRKBase.LR","title":"LR  <code>instance-attribute</code>","text":"<pre><code>LR = (\n    circle_radius\n    * roots_of_unity(\n        num_circle_points, device=device, dtype=dtype\n    )\n    + unsqueeze(-1) * dt\n)\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk._ETDRKBase.__init__","title":"__init__","text":"<pre><code>__init__(\n    dt: float,\n    linear_coef: Tensor,\n    nonlinear_func: Callable[[Tensor], Tensor],\n    num_circle_points: int = 16,\n    circle_radius: float = 1.0,\n)\n</code></pre> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>def __init__(\n    self,\n    dt: float,\n    linear_coef:torch.Tensor,\n    nonlinear_func:Callable[[torch.Tensor],torch.Tensor],\n    num_circle_points: int = 16,\n    circle_radius: float = 1.0,\n    ):\n    self.dt = dt\n    self._nonlinear_func = nonlinear_func\n    self._exp_term = torch.exp(self.dt * linear_coef)\n    self.LR=(\n        circle_radius * roots_of_unity(num_circle_points,device=linear_coef.device,dtype=linear_coef.real.dtype)\n        + linear_coef.unsqueeze(-1) * dt\n        )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk._ETDRKBase.step","title":"step  <code>abstractmethod</code>","text":"<pre><code>step(u_hat)\n</code></pre> <p>Advance the state in Fourier space.</p> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>@abstractmethod\ndef step(\n    self,\n    u_hat,\n    ):\n    \"\"\"\n    Advance the state in Fourier space.\n    \"\"\"\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK0","title":"torchfsm.integrator._etdrk.ETDRK0","text":"<p>Exactly solve a linear PDE in Fourier space</p> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>class ETDRK0():\n    \"\"\"\n    Exactly solve a linear PDE in Fourier space\n    \"\"\"\n    def __init__(\n        self,\n        dt: float,\n        linear_coef: torch.Tensor,\n    ):\n        self.dt = dt\n        self._exp_term = torch.exp(self.dt * linear_coef)\n\n    def step(\n        self,\n        u_hat,\n    ):\n        return self._exp_term * u_hat\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK0.dt","title":"dt  <code>instance-attribute</code>","text":"<pre><code>dt = dt\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK0.__init__","title":"__init__","text":"<pre><code>__init__(dt: float, linear_coef: Tensor)\n</code></pre> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>def __init__(\n    self,\n    dt: float,\n    linear_coef: torch.Tensor,\n):\n    self.dt = dt\n    self._exp_term = torch.exp(self.dt * linear_coef)\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK0.step","title":"step","text":"<pre><code>step(u_hat)\n</code></pre> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>def step(\n    self,\n    u_hat,\n):\n    return self._exp_term * u_hat\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK1","title":"torchfsm.integrator._etdrk.ETDRK1","text":"<p>               Bases: <code>_ETDRKBase</code></p> <p>First-order ETDRK method.</p> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>class ETDRK1(_ETDRKBase):\n\n    \"\"\"\n    First-order ETDRK method.\n    \"\"\"\n\n    def __init__(\n        self,\n        dt: float,\n        linear_coef: torch.Tensor,\n        nonlinear_func:Callable[[torch.Tensor],torch.Tensor],\n        num_circle_points: int = 16,\n        circle_radius: float = 1.0,\n        ):\n        super().__init__(dt, linear_coef,nonlinear_func,num_circle_points,circle_radius)\n        self._coef_1 = dt * torch.mean((torch.exp(self.LR) - 1) / self.LR, axis=-1).real\n\n    def step(\n        self,\n        u_hat,\n        ):\n        return self._exp_term * u_hat + self._coef_1 * self._nonlinear_func(u_hat)\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK1.dt","title":"dt  <code>instance-attribute</code>","text":"<pre><code>dt = dt\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK1.LR","title":"LR  <code>instance-attribute</code>","text":"<pre><code>LR = (\n    circle_radius\n    * roots_of_unity(\n        num_circle_points, device=device, dtype=dtype\n    )\n    + unsqueeze(-1) * dt\n)\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK1.__init__","title":"__init__","text":"<pre><code>__init__(\n    dt: float,\n    linear_coef: Tensor,\n    nonlinear_func: Callable[[Tensor], Tensor],\n    num_circle_points: int = 16,\n    circle_radius: float = 1.0,\n)\n</code></pre> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>def __init__(\n    self,\n    dt: float,\n    linear_coef: torch.Tensor,\n    nonlinear_func:Callable[[torch.Tensor],torch.Tensor],\n    num_circle_points: int = 16,\n    circle_radius: float = 1.0,\n    ):\n    super().__init__(dt, linear_coef,nonlinear_func,num_circle_points,circle_radius)\n    self._coef_1 = dt * torch.mean((torch.exp(self.LR) - 1) / self.LR, axis=-1).real\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK1.step","title":"step","text":"<pre><code>step(u_hat)\n</code></pre> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>def step(\n    self,\n    u_hat,\n    ):\n    return self._exp_term * u_hat + self._coef_1 * self._nonlinear_func(u_hat)\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK2","title":"torchfsm.integrator._etdrk.ETDRK2","text":"<p>               Bases: <code>_ETDRKBase</code></p> <p>Second-order ETDRK method.</p> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>class ETDRK2(_ETDRKBase):\n    \"\"\"\n    Second-order ETDRK method.\n    \"\"\"\n\n    def __init__(\n        self,\n        dt: float,\n        linear_coef: torch.Tensor,\n        nonlinear_func:Callable[[torch.Tensor],torch.Tensor],\n        num_circle_points: int = 16,\n        circle_radius: float = 1.0,\n        ):\n        super().__init__(dt, linear_coef,nonlinear_func,num_circle_points,circle_radius)\n        self._coef_1 = dt * torch.mean((torch.exp(self.LR) - 1) / self.LR, axis=-1).real\n        self._coef_2 = dt * torch.mean((torch.exp(self.LR) - 1 - self.LR) / self.LR**2, axis=-1).real\n\n    def step(\n        self,\n        u_hat,\n        ):\n        u_nonlin_hat = self._nonlinear_func(u_hat)\n        u_stage_1_hat = self._exp_term * u_hat + self._coef_1 * u_nonlin_hat\n        u_stage_1_nonlin_hat = self._nonlinear_func(u_stage_1_hat)\n        u_next_hat = u_stage_1_hat + self._coef_2 * (\n            u_stage_1_nonlin_hat - u_nonlin_hat\n            )\n        return u_next_hat\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK2.dt","title":"dt  <code>instance-attribute</code>","text":"<pre><code>dt = dt\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK2.LR","title":"LR  <code>instance-attribute</code>","text":"<pre><code>LR = (\n    circle_radius\n    * roots_of_unity(\n        num_circle_points, device=device, dtype=dtype\n    )\n    + unsqueeze(-1) * dt\n)\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK2.__init__","title":"__init__","text":"<pre><code>__init__(\n    dt: float,\n    linear_coef: Tensor,\n    nonlinear_func: Callable[[Tensor], Tensor],\n    num_circle_points: int = 16,\n    circle_radius: float = 1.0,\n)\n</code></pre> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>def __init__(\n    self,\n    dt: float,\n    linear_coef: torch.Tensor,\n    nonlinear_func:Callable[[torch.Tensor],torch.Tensor],\n    num_circle_points: int = 16,\n    circle_radius: float = 1.0,\n    ):\n    super().__init__(dt, linear_coef,nonlinear_func,num_circle_points,circle_radius)\n    self._coef_1 = dt * torch.mean((torch.exp(self.LR) - 1) / self.LR, axis=-1).real\n    self._coef_2 = dt * torch.mean((torch.exp(self.LR) - 1 - self.LR) / self.LR**2, axis=-1).real\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK2.step","title":"step","text":"<pre><code>step(u_hat)\n</code></pre> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>def step(\n    self,\n    u_hat,\n    ):\n    u_nonlin_hat = self._nonlinear_func(u_hat)\n    u_stage_1_hat = self._exp_term * u_hat + self._coef_1 * u_nonlin_hat\n    u_stage_1_nonlin_hat = self._nonlinear_func(u_stage_1_hat)\n    u_next_hat = u_stage_1_hat + self._coef_2 * (\n        u_stage_1_nonlin_hat - u_nonlin_hat\n        )\n    return u_next_hat\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK3","title":"torchfsm.integrator._etdrk.ETDRK3","text":"<p>               Bases: <code>_ETDRKBase</code></p> <p>Third-order ETDRK method.</p> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>class ETDRK3(_ETDRKBase):\n    \"\"\"\n    Third-order ETDRK method.\n    \"\"\"\n    def __init__(\n        self,\n        dt: float,\n        linear_coef: torch.Tensor,\n        nonlinear_func:Callable[[torch.Tensor],torch.Tensor],\n        num_circle_points: int = 16,\n        circle_radius: float = 1.0,\n    ):\n        super().__init__(dt, linear_coef,nonlinear_func,num_circle_points,circle_radius)\n        self._half_exp_term = torch.exp(0.5 * dt * linear_coef)\n        self._coef_1 = dt * torch.mean((torch.exp(self.LR / 2) - 1) / self.LR, axis=-1).real\n        self._coef_2 = dt * torch.mean((torch.exp(self.LR) - 1) / self.LR, axis=-1).real\n        self._coef_3 = (\n            dt\n            * torch.mean(\n                (-4 - self.LR + torch.exp(self.LR) * (4 - 3 * self.LR + self.LR**2)) / (self.LR**3), axis=-1\n            ).real\n        )\n        self._coef_4 = (\n            dt\n            * torch.mean(\n                (4.0 * (2.0 + self.LR + torch.exp(self.LR) * (-2 + self.LR))) / (self.LR**3), axis=-1\n            ).real\n        )\n        self._coef_5 = (\n            dt\n            * torch.mean(\n                (-4 - 3 * self.LR - self.LR**2 + torch.exp(self.LR) * (4 - self.LR)) / (self.LR**3), axis=-1\n            ).real\n        )\n\n    def step(\n        self,\n        u_hat,\n        ):\n        u_nonlin_hat = self._nonlinear_func(u_hat)\n        u_stage_1_hat = self._half_exp_term * u_hat + self._coef_1 * u_nonlin_hat\n        u_stage_1_nonlin_hat = self._nonlinear_func(u_stage_1_hat)\n        u_stage_2_hat = self._exp_term * u_hat + self._coef_2 * (\n            2 * u_stage_1_nonlin_hat - u_nonlin_hat\n            )\n        u_stage_2_nonlin_hat = self._nonlinear_func(u_stage_2_hat)\n        u_next_hat = (\n            self._exp_term * u_hat\n            + self._coef_3 * u_nonlin_hat\n            + self._coef_4 * u_stage_1_nonlin_hat\n            + self._coef_5 * u_stage_2_nonlin_hat\n            )\n        return u_next_hat\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK3.dt","title":"dt  <code>instance-attribute</code>","text":"<pre><code>dt = dt\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK3.LR","title":"LR  <code>instance-attribute</code>","text":"<pre><code>LR = (\n    circle_radius\n    * roots_of_unity(\n        num_circle_points, device=device, dtype=dtype\n    )\n    + unsqueeze(-1) * dt\n)\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK3.__init__","title":"__init__","text":"<pre><code>__init__(\n    dt: float,\n    linear_coef: Tensor,\n    nonlinear_func: Callable[[Tensor], Tensor],\n    num_circle_points: int = 16,\n    circle_radius: float = 1.0,\n)\n</code></pre> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>def __init__(\n    self,\n    dt: float,\n    linear_coef: torch.Tensor,\n    nonlinear_func:Callable[[torch.Tensor],torch.Tensor],\n    num_circle_points: int = 16,\n    circle_radius: float = 1.0,\n):\n    super().__init__(dt, linear_coef,nonlinear_func,num_circle_points,circle_radius)\n    self._half_exp_term = torch.exp(0.5 * dt * linear_coef)\n    self._coef_1 = dt * torch.mean((torch.exp(self.LR / 2) - 1) / self.LR, axis=-1).real\n    self._coef_2 = dt * torch.mean((torch.exp(self.LR) - 1) / self.LR, axis=-1).real\n    self._coef_3 = (\n        dt\n        * torch.mean(\n            (-4 - self.LR + torch.exp(self.LR) * (4 - 3 * self.LR + self.LR**2)) / (self.LR**3), axis=-1\n        ).real\n    )\n    self._coef_4 = (\n        dt\n        * torch.mean(\n            (4.0 * (2.0 + self.LR + torch.exp(self.LR) * (-2 + self.LR))) / (self.LR**3), axis=-1\n        ).real\n    )\n    self._coef_5 = (\n        dt\n        * torch.mean(\n            (-4 - 3 * self.LR - self.LR**2 + torch.exp(self.LR) * (4 - self.LR)) / (self.LR**3), axis=-1\n        ).real\n    )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK3.step","title":"step","text":"<pre><code>step(u_hat)\n</code></pre> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>def step(\n    self,\n    u_hat,\n    ):\n    u_nonlin_hat = self._nonlinear_func(u_hat)\n    u_stage_1_hat = self._half_exp_term * u_hat + self._coef_1 * u_nonlin_hat\n    u_stage_1_nonlin_hat = self._nonlinear_func(u_stage_1_hat)\n    u_stage_2_hat = self._exp_term * u_hat + self._coef_2 * (\n        2 * u_stage_1_nonlin_hat - u_nonlin_hat\n        )\n    u_stage_2_nonlin_hat = self._nonlinear_func(u_stage_2_hat)\n    u_next_hat = (\n        self._exp_term * u_hat\n        + self._coef_3 * u_nonlin_hat\n        + self._coef_4 * u_stage_1_nonlin_hat\n        + self._coef_5 * u_stage_2_nonlin_hat\n        )\n    return u_next_hat\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK4","title":"torchfsm.integrator._etdrk.ETDRK4","text":"<p>               Bases: <code>_ETDRKBase</code></p> <p>Fourth-order ETDRK method.</p> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>class ETDRK4(_ETDRKBase):\n    \"\"\"\n    Fourth-order ETDRK method.\n    \"\"\"\n\n    def __init__(\n        self,\n        dt: float,\n        linear_coef: torch.Tensor,\n        nonlinear_func:Callable[[torch.Tensor],torch.Tensor],\n        num_circle_points: int = 16,\n        circle_radius: float = 1.0,\n    ):\n        super().__init__(dt, linear_coef,nonlinear_func,num_circle_points,circle_radius)\n        self._half_exp_term = torch.exp(0.5 * dt * linear_coef)\n        self._coef_1 = dt * torch.mean((torch.exp(self.LR / 2) - 1) / self.LR, axis=-1).real\n        self._coef_2 = self._coef_1\n        self._coef_3 = self._coef_1\n        self._coef_4 = (\n            dt\n            * torch.mean(\n                (-4 - self.LR + torch.exp(self.LR) * (4 - 3 * self.LR + self.LR**2)) / (self.LR**3), axis=-1\n            ).real\n        )\n        self._coef_5 = (\n            dt * torch.mean((2 + self.LR + torch.exp(self.LR) * (-2 + self.LR)) / (self.LR**3), axis=-1).real\n        )\n        self._coef_6 = (\n            dt\n            * torch.mean(\n                (-4 - 3 * self.LR - self.LR**2 + torch.exp(self.LR) * (4 - self.LR)) / (self.LR**3), axis=-1\n            ).real\n        )\n\n    def step(\n        self,\n        u_hat,\n        ):\n        u_nonlin_hat = self._nonlinear_func(u_hat)\n        u_stage_1_hat = self._half_exp_term * u_hat + self._coef_1 * u_nonlin_hat\n        u_stage_1_nonlin_hat = self._nonlinear_func(u_stage_1_hat)\n        u_stage_2_hat = (\n            self._half_exp_term * u_hat + self._coef_2 * u_stage_1_nonlin_hat\n            )\n        u_stage_2_nonlin_hat = self._nonlinear_func(u_stage_2_hat)\n        u_stage_3_hat = self._half_exp_term * u_stage_1_hat + self._coef_3 * (\n            2 * u_stage_2_nonlin_hat - u_nonlin_hat\n            )\n        u_stage_3_nonlin_hat = self._nonlinear_func(u_stage_3_hat)\n        u_next_hat = (\n            self._exp_term * u_hat\n            + self._coef_4 * u_nonlin_hat\n            + self._coef_5 * 2 * (u_stage_1_nonlin_hat + u_stage_2_nonlin_hat)\n            + self._coef_6 * u_stage_3_nonlin_hat\n            )\n        return u_next_hat\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK4.dt","title":"dt  <code>instance-attribute</code>","text":"<pre><code>dt = dt\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK4.LR","title":"LR  <code>instance-attribute</code>","text":"<pre><code>LR = (\n    circle_radius\n    * roots_of_unity(\n        num_circle_points, device=device, dtype=dtype\n    )\n    + unsqueeze(-1) * dt\n)\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK4.__init__","title":"__init__","text":"<pre><code>__init__(\n    dt: float,\n    linear_coef: Tensor,\n    nonlinear_func: Callable[[Tensor], Tensor],\n    num_circle_points: int = 16,\n    circle_radius: float = 1.0,\n)\n</code></pre> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>def __init__(\n    self,\n    dt: float,\n    linear_coef: torch.Tensor,\n    nonlinear_func:Callable[[torch.Tensor],torch.Tensor],\n    num_circle_points: int = 16,\n    circle_radius: float = 1.0,\n):\n    super().__init__(dt, linear_coef,nonlinear_func,num_circle_points,circle_radius)\n    self._half_exp_term = torch.exp(0.5 * dt * linear_coef)\n    self._coef_1 = dt * torch.mean((torch.exp(self.LR / 2) - 1) / self.LR, axis=-1).real\n    self._coef_2 = self._coef_1\n    self._coef_3 = self._coef_1\n    self._coef_4 = (\n        dt\n        * torch.mean(\n            (-4 - self.LR + torch.exp(self.LR) * (4 - 3 * self.LR + self.LR**2)) / (self.LR**3), axis=-1\n        ).real\n    )\n    self._coef_5 = (\n        dt * torch.mean((2 + self.LR + torch.exp(self.LR) * (-2 + self.LR)) / (self.LR**3), axis=-1).real\n    )\n    self._coef_6 = (\n        dt\n        * torch.mean(\n            (-4 - 3 * self.LR - self.LR**2 + torch.exp(self.LR) * (4 - self.LR)) / (self.LR**3), axis=-1\n        ).real\n    )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._etdrk.ETDRK4.step","title":"step","text":"<pre><code>step(u_hat)\n</code></pre> Source code in <code>torchfsm/integrator/_etdrk.py</code> <pre><code>def step(\n    self,\n    u_hat,\n    ):\n    u_nonlin_hat = self._nonlinear_func(u_hat)\n    u_stage_1_hat = self._half_exp_term * u_hat + self._coef_1 * u_nonlin_hat\n    u_stage_1_nonlin_hat = self._nonlinear_func(u_stage_1_hat)\n    u_stage_2_hat = (\n        self._half_exp_term * u_hat + self._coef_2 * u_stage_1_nonlin_hat\n        )\n    u_stage_2_nonlin_hat = self._nonlinear_func(u_stage_2_hat)\n    u_stage_3_hat = self._half_exp_term * u_stage_1_hat + self._coef_3 * (\n        2 * u_stage_2_nonlin_hat - u_nonlin_hat\n        )\n    u_stage_3_nonlin_hat = self._nonlinear_func(u_stage_3_hat)\n    u_next_hat = (\n        self._exp_term * u_hat\n        + self._coef_4 * u_nonlin_hat\n        + self._coef_5 * 2 * (u_stage_1_nonlin_hat + u_stage_2_nonlin_hat)\n        + self._coef_6 * u_stage_3_nonlin_hat\n        )\n    return u_next_hat\n</code></pre>"},{"location":"apis/integrator/#rk","title":"RK","text":""},{"location":"apis/integrator/#torchfsm.integrator.RKIntegrator","title":"torchfsm.integrator.RKIntegrator","text":"<p>               Bases: <code>Enum</code></p> <p>Enum class for Runge-Kutta integrators. This class provides a set of predefined Runge-Kutta integrators for solving ordinary differential equations (ODEs). Each integrator is represented as a member of the enum, and can be used to create an instance of the corresponding integrator class. The integrators include:     - Euler: First-order Euler method.     - Midpoint: Second-order Midpoint method.     - Heun12: Second-order Heun method.     - Ralston12: Second-order Ralston method.     - BogackiShampine23: Third-order     - RK4: Fourth-order Runge-Kutta method.     - RK4_38Rule: Fourth-order Runge-Kutta method with \u215c rule.     - Dorpi45: Fifth-order Dormand-Prince method.     - Fehlberg45: Fifth-order Fehlberg method.     - CashKarp45: Fifth-order Cash-Karp method.</p> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>class RKIntegrator(Enum):\n    \"\"\"\n    Enum class for Runge-Kutta integrators.\n    This class provides a set of predefined Runge-Kutta integrators for solving ordinary differential equations (ODEs).\n    Each integrator is represented as a member of the enum, and can be used to create an instance of the corresponding integrator class.\n    The integrators include:\n        - Euler: First-order Euler method.\n        - Midpoint: Second-order Midpoint method.\n        - Heun12: Second-order Heun method.\n        - Ralston12: Second-order Ralston method.\n        - BogackiShampine23: Third-order\n        - RK4: Fourth-order Runge-Kutta method.\n        - RK4_38Rule: Fourth-order Runge-Kutta method with 3/8 rule.\n        - Dorpi45: Fifth-order Dormand-Prince method.\n        - Fehlberg45: Fifth-order Fehlberg method.\n        - CashKarp45: Fifth-order Cash-Karp method.\n    \"\"\"\n    Euler = Euler\n    Midpoint = Midpoint\n    Heun12 = Heun12\n    Ralston12 = Ralston12\n    BogackiShampine23 = BogackiShampine23\n    RK4 = RK4\n    RK4_38Rule = RK4_38Rule\n    Dorpi45 = Dorpi45\n    Fehlberg45 = Fehlberg45\n    CashKarp45 = CashKarp45\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.RKIntegrator.Euler","title":"Euler  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Euler = Euler\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.RKIntegrator.Midpoint","title":"Midpoint  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Midpoint = Midpoint\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.RKIntegrator.Heun12","title":"Heun12  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Heun12 = Heun12\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.RKIntegrator.Ralston12","title":"Ralston12  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Ralston12 = Ralston12\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.RKIntegrator.BogackiShampine23","title":"BogackiShampine23  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>BogackiShampine23 = BogackiShampine23\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.RKIntegrator.RK4","title":"RK4  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RK4 = RK4\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.RKIntegrator.RK4_38Rule","title":"RK4_38Rule  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RK4_38Rule = RK4_38Rule\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.RKIntegrator.Dorpi45","title":"Dorpi45  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Dorpi45 = Dorpi45\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.RKIntegrator.Fehlberg45","title":"Fehlberg45  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>Fehlberg45 = Fehlberg45\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator.RKIntegrator.CashKarp45","title":"CashKarp45  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>CashKarp45 = CashKarp45\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk._RKBase","title":"torchfsm.integrator._rk._RKBase","text":"<p>Base class for Runge-Kutta integrators.     This class implements the Runge-Kutta method for solving ordinary differential equations (ODEs).     The Runge-Kutta method is a numerical technique used to solve ODEs by approximating the solution at discrete time steps.     The class provides a flexible interface for defining different Runge-Kutta methods by specifying the coefficients and weights.     The class also supports adaptive step size control, allowing for dynamic adjustment of the time step based on the estimated error.</p> <p>Parameters:</p> Name Type Description Default <code>ca</code> <code>Sequence[float]</code> <p>Coefficients for the Runge-Kutta method.</p> required <code>b</code> <code>Sequence[float]</code> <p>Weights for the Runge-Kutta method.</p> required <code>b_star</code> <code>Optional[Sequence]</code> <p>Optional coefficients for error estimation.</p> <code>None</code> <code>adaptive</code> <code>bool</code> <p>If True, enables adaptive step size control.</p> <code>False</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for adaptive step size control.</p> <code>1e-06</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive step size control.</p> <code>1e-05</code> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>class _RKBase:\n    \"\"\"\n    Base class for Runge-Kutta integrators.\n        This class implements the Runge-Kutta method for solving ordinary differential equations (ODEs).\n        The Runge-Kutta method is a numerical technique used to solve ODEs by approximating the solution at discrete time steps.\n        The class provides a flexible interface for defining different Runge-Kutta methods by specifying the coefficients and weights.\n        The class also supports adaptive step size control, allowing for dynamic adjustment of the time step based on the estimated error.\n\n    Args:\n        ca (Sequence[float]): Coefficients for the Runge-Kutta method.\n        b (Sequence[float]): Weights for the Runge-Kutta method.\n        b_star (Optional[Sequence]): Optional coefficients for error estimation.\n        adaptive (bool): If True, enables adaptive step size control.\n        atol (float): Absolute tolerance for adaptive step size control.\n        rtol (float): Relative tolerance for adaptive step size control.\n    \"\"\"\n\n    def __init__(\n        self,\n        ca: Sequence[float],\n        b: Sequence[float],\n        b_star: Optional[Sequence] = None,\n        adaptive: bool = False,\n        atol: float = 1e-6,\n        rtol: float = 1e-5,\n    ):\n        self.ca = ca\n        self.b = b\n        self.b_star = b_star\n        self.adaptive = adaptive\n        self.atol = atol\n        self.rtol = rtol\n        if self.adaptive and self.b_star is None:\n            raise ValueError(\"adaptive step requires b_star\")\n        self.step= self._adaptive_step if self.adaptive else self._rk_step\n\n    def _rk_step(\n        self,\n        f: Callable[[Tensor], Tensor],\n        x_t: Tensor,\n        dt: float,\n        return_error: bool = False,\n    ):\n        ks = [f(x_t)]\n        for ca_i in self.ca:\n            ks.append(f(x_t + dt * sum([a_i * k for a_i, k in zip(ca_i[1:], ks)])))\n        x_new = x_t + dt * sum([b_i * k for b_i, k in zip(self.b, ks)])\n        if self.b_star is not None and return_error:\n            b_dif = [b_i - b_star_i for b_i, b_star_i in zip(self.b, self.b_star)]\n            error = dt * sum([b_dif_i * k for b_dif_i, k in zip(b_dif, ks)])\n            return x_new, error\n        return x_new\n\n    def _adaptive_step(\n            self,\n            f: Callable[[Tensor], Tensor],\n            x_t: Tensor,\n            dt: float,\n        ):\n        t = 0.0\n        t_1 = dt - t\n        while t_1 - t &gt; 0:\n            dt = min(dt, abs(t_1 - t))\n            if self.adaptive:\n                while True:\n                    y, error = self._rk_step(f, x_t, dt, return_error=True)\n                    tolerance = self.atol + self.rtol * torch.max(abs(x_t), abs(y))\n                    error = torch.max(error / tolerance).clip(min=1e-9).item()\n                    if error &lt; 1.0:\n                        x_t, t = y, t + dt\n                        break\n                    dt = dt * min(10.0, max(0.1, 0.9 / error ** (1 / 5)))\n        return x_t\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk._RKBase.ca","title":"ca  <code>instance-attribute</code>","text":"<pre><code>ca = ca\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk._RKBase.b","title":"b  <code>instance-attribute</code>","text":"<pre><code>b = b\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk._RKBase.b_star","title":"b_star  <code>instance-attribute</code>","text":"<pre><code>b_star = b_star\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk._RKBase.adaptive","title":"adaptive  <code>instance-attribute</code>","text":"<pre><code>adaptive = adaptive\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk._RKBase.atol","title":"atol  <code>instance-attribute</code>","text":"<pre><code>atol = atol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk._RKBase.rtol","title":"rtol  <code>instance-attribute</code>","text":"<pre><code>rtol = rtol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk._RKBase.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step = _adaptive_step if adaptive else _rk_step\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk._RKBase.__init__","title":"__init__","text":"<pre><code>__init__(\n    ca: Sequence[float],\n    b: Sequence[float],\n    b_star: Optional[Sequence] = None,\n    adaptive: bool = False,\n    atol: float = 1e-06,\n    rtol: float = 1e-05,\n)\n</code></pre> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>def __init__(\n    self,\n    ca: Sequence[float],\n    b: Sequence[float],\n    b_star: Optional[Sequence] = None,\n    adaptive: bool = False,\n    atol: float = 1e-6,\n    rtol: float = 1e-5,\n):\n    self.ca = ca\n    self.b = b\n    self.b_star = b_star\n    self.adaptive = adaptive\n    self.atol = atol\n    self.rtol = rtol\n    if self.adaptive and self.b_star is None:\n        raise ValueError(\"adaptive step requires b_star\")\n    self.step= self._adaptive_step if self.adaptive else self._rk_step\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Euler","title":"torchfsm.integrator._rk.Euler","text":"<p>               Bases: <code>_RKBase</code></p> <p>First-order Euler method.</p> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>class Euler(_RKBase):\n    \"\"\"\n    First-order Euler method.\n    \"\"\"\n    def __init__(self):\n        super().__init__([[1.0]], [1.0], adaptive=False)\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Euler.ca","title":"ca  <code>instance-attribute</code>","text":"<pre><code>ca = ca\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Euler.b","title":"b  <code>instance-attribute</code>","text":"<pre><code>b = b\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Euler.b_star","title":"b_star  <code>instance-attribute</code>","text":"<pre><code>b_star = b_star\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Euler.adaptive","title":"adaptive  <code>instance-attribute</code>","text":"<pre><code>adaptive = adaptive\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Euler.atol","title":"atol  <code>instance-attribute</code>","text":"<pre><code>atol = atol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Euler.rtol","title":"rtol  <code>instance-attribute</code>","text":"<pre><code>rtol = rtol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Euler.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step = _adaptive_step if adaptive else _rk_step\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Euler.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>def __init__(self):\n    super().__init__([[1.0]], [1.0], adaptive=False)\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Midpoint","title":"torchfsm.integrator._rk.Midpoint","text":"<p>               Bases: <code>_RKBase</code></p> <p>Midpoint method.</p> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>class Midpoint(_RKBase):\n    \"\"\"\n    Midpoint method.\n    \"\"\"\n    def __init__(self):\n        super().__init__([[1 / 2, 1 / 2]], [0, 1], adaptive=False)\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Midpoint.ca","title":"ca  <code>instance-attribute</code>","text":"<pre><code>ca = ca\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Midpoint.b","title":"b  <code>instance-attribute</code>","text":"<pre><code>b = b\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Midpoint.b_star","title":"b_star  <code>instance-attribute</code>","text":"<pre><code>b_star = b_star\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Midpoint.adaptive","title":"adaptive  <code>instance-attribute</code>","text":"<pre><code>adaptive = adaptive\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Midpoint.atol","title":"atol  <code>instance-attribute</code>","text":"<pre><code>atol = atol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Midpoint.rtol","title":"rtol  <code>instance-attribute</code>","text":"<pre><code>rtol = rtol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Midpoint.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step = _adaptive_step if adaptive else _rk_step\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Midpoint.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>def __init__(self):\n    super().__init__([[1 / 2, 1 / 2]], [0, 1], adaptive=False)\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Heun12","title":"torchfsm.integrator._rk.Heun12","text":"<p>               Bases: <code>_RKBase</code></p> <p>Heun's second-order method.</p> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>class Heun12(_RKBase):\n    \"\"\"\n    Heun's second-order method.\n    \"\"\"\n    def __init__(self, adaptive: bool = False, atol: float = 1e-6, rtol: float = 1e-5):\n        super().__init__(\n            [[1, 1]], [1 / 2, 1 / 2], [1, 0], adaptive=adaptive, atol=atol, rtol=rtol\n        )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Heun12.ca","title":"ca  <code>instance-attribute</code>","text":"<pre><code>ca = ca\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Heun12.b","title":"b  <code>instance-attribute</code>","text":"<pre><code>b = b\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Heun12.b_star","title":"b_star  <code>instance-attribute</code>","text":"<pre><code>b_star = b_star\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Heun12.adaptive","title":"adaptive  <code>instance-attribute</code>","text":"<pre><code>adaptive = adaptive\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Heun12.atol","title":"atol  <code>instance-attribute</code>","text":"<pre><code>atol = atol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Heun12.rtol","title":"rtol  <code>instance-attribute</code>","text":"<pre><code>rtol = rtol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Heun12.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step = _adaptive_step if adaptive else _rk_step\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Heun12.__init__","title":"__init__","text":"<pre><code>__init__(\n    adaptive: bool = False,\n    atol: float = 1e-06,\n    rtol: float = 1e-05,\n)\n</code></pre> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>def __init__(self, adaptive: bool = False, atol: float = 1e-6, rtol: float = 1e-5):\n    super().__init__(\n        [[1, 1]], [1 / 2, 1 / 2], [1, 0], adaptive=adaptive, atol=atol, rtol=rtol\n    )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Ralston12","title":"torchfsm.integrator._rk.Ralston12","text":"<p>               Bases: <code>_RKBase</code></p> <p>Ralston's second-order method.</p> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>class Ralston12(_RKBase):\n    \"\"\"\n    Ralston's second-order method.\n    \"\"\"\n    def __init__(self, adaptive: bool = False, atol: float = 1e-6, rtol: float = 1e-5):\n        super().__init__(\n            [[2 / 3, 2 / 3]],\n            [1 / 4, 3 / 4],\n            [2 / 3, 1 / 3],\n            adaptive=adaptive,\n            atol=atol,\n            rtol=rtol,\n        )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Ralston12.ca","title":"ca  <code>instance-attribute</code>","text":"<pre><code>ca = ca\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Ralston12.b","title":"b  <code>instance-attribute</code>","text":"<pre><code>b = b\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Ralston12.b_star","title":"b_star  <code>instance-attribute</code>","text":"<pre><code>b_star = b_star\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Ralston12.adaptive","title":"adaptive  <code>instance-attribute</code>","text":"<pre><code>adaptive = adaptive\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Ralston12.atol","title":"atol  <code>instance-attribute</code>","text":"<pre><code>atol = atol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Ralston12.rtol","title":"rtol  <code>instance-attribute</code>","text":"<pre><code>rtol = rtol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Ralston12.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step = _adaptive_step if adaptive else _rk_step\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Ralston12.__init__","title":"__init__","text":"<pre><code>__init__(\n    adaptive: bool = False,\n    atol: float = 1e-06,\n    rtol: float = 1e-05,\n)\n</code></pre> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>def __init__(self, adaptive: bool = False, atol: float = 1e-6, rtol: float = 1e-5):\n    super().__init__(\n        [[2 / 3, 2 / 3]],\n        [1 / 4, 3 / 4],\n        [2 / 3, 1 / 3],\n        adaptive=adaptive,\n        atol=atol,\n        rtol=rtol,\n    )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.BogackiShampine23","title":"torchfsm.integrator._rk.BogackiShampine23","text":"<p>               Bases: <code>_RKBase</code></p> <p>Third-order Bogack and Shampine method.</p> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>class BogackiShampine23(_RKBase):\n    \"\"\"\n    Third-order Bogack and Shampine method.\n    \"\"\"\n    def __init__(self, adaptive: bool = False, atol: float = 1e-6, rtol: float = 1e-5):\n        super().__init__(\n            ca=[\n                [1 / 2, 1 / 2],\n                [3 / 4, 0, 3 / 4],\n                [1, 2 / 9, 1 / 3, 4 / 9],\n            ],\n            b=[2 / 9, 1 / 3, 4 / 9, 0],\n            b_star=[7 / 24, 1 / 4, 1 / 3, 1 / 8],\n            adaptive=adaptive,\n            atol=atol,\n            rtol=rtol,\n        )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.BogackiShampine23.ca","title":"ca  <code>instance-attribute</code>","text":"<pre><code>ca = ca\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.BogackiShampine23.b","title":"b  <code>instance-attribute</code>","text":"<pre><code>b = b\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.BogackiShampine23.b_star","title":"b_star  <code>instance-attribute</code>","text":"<pre><code>b_star = b_star\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.BogackiShampine23.adaptive","title":"adaptive  <code>instance-attribute</code>","text":"<pre><code>adaptive = adaptive\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.BogackiShampine23.atol","title":"atol  <code>instance-attribute</code>","text":"<pre><code>atol = atol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.BogackiShampine23.rtol","title":"rtol  <code>instance-attribute</code>","text":"<pre><code>rtol = rtol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.BogackiShampine23.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step = _adaptive_step if adaptive else _rk_step\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.BogackiShampine23.__init__","title":"__init__","text":"<pre><code>__init__(\n    adaptive: bool = False,\n    atol: float = 1e-06,\n    rtol: float = 1e-05,\n)\n</code></pre> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>def __init__(self, adaptive: bool = False, atol: float = 1e-6, rtol: float = 1e-5):\n    super().__init__(\n        ca=[\n            [1 / 2, 1 / 2],\n            [3 / 4, 0, 3 / 4],\n            [1, 2 / 9, 1 / 3, 4 / 9],\n        ],\n        b=[2 / 9, 1 / 3, 4 / 9, 0],\n        b_star=[7 / 24, 1 / 4, 1 / 3, 1 / 8],\n        adaptive=adaptive,\n        atol=atol,\n        rtol=rtol,\n    )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4","title":"torchfsm.integrator._rk.RK4","text":"<p>               Bases: <code>_RKBase</code></p> <p>Fourth-order Runge-Kutta method.</p> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>class RK4(_RKBase):\n    \"\"\"\n    Fourth-order Runge-Kutta method.\n    \"\"\"\n    def __init__(self):\n        super().__init__(\n            ca=[\n                [1 / 2, 1 / 2],\n                [1 / 2, 0, 1 / 2],\n                [1, 0, 0, 1],\n            ],\n            b=[1 / 6, 1 / 3, 1 / 3, 1 / 6],\n            adaptive=False,\n        )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4.ca","title":"ca  <code>instance-attribute</code>","text":"<pre><code>ca = ca\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4.b","title":"b  <code>instance-attribute</code>","text":"<pre><code>b = b\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4.b_star","title":"b_star  <code>instance-attribute</code>","text":"<pre><code>b_star = b_star\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4.adaptive","title":"adaptive  <code>instance-attribute</code>","text":"<pre><code>adaptive = adaptive\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4.atol","title":"atol  <code>instance-attribute</code>","text":"<pre><code>atol = atol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4.rtol","title":"rtol  <code>instance-attribute</code>","text":"<pre><code>rtol = rtol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step = _adaptive_step if adaptive else _rk_step\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>def __init__(self):\n    super().__init__(\n        ca=[\n            [1 / 2, 1 / 2],\n            [1 / 2, 0, 1 / 2],\n            [1, 0, 0, 1],\n        ],\n        b=[1 / 6, 1 / 3, 1 / 3, 1 / 6],\n        adaptive=False,\n    )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4_38Rule","title":"torchfsm.integrator._rk.RK4_38Rule","text":"<p>               Bases: <code>_RKBase</code></p> <p>Fourth-order Runge-Kutta method with \u215c rule.</p> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>class RK4_38Rule(_RKBase):\n    \"\"\"\n    Fourth-order Runge-Kutta method with 3/8 rule.\n    \"\"\"\n    def __init__(self):\n        super().__init__(\n            ca=[\n                [1 / 3, 1 / 3],\n                [2 / 3, -1 / 3, 1],\n                [1, -1, 1, 1],\n            ],\n            b=[1 / 8, 3 / 8, 3 / 8, 1 / 8],\n            adaptive=False,\n        )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4_38Rule.ca","title":"ca  <code>instance-attribute</code>","text":"<pre><code>ca = ca\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4_38Rule.b","title":"b  <code>instance-attribute</code>","text":"<pre><code>b = b\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4_38Rule.b_star","title":"b_star  <code>instance-attribute</code>","text":"<pre><code>b_star = b_star\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4_38Rule.adaptive","title":"adaptive  <code>instance-attribute</code>","text":"<pre><code>adaptive = adaptive\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4_38Rule.atol","title":"atol  <code>instance-attribute</code>","text":"<pre><code>atol = atol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4_38Rule.rtol","title":"rtol  <code>instance-attribute</code>","text":"<pre><code>rtol = rtol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4_38Rule.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step = _adaptive_step if adaptive else _rk_step\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.RK4_38Rule.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>def __init__(self):\n    super().__init__(\n        ca=[\n            [1 / 3, 1 / 3],\n            [2 / 3, -1 / 3, 1],\n            [1, -1, 1, 1],\n        ],\n        b=[1 / 8, 3 / 8, 3 / 8, 1 / 8],\n        adaptive=False,\n    )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Dorpi45","title":"torchfsm.integrator._rk.Dorpi45","text":"<p>               Bases: <code>_RKBase</code></p> <p>Fifth-order Dormand-Prince method.</p> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>class Dorpi45(_RKBase):\n    \"\"\"\n    Fifth-order Dormand-Prince method.\n    \"\"\"\n\n    def __init__(self, adaptive: bool = False, atol: float = 1e-6, rtol: float = 1e-5):\n        super().__init__(\n            ca=[\n                [1 / 5, 1 / 5],\n                [3 / 10, 3 / 40, 9 / 40],\n                [4 / 5, 44 / 45, -56 / 15, 32 / 9],\n                [8 / 9, 19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729],\n                [1, 9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656],\n                [1, 35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84],\n            ],\n            b=[35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84],\n            b_star=[\n                5179 / 57600,\n                0,\n                7571 / 16695,\n                393 / 640,\n                -92097 / 339200,\n                187 / 2100,\n                1 / 40,\n            ],\n            adaptive=adaptive,\n            atol=atol,\n            rtol=rtol,\n        )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Dorpi45.ca","title":"ca  <code>instance-attribute</code>","text":"<pre><code>ca = ca\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Dorpi45.b","title":"b  <code>instance-attribute</code>","text":"<pre><code>b = b\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Dorpi45.b_star","title":"b_star  <code>instance-attribute</code>","text":"<pre><code>b_star = b_star\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Dorpi45.adaptive","title":"adaptive  <code>instance-attribute</code>","text":"<pre><code>adaptive = adaptive\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Dorpi45.atol","title":"atol  <code>instance-attribute</code>","text":"<pre><code>atol = atol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Dorpi45.rtol","title":"rtol  <code>instance-attribute</code>","text":"<pre><code>rtol = rtol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Dorpi45.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step = _adaptive_step if adaptive else _rk_step\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Dorpi45.__init__","title":"__init__","text":"<pre><code>__init__(\n    adaptive: bool = False,\n    atol: float = 1e-06,\n    rtol: float = 1e-05,\n)\n</code></pre> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>def __init__(self, adaptive: bool = False, atol: float = 1e-6, rtol: float = 1e-5):\n    super().__init__(\n        ca=[\n            [1 / 5, 1 / 5],\n            [3 / 10, 3 / 40, 9 / 40],\n            [4 / 5, 44 / 45, -56 / 15, 32 / 9],\n            [8 / 9, 19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729],\n            [1, 9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656],\n            [1, 35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84],\n        ],\n        b=[35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84],\n        b_star=[\n            5179 / 57600,\n            0,\n            7571 / 16695,\n            393 / 640,\n            -92097 / 339200,\n            187 / 2100,\n            1 / 40,\n        ],\n        adaptive=adaptive,\n        atol=atol,\n        rtol=rtol,\n    )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Fehlberg45","title":"torchfsm.integrator._rk.Fehlberg45","text":"<p>               Bases: <code>_RKBase</code></p> <p>Fehlberg 4(5) method for adaptive step size control. This method is a Runge-Kutta method that provides a fourth-order and fifth-order approximation of the solution to an ODE.</p> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>class Fehlberg45(_RKBase):\n    \"\"\"\n    Fehlberg 4(5) method for adaptive step size control.\n    This method is a Runge-Kutta method that provides a fourth-order and fifth-order approximation of the solution to an ODE.\n    \"\"\"\n\n    def __init__(self, adaptive: bool = False, atol: float = 1e-6, rtol: float = 1e-5):\n        super().__init__(\n            ca=[\n                [1 / 4, 1 / 4],\n                [3 / 8, 3 / 32, 9 / 32],\n                [12 / 13, 1932 / 2197, -7200 / 2197, 7296 / 2197],\n                [1, 439 / 216, -8, 3680 / 513, -845 / 4104],\n                [1 / 2, -8 / 27, 2, -3544 / 2565, 1859 / 4104, -11 / 40],\n            ],\n            b=[16 / 135, 0, 6656 / 12825, 28561 / 56430, -9 / 50, 2 / 55],\n            b_star=[25 / 216, 0, 1408 / 2565, 2197 / 4104, -1 / 5, 0],\n            adaptive=adaptive,\n            atol=atol,\n            rtol=rtol,\n        )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Fehlberg45.ca","title":"ca  <code>instance-attribute</code>","text":"<pre><code>ca = ca\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Fehlberg45.b","title":"b  <code>instance-attribute</code>","text":"<pre><code>b = b\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Fehlberg45.b_star","title":"b_star  <code>instance-attribute</code>","text":"<pre><code>b_star = b_star\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Fehlberg45.adaptive","title":"adaptive  <code>instance-attribute</code>","text":"<pre><code>adaptive = adaptive\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Fehlberg45.atol","title":"atol  <code>instance-attribute</code>","text":"<pre><code>atol = atol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Fehlberg45.rtol","title":"rtol  <code>instance-attribute</code>","text":"<pre><code>rtol = rtol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Fehlberg45.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step = _adaptive_step if adaptive else _rk_step\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.Fehlberg45.__init__","title":"__init__","text":"<pre><code>__init__(\n    adaptive: bool = False,\n    atol: float = 1e-06,\n    rtol: float = 1e-05,\n)\n</code></pre> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>def __init__(self, adaptive: bool = False, atol: float = 1e-6, rtol: float = 1e-5):\n    super().__init__(\n        ca=[\n            [1 / 4, 1 / 4],\n            [3 / 8, 3 / 32, 9 / 32],\n            [12 / 13, 1932 / 2197, -7200 / 2197, 7296 / 2197],\n            [1, 439 / 216, -8, 3680 / 513, -845 / 4104],\n            [1 / 2, -8 / 27, 2, -3544 / 2565, 1859 / 4104, -11 / 40],\n        ],\n        b=[16 / 135, 0, 6656 / 12825, 28561 / 56430, -9 / 50, 2 / 55],\n        b_star=[25 / 216, 0, 1408 / 2565, 2197 / 4104, -1 / 5, 0],\n        adaptive=adaptive,\n        atol=atol,\n        rtol=rtol,\n    )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.CashKarp45","title":"torchfsm.integrator._rk.CashKarp45","text":"<p>               Bases: <code>_RKBase</code></p> <p>Cash-Karp 4(5) method for adaptive step size control. This method is a Runge-Kutta method that provides a fourth-order and fifth-order approximation of the solution to an ODE.</p> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>class CashKarp45(_RKBase):\n    \"\"\"\n    Cash-Karp 4(5) method for adaptive step size control.\n    This method is a Runge-Kutta method that provides a fourth-order and fifth-order approximation of the solution to an ODE.\n    \"\"\"\n\n    def __init__(self, adaptive: bool = False, atol: float = 1e-6, rtol: float = 1e-5):\n        super().__init__(\n            ca=[\n                [1 / 5, 1 / 5],\n                [3 / 10, 3 / 40, 9 / 40],\n                [3 / 5, 3 / 10, -9 / 10, 6 / 5],\n                [1, -11 / 54, 5 / 2, -70 / 27, 35 / 27],\n                [\n                    7 / 8,\n                    1631 / 55296,\n                    175 / 512,\n                    575 / 13824,\n                    44275 / 110592,\n                    253 / 4096,\n                ],\n            ],\n            b=[37 / 378, 0, 250 / 621, 125 / 594, 0, 512 / 1771],\n            b_star=[2825 / 27648, 0, 18575 / 48384, 13525 / 55296, 277 / 14336, 1 / 4],\n            adaptive=adaptive,\n            atol=atol,\n            rtol=rtol,\n        )\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.CashKarp45.ca","title":"ca  <code>instance-attribute</code>","text":"<pre><code>ca = ca\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.CashKarp45.b","title":"b  <code>instance-attribute</code>","text":"<pre><code>b = b\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.CashKarp45.b_star","title":"b_star  <code>instance-attribute</code>","text":"<pre><code>b_star = b_star\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.CashKarp45.adaptive","title":"adaptive  <code>instance-attribute</code>","text":"<pre><code>adaptive = adaptive\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.CashKarp45.atol","title":"atol  <code>instance-attribute</code>","text":"<pre><code>atol = atol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.CashKarp45.rtol","title":"rtol  <code>instance-attribute</code>","text":"<pre><code>rtol = rtol\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.CashKarp45.step","title":"step  <code>instance-attribute</code>","text":"<pre><code>step = _adaptive_step if adaptive else _rk_step\n</code></pre>"},{"location":"apis/integrator/#torchfsm.integrator._rk.CashKarp45.__init__","title":"__init__","text":"<pre><code>__init__(\n    adaptive: bool = False,\n    atol: float = 1e-06,\n    rtol: float = 1e-05,\n)\n</code></pre> Source code in <code>torchfsm/integrator/_rk.py</code> <pre><code>def __init__(self, adaptive: bool = False, atol: float = 1e-6, rtol: float = 1e-5):\n    super().__init__(\n        ca=[\n            [1 / 5, 1 / 5],\n            [3 / 10, 3 / 40, 9 / 40],\n            [3 / 5, 3 / 10, -9 / 10, 6 / 5],\n            [1, -11 / 54, 5 / 2, -70 / 27, 35 / 27],\n            [\n                7 / 8,\n                1631 / 55296,\n                175 / 512,\n                575 / 13824,\n                44275 / 110592,\n                253 / 4096,\n            ],\n        ],\n        b=[37 / 378, 0, 250 / 621, 125 / 594, 0, 512 / 1771],\n        b_star=[2825 / 27648, 0, 18575 / 48384, 13525 / 55296, 277 / 14336, 1 / 4],\n        adaptive=adaptive,\n        atol=atol,\n        rtol=rtol,\n    )\n</code></pre>"},{"location":"apis/mesh/","title":"Mesh","text":""},{"location":"apis/mesh/#torchfsmmeshmeshgrid","title":"torchfsm.mesh.MeshGrid","text":""},{"location":"apis/mesh/#torchfsmmeshfftfrequency","title":"torchfsm.mesh.FFTFrequency","text":""},{"location":"apis/mesh/#torchfsmmeshbroadcastedfftfrequency","title":"torchfsm.mesh.BroadcastedFFTFrequency","text":""},{"location":"apis/mesh/#torchfsmmeshfouriermesh","title":"torchfsm.mesh.FourierMesh","text":"<p>torchfsm.mesh.mesh_shape</p>"},{"location":"apis/operator/","title":"1. operator","text":""},{"location":"apis/operator/#operators","title":"Operators","text":"<p>Operators are the core of the torchfsm library. Each operator represents a specific physical process, such as convection, diffusion, or pressure calculation.</p>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic","title":"torchfsm.operator.Biharmonic","text":"<p>               Bases: <code>LinearOperator</code></p> <p><code>Biharmonic</code> calculates the Biharmonic of a vector field.      It is defined as \\(\\nabla^4\\mathbf{u}=\\left[\\begin{matrix}(\\sum_{i=0}^I\\frac{\\partial^2}{\\partial i^2 })(\\sum_{j=0}^I\\frac{\\partial^2}{\\partial j^2 })u_x \\\\ (\\sum_{i=0}^I\\frac{\\partial^2}{\\partial i^2 })(\\sum_{j=0}^I\\frac{\\partial^2}{\\partial j^2 })u_y \\\\ \\cdots \\\\ (\\sum_{i=0}^I\\frac{\\partial^2}{\\partial i^2 })(\\sum_{j=0}^I\\frac{\\partial^2}{\\partial j^2 })u_i \\\\ \\end{matrix} \\right]\\)     Note that this class is an operator wrapper. The real implementation of the source term is in the <code>_BiharmonicCore</code> class.</p> Source code in <code>torchfsm/operator/generic/_biharmonic.py</code> <pre><code>class Biharmonic(LinearOperator):\n    r\"\"\"\n    `Biharmonic` calculates the Biharmonic of a vector field. \n        It is defined as $\\nabla^4\\mathbf{u}=\\left[\\begin{matrix}(\\sum_{i=0}^I\\frac{\\partial^2}{\\partial i^2 })(\\sum_{j=0}^I\\frac{\\partial^2}{\\partial j^2 })u_x \\\\ (\\sum_{i=0}^I\\frac{\\partial^2}{\\partial i^2 })(\\sum_{j=0}^I\\frac{\\partial^2}{\\partial j^2 })u_y \\\\ \\cdots \\\\ (\\sum_{i=0}^I\\frac{\\partial^2}{\\partial i^2 })(\\sum_{j=0}^I\\frac{\\partial^2}{\\partial j^2 })u_i \\\\ \\end{matrix} \\right]$\n        Note that this class is an operator wrapper. The real implementation of the source term is in the `_BiharmonicCore` class.    \n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(_BiharmonicCore())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.solve","title":"solve","text":"<pre><code>solve(\n    b: Optional[Tensor] = None,\n    b_fft: Optional[Tensor] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]\n]\n</code></pre> <p>Solve the linear operator equation \\(Ax = b\\), where \\(A\\) is the linear operator and \\(b\\) is the right-hand side.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in spatial domain. If None, b_fft should be provided.</p> <code>None</code> <code>b_fft</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in Fourier domain. If None, b should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. If None, the mesh registered in the operator will be used.</p> <code>None</code> <code>n_channel</code> <code>Optional[int]</code> <p>Number of channels of \\(x\\). If None, the number of channels registered in the operator will be used.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def solve(\n    self,\n    b: Optional[torch.Tensor] = None,\n    b_fft: Optional[torch.Tensor] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]]:\n\n    r\"\"\"\n    Solve the linear operator equation $Ax = b$, where $A$ is the linear operator and $b$ is the right-hand side.\n\n    Args:\n        b (Optional[torch.Tensor]): Right-hand side tensor in spatial domain. If None, b_fft should be provided.\n        b_fft (Optional[torch.Tensor]): Right-hand side tensor in Fourier domain. If None, b should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. If None, the mesh registered in the operator will be used.\n        n_channel (Optional[int]): Number of channels of $x$. If None, the number of channels registered in the operator will be used.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.\n    \"\"\"\n    if not (mesh is not None and n_channel is not None):\n        assert (\n            self._state_dict[\"f_mesh\"] is not None\n        ), \"Mesh and n_channel should be given when calling solve\"\n    if not (mesh is None and n_channel is None):\n        mesh = self._state_dict[\"f_mesh\"] if mesh is None else mesh\n        n_channel = (\n            self._state_dict[\"n_channel\"] if n_channel is None else n_channel\n        )\n        self.register_mesh(mesh, n_channel)\n    if self._state_dict[\"invert_linear_coef\"] is None:\n        self._state_dict[\"invert_linear_coef\"] = torch.where(\n            self._state_dict[\"linear_coef\"] == 0,\n            1.0,\n            1 / self._state_dict[\"linear_coef\"],\n        )\n    if b_fft is None:\n        b_fft = self._state_dict[\"f_mesh\"].fft(b)\n    value_fft = b_fft * self._state_dict[\"invert_linear_coef\"]\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, LinearOperator):\n        return LinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return LinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return LinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Biharmonic.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/generic/_biharmonic.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(_BiharmonicCore())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection","title":"torchfsm.operator.ConservativeConvection","text":"<p>               Bases: <code>NonlinearOperator</code></p> <p><code>ConservativeConvection</code> calculates the convection of a vector field on itself.      It is defined as \\(\\nabla \\cdot \\mathbf{u}\\mathbf{u}=\\left[\\begin{matrix}\\sum_{i=0}^I \\frac{\\partial u_i u_x }{\\partial i} \\\\\\sum_{i=0}^I \\frac{\\partial u_i u_y }{\\partial i} \\\\\\cdots\\\\\\sum_{i=0}^I \\frac{\\partial u_i u_I }{\\partial i} \\\\\\end{matrix}\\right]\\).     This operator only works for vector fields with the same dimension as the mesh.     Note that this class is an operator wrapper. The real implementation of the source term is in the <code>_ConservativeConvectionCore</code> class.</p> Source code in <code>torchfsm/operator/generic/_conservative_convection.py</code> <pre><code>class ConservativeConvection(NonlinearOperator):\n    r\"\"\"\n    `ConservativeConvection` calculates the convection of a vector field on itself. \n        It is defined as $\\nabla \\cdot \\mathbf{u}\\mathbf{u}=\\left[\\begin{matrix}\\sum_{i=0}^I \\frac{\\partial u_i u_x }{\\partial i} \\\\\\sum_{i=0}^I \\frac{\\partial u_i u_y }{\\partial i} \\\\\\cdots\\\\\\sum_{i=0}^I \\frac{\\partial u_i u_I }{\\partial i} \\\\\\end{matrix}\\right]$.\n        This operator only works for vector fields with the same dimension as the mesh.\n        Note that this class is an operator wrapper. The real implementation of the source term is in the `_ConservativeConvectionCore` class.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(_ConservativeConvectionGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, NonlinearOperator):\n        return NonlinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return NonlinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return NonlinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ConservativeConvection.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/generic/_conservative_convection.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(_ConservativeConvectionGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection","title":"torchfsm.operator.Convection","text":"<p>               Bases: <code>NonlinearOperator</code></p> <p><code>Convection</code> calculates the convection of a vector field on itself if the vector field is divergence free, i.e., \\(\\nabla \\cdot \\mathbf{u} =0\\).     It is defined as \\(\\mathbf{u} \\cdot \\nabla  \\mathbf{u}=\\left[\\begin{matrix}\\sum_{i=0}^I u_i\\frac{\\partial u_x }{\\partial i} \\\\\\sum_{i=0}^I u_i\\frac{\\partial u_y }{\\partial i} \\\\\\cdots\\\\\\sum_{i=0}^I u_i\\frac{\\partial u_I }{\\partial i} \\\\\\end{matrix}\\right]\\)     This operator only works for vector fields with the same dimension as the mesh.     Note that this class is an operator wrapper. The real implementation of the source term is in the <code>_ConvectionCore</code> class.</p> Source code in <code>torchfsm/operator/generic/_convection.py</code> <pre><code>class Convection(NonlinearOperator):\n    r\"\"\"\n    `Convection` calculates the convection of a vector field on itself if the vector field is divergence free, i.e., $\\nabla \\cdot \\mathbf{u} =0$.\n        It is defined as $\\mathbf{u} \\cdot \\nabla  \\mathbf{u}=\\left[\\begin{matrix}\\sum_{i=0}^I u_i\\frac{\\partial u_x }{\\partial i} \\\\\\sum_{i=0}^I u_i\\frac{\\partial u_y }{\\partial i} \\\\\\cdots\\\\\\sum_{i=0}^I u_i\\frac{\\partial u_I }{\\partial i} \\\\\\end{matrix}\\right]$\n        This operator only works for vector fields with the same dimension as the mesh.\n        Note that this class is an operator wrapper. The real implementation of the source term is in the `_ConvectionCore` class.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(_ConvectionGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, NonlinearOperator):\n        return NonlinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return NonlinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return NonlinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Convection.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/generic/_convection.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(_ConvectionGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl","title":"torchfsm.operator.Curl","text":"<p>               Bases: <code>NonlinearOperator</code></p> <p>Curl operator for 2D and 3D vector fields.      It is defined as: \\(\\nabla \\times \\mathbf{u} = \\frac{\\partial u_y}{\\partial x}-\\frac{\\partial u_x}{\\partial y}\\)     for 2D vector field \\(\\mathbf{u} = (u_x, u_y)\\) and     \\(\\nabla \\times \\mathbf{u} = \\left[\\begin{matrix} \\frac{\\partial u_z}{\\partial y}-\\frac{\\partial u_y}{\\partial z} \\\\ \\frac{\\partial u_x}{\\partial z}-\\frac{\\partial u_z}{\\partial x} \\\\ \\frac{\\partial u_y}{\\partial x}-\\frac{\\partial u_x}{\\partial y} \\end{matrix} \\right]\\)     for 3D vector field \\(\\mathbf{u} = (u_x, u_y, u_z)\\).     This operator only works for vector fields with the same dimension as the mesh.     Note that this class is an operator wrapper. The real implementation of the source term is in the <code>_Curl2DCore</code> and <code>_Curl2DCore</code> class.</p> Source code in <code>torchfsm/operator/generic/_curl.py</code> <pre><code>class Curl(NonlinearOperator):\n\n    r\"\"\"\n    Curl operator for 2D and 3D vector fields. \n        It is defined as: $\\nabla \\times \\mathbf{u} = \\frac{\\partial u_y}{\\partial x}-\\frac{\\partial u_x}{\\partial y}$\n        for 2D vector field $\\mathbf{u} = (u_x, u_y)$ and\n        $\\nabla \\times \\mathbf{u} = \\left[\\begin{matrix} \\frac{\\partial u_z}{\\partial y}-\\frac{\\partial u_y}{\\partial z} \\\\ \\frac{\\partial u_x}{\\partial z}-\\frac{\\partial u_z}{\\partial x} \\\\ \\frac{\\partial u_y}{\\partial x}-\\frac{\\partial u_x}{\\partial y} \\end{matrix} \\right]$\n        for 3D vector field $\\mathbf{u} = (u_x, u_y, u_z)$.\n        This operator only works for vector fields with the same dimension as the mesh.\n        Note that this class is an operator wrapper. The real implementation of the source term is in the `_Curl2DCore` and `_Curl2DCore` class.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(_CurlGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, NonlinearOperator):\n        return NonlinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return NonlinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return NonlinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Curl.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/generic/_curl.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(_CurlGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div","title":"torchfsm.operator.Div","text":"<p>               Bases: <code>NonlinearOperator</code></p> <p><code>Div</code> calculates the divergence of a vector field.     It is defined as\\(\\nabla \\cdot \\mathbf{u} = \\sum_i \\frac{\\partial u_i}{\\partial i}\\).     This operator only works for vector fields with the same dimension as the mesh.     Note that this class is an operator wrapper. The actual implementation of the operator is in the <code>_DivCore</code> class.</p> Source code in <code>torchfsm/operator/generic/_div.py</code> <pre><code>class Div(NonlinearOperator):\n    r\"\"\"\n    `Div` calculates the divergence of a vector field.\n        It is defined as$\\nabla \\cdot \\mathbf{u} = \\sum_i \\frac{\\partial u_i}{\\partial i}$.\n        This operator only works for vector fields with the same dimension as the mesh.\n        Note that this class is an operator wrapper. The actual implementation of the operator is in the `_DivCore` class.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(_DivGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, NonlinearOperator):\n        return NonlinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return NonlinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return NonlinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Div.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/generic/_div.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(_DivGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad","title":"torchfsm.operator.Grad","text":"<p>               Bases: <code>LinearOperator</code></p> <p><code>Grad</code> calculates the spatial gradient of a scalar field.     It is defined as \\(\\nabla p = \\left[\\begin{matrix}\\frac{\\partial p}{\\partial x} \\\\\\frac{\\partial p}{\\partial y} \\\\\\cdots \\\\\\frac{\\partial p}{\\partial i} \\\\\\end{matrix}\\right]\\)     Note that this class is an operator wrapper. The actual implementation of the operator is in the <code>_GradCore</code> class.</p> Source code in <code>torchfsm/operator/generic/_grad.py</code> <pre><code>class Grad(LinearOperator):\n    r\"\"\"\n    `Grad` calculates the spatial gradient of a scalar field.\n        It is defined as $\\nabla p = \\left[\\begin{matrix}\\frac{\\partial p}{\\partial x} \\\\\\frac{\\partial p}{\\partial y} \\\\\\cdots \\\\\\frac{\\partial p}{\\partial i} \\\\\\end{matrix}\\right]$\n        Note that this class is an operator wrapper. The actual implementation of the operator is in the `_GradCore` class.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(_GradGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.solve","title":"solve","text":"<pre><code>solve(\n    b: Optional[Tensor] = None,\n    b_fft: Optional[Tensor] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]\n]\n</code></pre> <p>Solve the linear operator equation \\(Ax = b\\), where \\(A\\) is the linear operator and \\(b\\) is the right-hand side.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in spatial domain. If None, b_fft should be provided.</p> <code>None</code> <code>b_fft</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in Fourier domain. If None, b should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. If None, the mesh registered in the operator will be used.</p> <code>None</code> <code>n_channel</code> <code>Optional[int]</code> <p>Number of channels of \\(x\\). If None, the number of channels registered in the operator will be used.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def solve(\n    self,\n    b: Optional[torch.Tensor] = None,\n    b_fft: Optional[torch.Tensor] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]]:\n\n    r\"\"\"\n    Solve the linear operator equation $Ax = b$, where $A$ is the linear operator and $b$ is the right-hand side.\n\n    Args:\n        b (Optional[torch.Tensor]): Right-hand side tensor in spatial domain. If None, b_fft should be provided.\n        b_fft (Optional[torch.Tensor]): Right-hand side tensor in Fourier domain. If None, b should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. If None, the mesh registered in the operator will be used.\n        n_channel (Optional[int]): Number of channels of $x$. If None, the number of channels registered in the operator will be used.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.\n    \"\"\"\n    if not (mesh is not None and n_channel is not None):\n        assert (\n            self._state_dict[\"f_mesh\"] is not None\n        ), \"Mesh and n_channel should be given when calling solve\"\n    if not (mesh is None and n_channel is None):\n        mesh = self._state_dict[\"f_mesh\"] if mesh is None else mesh\n        n_channel = (\n            self._state_dict[\"n_channel\"] if n_channel is None else n_channel\n        )\n        self.register_mesh(mesh, n_channel)\n    if self._state_dict[\"invert_linear_coef\"] is None:\n        self._state_dict[\"invert_linear_coef\"] = torch.where(\n            self._state_dict[\"linear_coef\"] == 0,\n            1.0,\n            1 / self._state_dict[\"linear_coef\"],\n        )\n    if b_fft is None:\n        b_fft = self._state_dict[\"f_mesh\"].fft(b)\n    value_fft = b_fft * self._state_dict[\"invert_linear_coef\"]\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, LinearOperator):\n        return LinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return LinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return LinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Grad.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/generic/_grad.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(_GradGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource","title":"torchfsm.operator.ExplicitSource","text":"<p>               Bases: <code>NonlinearOperator</code></p> <p>Explicit source term for the operator. This class is used to represent an explicit source term in the operator.     Note that this class is an operator wrapper. The real implementation of the source term is in the _ExplicitSourceCore class. </p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Tensor</code> <p>Source term in spatial domain. This is a tensor that represents the source term in the spatial domain.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>class ExplicitSource(NonlinearOperator):\n\n    r\"\"\"\n    Explicit source term for the operator. This class is used to represent an explicit source term in the operator.\n        Note that this class is an operator wrapper. The real implementation of the source term is in the _ExplicitSourceCore class. \n\n    Args:\n        source (torch.Tensor): Source term in spatial domain. This is a tensor that represents the source term in the spatial domain.\n    \"\"\"\n\n    def __init__(self, source: torch.Tensor) -&gt; None:\n        super().__init__(_ExplicitSourceCore(source))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, NonlinearOperator):\n        return NonlinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return NonlinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return NonlinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ExplicitSource.__init__","title":"__init__","text":"<pre><code>__init__(source: Tensor) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __init__(self, source: torch.Tensor) -&gt; None:\n    super().__init__(_ExplicitSourceCore(source))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource","title":"torchfsm.operator.ImplicitSource","text":"<p>               Bases: <code>Operator</code></p> <p><code>ImplicitSource</code> allows to define a source term in the implicit form.     Note that this class is an operator wrapper. The actual implementation of the operator is in the <code>_ImplicitFuncSourceCore</code> class and <code>_ImplicitUnitSourceCore</code>.</p> <p>Parameters:</p> Name Type Description Default <code>source_func</code> <code>Callable[[Tensor], Tensor]</code> <p>The f(x) function to be used as the source term. This function is used to define the source term in the implicit form. If None, the source term will be set to the unknown variable itself, i.e., f(x) = x.</p> <code>None</code> <code>non_linear</code> <code>bool</code> <p>If True, the source term is treated as a nonlinear function.  If False, it is treated as a linear function. Default is True. This actually controls whether the operator wil use the dealiased version of unknown variable for the source term. If the source term is a nonlinear function, the dealiased version of the unknown variable will be used.</p> <code>True</code> Source code in <code>torchfsm/operator/generic/_source.py</code> <pre><code>class ImplicitSource(Operator):\n\n    r\"\"\"\n    `ImplicitSource` allows to define a source term in the implicit form.\n        Note that this class is an operator wrapper. The actual implementation of the operator is in the `_ImplicitFuncSourceCore` class and `_ImplicitUnitSourceCore`.\n\n    Args:\n        source_func (Callable[[torch.Tensor], torch.Tensor], optional): \n            The f(x) function to be used as the source term.\n            This function is used to define the source term in the implicit form.\n            If None, the source term will be set to the unknown variable itself, i.e., f(x) = x.\n\n        non_linear (bool, optional): \n            If True, the source term is treated as a nonlinear function. \n            If False, it is treated as a linear function. Default is True.\n            This actually controls whether the operator wil use the dealiased version of unknown variable for the source term.\n            If the source term is a nonlinear function, the dealiased version of the unknown variable will be used.\n    \"\"\"\n\n    def __init__(\n        self,\n        source_func: Optional[Callable[[torch.Tensor], torch.Tensor]] = None,\n        non_linear: bool = True,\n    ) -&gt; None:\n        if source_func is None:\n            generator = lambda f_mesh, n_channel: _ImplicitUnitSourceCore()\n        else:\n            generator = lambda f_mesh, n_channel: _ImplicitFuncSourceCore(\n                source_func, non_linear\n            )\n        super().__init__(generator)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear: bool\n</code></pre> <p>Check if the operator is linear.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the operator is linear, False otherwise.</p>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return Operator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return Operator(self.operator_generators, [-1 * coef for coef in self.coefs])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.ImplicitSource.__init__","title":"__init__","text":"<pre><code>__init__(\n    source_func: Optional[\n        Callable[[Tensor], Tensor]\n    ] = None,\n    non_linear: bool = True,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/generic/_source.py</code> <pre><code>def __init__(\n    self,\n    source_func: Optional[Callable[[torch.Tensor], torch.Tensor]] = None,\n    non_linear: bool = True,\n) -&gt; None:\n    if source_func is None:\n        generator = lambda f_mesh, n_channel: _ImplicitUnitSourceCore()\n    else:\n        generator = lambda f_mesh, n_channel: _ImplicitFuncSourceCore(\n            source_func, non_linear\n        )\n    super().__init__(generator)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian","title":"torchfsm.operator.Laplacian","text":"<p>               Bases: <code>LinearOperator</code></p> <p><code>Laplacian</code> calculates the Laplacian of a vector field.</p> <p>It is defined as \\(\\nabla \\cdot (\\nabla\\mathbf{u}) = \\left[\\begin{matrix}\\sum_i \\frac{\\partial^2 u_x}{\\partial i^2 } \\\\\\sum_i \\frac{\\partial^2 u_y}{\\partial i^2 } \\\\\\cdots \\\\\\sum_i \\frac{\\partial^2 u_i}{\\partial i^2 } \\\\\\end{matrix}\\right]\\) Note that this class is an operator wrapper. The actual implementation of the operator is in the <code>_LaplacianCore</code> class.</p> Source code in <code>torchfsm/operator/generic/_laplacian.py</code> <pre><code>class Laplacian(LinearOperator):\n    r\"\"\"\n    `Laplacian` calculates the Laplacian of a vector field.\n\n    It is defined as $\\nabla \\cdot (\\nabla\\mathbf{u}) = \\left[\\begin{matrix}\\sum_i \\frac{\\partial^2 u_x}{\\partial i^2 } \\\\\\sum_i \\frac{\\partial^2 u_y}{\\partial i^2 } \\\\\\cdots \\\\\\sum_i \\frac{\\partial^2 u_i}{\\partial i^2 } \\\\\\end{matrix}\\right]$\n    Note that this class is an operator wrapper. The actual implementation of the operator is in the `_LaplacianCore` class.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__( _LaplacianCore())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.solve","title":"solve","text":"<pre><code>solve(\n    b: Optional[Tensor] = None,\n    b_fft: Optional[Tensor] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]\n]\n</code></pre> <p>Solve the linear operator equation \\(Ax = b\\), where \\(A\\) is the linear operator and \\(b\\) is the right-hand side.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in spatial domain. If None, b_fft should be provided.</p> <code>None</code> <code>b_fft</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in Fourier domain. If None, b should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. If None, the mesh registered in the operator will be used.</p> <code>None</code> <code>n_channel</code> <code>Optional[int]</code> <p>Number of channels of \\(x\\). If None, the number of channels registered in the operator will be used.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def solve(\n    self,\n    b: Optional[torch.Tensor] = None,\n    b_fft: Optional[torch.Tensor] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]]:\n\n    r\"\"\"\n    Solve the linear operator equation $Ax = b$, where $A$ is the linear operator and $b$ is the right-hand side.\n\n    Args:\n        b (Optional[torch.Tensor]): Right-hand side tensor in spatial domain. If None, b_fft should be provided.\n        b_fft (Optional[torch.Tensor]): Right-hand side tensor in Fourier domain. If None, b should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. If None, the mesh registered in the operator will be used.\n        n_channel (Optional[int]): Number of channels of $x$. If None, the number of channels registered in the operator will be used.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.\n    \"\"\"\n    if not (mesh is not None and n_channel is not None):\n        assert (\n            self._state_dict[\"f_mesh\"] is not None\n        ), \"Mesh and n_channel should be given when calling solve\"\n    if not (mesh is None and n_channel is None):\n        mesh = self._state_dict[\"f_mesh\"] if mesh is None else mesh\n        n_channel = (\n            self._state_dict[\"n_channel\"] if n_channel is None else n_channel\n        )\n        self.register_mesh(mesh, n_channel)\n    if self._state_dict[\"invert_linear_coef\"] is None:\n        self._state_dict[\"invert_linear_coef\"] = torch.where(\n            self._state_dict[\"linear_coef\"] == 0,\n            1.0,\n            1 / self._state_dict[\"linear_coef\"],\n        )\n    if b_fft is None:\n        b_fft = self._state_dict[\"f_mesh\"].fft(b)\n    value_fft = b_fft * self._state_dict[\"invert_linear_coef\"]\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, LinearOperator):\n        return LinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return LinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return LinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Laplacian.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/generic/_laplacian.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__( _LaplacianCore())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative","title":"torchfsm.operator.SpatialDerivative","text":"<p>               Bases: <code>LinearOperator</code></p> <p><code>SpatialDeritivate</code> calculates the spatial derivative of a scalar field w.r.t to a spatial dimension.     It is defined as\\(\\frac{\\partial ^n}{\\partial i} p\\) where \\(i = x, y, z, \\cdots\\) and \\(n=1, 2, 3, \\cdots\\)     Note that this class is an operator wrapper. The actual implementation of the operator is in the <code>_SpatialDerivativeCore</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>dim_index</code> <code>int</code> <p>The index of the spatial dimension.</p> required <code>order</code> <code>int</code> <p>The order of the derivative.</p> required Source code in <code>torchfsm/operator/generic/_spatial_derivative.py</code> <pre><code>class SpatialDerivative(LinearOperator):\n    r\"\"\"\n    `SpatialDeritivate` calculates the spatial derivative of a scalar field w.r.t to a spatial dimension.\n        It is defined as$\\frac{\\partial ^n}{\\partial i} p$ where $i = x, y, z, \\cdots$ and $n=1, 2, 3, \\cdots$\n        Note that this class is an operator wrapper. The actual implementation of the operator is in the `_SpatialDerivativeCore` class.\n\n    Args:\n        dim_index (int): The index of the spatial dimension.\n        order (int): The order of the derivative.\n    \"\"\"\n\n    def __init__(self, dim_index: int, order: int) -&gt; None:\n        super().__init__(_SpatialDerivativeGenerator(dim_index, order))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.solve","title":"solve","text":"<pre><code>solve(\n    b: Optional[Tensor] = None,\n    b_fft: Optional[Tensor] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]\n]\n</code></pre> <p>Solve the linear operator equation \\(Ax = b\\), where \\(A\\) is the linear operator and \\(b\\) is the right-hand side.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in spatial domain. If None, b_fft should be provided.</p> <code>None</code> <code>b_fft</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in Fourier domain. If None, b should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. If None, the mesh registered in the operator will be used.</p> <code>None</code> <code>n_channel</code> <code>Optional[int]</code> <p>Number of channels of \\(x\\). If None, the number of channels registered in the operator will be used.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def solve(\n    self,\n    b: Optional[torch.Tensor] = None,\n    b_fft: Optional[torch.Tensor] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]]:\n\n    r\"\"\"\n    Solve the linear operator equation $Ax = b$, where $A$ is the linear operator and $b$ is the right-hand side.\n\n    Args:\n        b (Optional[torch.Tensor]): Right-hand side tensor in spatial domain. If None, b_fft should be provided.\n        b_fft (Optional[torch.Tensor]): Right-hand side tensor in Fourier domain. If None, b should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. If None, the mesh registered in the operator will be used.\n        n_channel (Optional[int]): Number of channels of $x$. If None, the number of channels registered in the operator will be used.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.\n    \"\"\"\n    if not (mesh is not None and n_channel is not None):\n        assert (\n            self._state_dict[\"f_mesh\"] is not None\n        ), \"Mesh and n_channel should be given when calling solve\"\n    if not (mesh is None and n_channel is None):\n        mesh = self._state_dict[\"f_mesh\"] if mesh is None else mesh\n        n_channel = (\n            self._state_dict[\"n_channel\"] if n_channel is None else n_channel\n        )\n        self.register_mesh(mesh, n_channel)\n    if self._state_dict[\"invert_linear_coef\"] is None:\n        self._state_dict[\"invert_linear_coef\"] = torch.where(\n            self._state_dict[\"linear_coef\"] == 0,\n            1.0,\n            1 / self._state_dict[\"linear_coef\"],\n        )\n    if b_fft is None:\n        b_fft = self._state_dict[\"f_mesh\"].fft(b)\n    value_fft = b_fft * self._state_dict[\"invert_linear_coef\"]\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, LinearOperator):\n        return LinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return LinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return LinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.SpatialDerivative.__init__","title":"__init__","text":"<pre><code>__init__(dim_index: int, order: int) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/generic/_spatial_derivative.py</code> <pre><code>def __init__(self, dim_index: int, order: int) -&gt; None:\n    super().__init__(_SpatialDerivativeGenerator(dim_index, order))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection","title":"torchfsm.operator.KSConvection","text":"<p>               Bases: <code>NonlinearOperator</code></p> <p>The Kuramoto-Sivashinsky convection operator for a scalar field.     It is defined as: \\(\\frac{1}{2}|\\nabla \\phi|^2=\\frac{1}{2}\\sum_{i=0}^{I}(\\frac{\\partial \\phi}{\\partial i})^2\\)     Note that this class is an operator wrapper. The real implementation of the source term is in the <code>_KSConvectionCore</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>remove_mean</code> <code>bool</code> <p>Whether to remove the mean of the result. Default is True. Set to True will improve the stability of the simulation.</p> <code>True</code> Source code in <code>torchfsm/operator/dedicated/_ks_convection.py</code> <pre><code>class KSConvection(NonlinearOperator):\n\n    r\"\"\"\n    The Kuramoto-Sivashinsky convection operator for a scalar field.\n        It is defined as: $\\frac{1}{2}|\\nabla \\phi|^2=\\frac{1}{2}\\sum_{i=0}^{I}(\\frac{\\partial \\phi}{\\partial i})^2$\n        Note that this class is an operator wrapper. The real implementation of the source term is in the `_KSConvectionCore` class.\n\n    Args:\n        remove_mean (bool): Whether to remove the mean of the result. Default is True. Set to True will improve the stability of the simulation.\n    \"\"\"\n\n    def __init__(self, remove_mean: bool = True) -&gt; None:\n        super().__init__(_KSConvectionGenerator(remove_mean))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, NonlinearOperator):\n        return NonlinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return NonlinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return NonlinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.KSConvection.__init__","title":"__init__","text":"<pre><code>__init__(remove_mean: bool = True) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_ks_convection.py</code> <pre><code>def __init__(self, remove_mean: bool = True) -&gt; None:\n    super().__init__(_KSConvectionGenerator(remove_mean))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection","title":"torchfsm.operator.VorticityConvection","text":"<p>               Bases: <code>NonlinearOperator</code></p> <p>Operator for vorticity convection in 2D.      It is defined as \\((\\mathbf{u}\\cdot\\nabla) \\omega\\) where \\(\\omega\\) is the vorticity and \\(\\mathbf{u}\\) is the velocity.     Note that this class is an operator wrapper. The real implementation of the source term is in the <code>_VorticityConvectionCore</code> class.</p> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class VorticityConvection(NonlinearOperator):\n\n    r\"\"\"\n    Operator for vorticity convection in 2D. \n        It is defined as $(\\mathbf{u}\\cdot\\nabla) \\omega$ where $\\omega$ is the vorticity and $\\mathbf{u}$ is the velocity.\n        Note that this class is an operator wrapper. The real implementation of the source term is in the `_VorticityConvectionCore` class.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__(_VorticityConvectionGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, NonlinearOperator):\n        return NonlinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return NonlinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return NonlinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.VorticityConvection.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__(_VorticityConvectionGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity","title":"torchfsm.operator.Vorticity2Velocity","text":"<p>               Bases: <code>LinearOperator</code></p> <p>Operator for vorticity to velocity conversion in 2D.     It is defined as \\([u,v]=[-\\frac{\\partial \\nabla^{-2}\\omega}{\\partial y},\\frac{\\partial \\nabla^{-2}\\omega}{\\partial x}]\\).     Note that this class is an operator wrapper. The real implementation of the source term is in the <code>_Vorticity2VelocityCore</code> class.</p> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class Vorticity2Velocity(LinearOperator):\n\n    r\"\"\"\n    Operator for vorticity to velocity conversion in 2D.\n        It is defined as $[u,v]=[-\\frac{\\partial \\nabla^{-2}\\omega}{\\partial y},\\frac{\\partial \\nabla^{-2}\\omega}{\\partial x}]$.\n        Note that this class is an operator wrapper. The real implementation of the source term is in the `_Vorticity2VelocityCore` class.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(_Vorticity2VelocityGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.solve","title":"solve","text":"<pre><code>solve(\n    b: Optional[Tensor] = None,\n    b_fft: Optional[Tensor] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]\n]\n</code></pre> <p>Solve the linear operator equation \\(Ax = b\\), where \\(A\\) is the linear operator and \\(b\\) is the right-hand side.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in spatial domain. If None, b_fft should be provided.</p> <code>None</code> <code>b_fft</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in Fourier domain. If None, b should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. If None, the mesh registered in the operator will be used.</p> <code>None</code> <code>n_channel</code> <code>Optional[int]</code> <p>Number of channels of \\(x\\). If None, the number of channels registered in the operator will be used.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def solve(\n    self,\n    b: Optional[torch.Tensor] = None,\n    b_fft: Optional[torch.Tensor] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]]:\n\n    r\"\"\"\n    Solve the linear operator equation $Ax = b$, where $A$ is the linear operator and $b$ is the right-hand side.\n\n    Args:\n        b (Optional[torch.Tensor]): Right-hand side tensor in spatial domain. If None, b_fft should be provided.\n        b_fft (Optional[torch.Tensor]): Right-hand side tensor in Fourier domain. If None, b should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. If None, the mesh registered in the operator will be used.\n        n_channel (Optional[int]): Number of channels of $x$. If None, the number of channels registered in the operator will be used.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.\n    \"\"\"\n    if not (mesh is not None and n_channel is not None):\n        assert (\n            self._state_dict[\"f_mesh\"] is not None\n        ), \"Mesh and n_channel should be given when calling solve\"\n    if not (mesh is None and n_channel is None):\n        mesh = self._state_dict[\"f_mesh\"] if mesh is None else mesh\n        n_channel = (\n            self._state_dict[\"n_channel\"] if n_channel is None else n_channel\n        )\n        self.register_mesh(mesh, n_channel)\n    if self._state_dict[\"invert_linear_coef\"] is None:\n        self._state_dict[\"invert_linear_coef\"] = torch.where(\n            self._state_dict[\"linear_coef\"] == 0,\n            1.0,\n            1 / self._state_dict[\"linear_coef\"],\n        )\n    if b_fft is None:\n        b_fft = self._state_dict[\"f_mesh\"].fft(b)\n    value_fft = b_fft * self._state_dict[\"invert_linear_coef\"]\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, LinearOperator):\n        return LinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return LinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return LinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Velocity.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __init__(self):\n    super().__init__(_Vorticity2VelocityGenerator())\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure","title":"torchfsm.operator.Vorticity2Pressure","text":"<p>               Bases: <code>NonlinearOperator</code></p> <p>Operator for vorticity to pressure conversion in 2D.     It is defined as \\(\\begin{matrix}\\mathbf{u}=[u,v]=[-\\frac{\\partial \\nabla^{-2}\\omega}{\\partial y},\\frac{\\partial \\nabla^{-2}\\omega}{\\partial x}]\\\\ p= -\\nabla^{-2} (\\nabla \\cdot (\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}-f))\\end{matrix}\\).     Note that this class is an operator wrapper. The real implementation of the source term is in the <code>_Vorticity2PressureCore</code> class.</p> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class Vorticity2Pressure(NonlinearOperator):\n    r\"\"\"\n    Operator for vorticity to pressure conversion in 2D.\n        It is defined as $\\begin{matrix}\\mathbf{u}=[u,v]=[-\\frac{\\partial \\nabla^{-2}\\omega}{\\partial y},\\frac{\\partial \\nabla^{-2}\\omega}{\\partial x}]\\\\ p= -\\nabla^{-2} (\\nabla \\cdot (\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}-f))\\end{matrix}$.\n        Note that this class is an operator wrapper. The real implementation of the source term is in the `_Vorticity2PressureCore` class.\n    \"\"\"\n\n    def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n        super().__init__(_Vorticity2PressureGenerator(external_force))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, NonlinearOperator):\n        return NonlinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return NonlinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return NonlinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Vorticity2Pressure.__init__","title":"__init__","text":"<pre><code>__init__(\n    external_force: Optional[OperatorLike] = None,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n    super().__init__(_Vorticity2PressureGenerator(external_force))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure","title":"torchfsm.operator.Velocity2Pressure","text":"<p>               Bases: <code>NonlinearOperator</code></p> <p>Operator for velocity to pressure conversion.     It is defined as \\(-\\nabla^{-2} (\\nabla \\cdot (\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}-f))\\)     Note that this class is an operator wrapper. The real implementation of the source term is in the <code>_Velocity2PressureCore</code> class.</p> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class Velocity2Pressure(NonlinearOperator):\n    r\"\"\"\n    Operator for velocity to pressure conversion.\n        It is defined as $-\\nabla^{-2} (\\nabla \\cdot (\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}-f))$\n        Note that this class is an operator wrapper. The real implementation of the source term is in the `_Velocity2PressureCore` class.\n    \"\"\"\n\n    def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n        super().__init__(_Velocity2PressureCore(external_force))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, NonlinearOperator):\n        return NonlinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return NonlinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return NonlinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.Velocity2Pressure.__init__","title":"__init__","text":"<pre><code>__init__(\n    external_force: Optional[OperatorLike] = None,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n    super().__init__(_Velocity2PressureCore(external_force))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection","title":"torchfsm.operator.NSPressureConvection","text":"<p>               Bases: <code>NonlinearOperator</code></p> <p>Operator for Navier-Stokes pressure convection.     It is defined as \\(-\\nabla (\\nabla^{-2} \\nabla \\cdot (\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}-f))-\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u} + \\mathbf{f}\\).     Note that this class is an operator wrapper. The real implementation of the source term is in the <code>_NSPressureConvectionCore</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>external_force</code> <code>Optional[OperatorLike]</code> <p>Optional[OperatorLike], optional, default=None</p> <code>None</code> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class NSPressureConvection(NonlinearOperator):\n    r\"\"\"\n    Operator for Navier-Stokes pressure convection.\n        It is defined as $-\\nabla (\\nabla^{-2} \\nabla \\cdot (\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}-f))-\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u} + \\mathbf{f}$.\n        Note that this class is an operator wrapper. The real implementation of the source term is in the `_NSPressureConvectionCore` class.\n\n    Args:\n        external_force: Optional[OperatorLike], optional, default=None\n    \"\"\"\n\n    def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n        super().__init__(_NSPressureConvectionCore(external_force))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, NonlinearOperator):\n        return NonlinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return NonlinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return NonlinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.NSPressureConvection.__init__","title":"__init__","text":"<pre><code>__init__(\n    external_force: Optional[OperatorLike] = None,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n    super().__init__(_NSPressureConvectionCore(external_force))\n</code></pre>"},{"location":"apis/operator/#utils","title":"Utils","text":""},{"location":"apis/operator/#torchfsm.operator.run_operators","title":"torchfsm.operator.run_operators","text":"<pre><code>run_operators(\n    u: SpatialTensor[\"B C H ...\"],\n    operators: Sequence[Operator],\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Run a sequence of operators on the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>SpatialTensor</code> <p>Input tensor of shape (B, C, H, ...).</p> required <code>operators</code> <code>Sequence[Operator]</code> <p>Sequence of operators to be applied.</p> required <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <p>Returns:</p> Name Type Description <code>SpatialTensor</code> <code>SpatialTensor['B C H ...']</code> <p>Resulting tensor after applying the operators.</p> Source code in <code>torchfsm/operator/__init__.py</code> <pre><code>def run_operators(u:SpatialTensor[\"B C H ...\"],\n                  operators:Sequence[Operator],\n                  mesh: Union[Sequence[tuple[float, float, int]],MeshGrid,FourierMesh]) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Run a sequence of operators on the input tensor.\n\n    Args:\n        u (SpatialTensor): Input tensor of shape (B, C, H, ...).\n        operators (Sequence[Operator]): Sequence of operators to be applied.\n        mesh (Union[Sequence[tuple[float, float, int]],MeshGrid,FourierMesh]): Mesh information or mesh object.\n\n    Returns:\n        SpatialTensor: Resulting tensor after applying the operators.\n    \"\"\"\n    if not isinstance(mesh,FourierMesh):\n        mesh=FourierMesh(mesh)\n    u_fft=mesh.fft(u)\n    def _run_operator(operator:Operator):\n        return operator(u_fft=u_fft,mesh=mesh)\n    return map(_run_operator,operators)\n</code></pre>"},{"location":"apis/operator/#torchfsm.operator.check_value_with_mesh","title":"torchfsm.operator.check_value_with_mesh","text":"<pre><code>check_value_with_mesh(\n    u: SpatialTensor[\"B C H ...\"],\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n)\n</code></pre> <p>Check if the value and mesh are compatible. If not, raise a ValueError.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>SpatialTensor</code> <p>Input tensor of shape (B, C, H, ...).</p> required <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def check_value_with_mesh(\n    u: SpatialTensor[\"B C H ...\"],\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n):\n    r\"\"\"\n    Check if the value and mesh are compatible. If not, raise a ValueError.\n\n    Args:\n        u (SpatialTensor): Input tensor of shape (B, C, H, ...).\n        mesh (Union[Sequence[tuple[float, float, int]],MeshGrid,FourierMesh]): Mesh information or mesh object.\n    \"\"\"\n    if isinstance(mesh, FourierMesh) or isinstance(mesh, MeshGrid):\n        mesh = mesh.mesh_info\n    n_dim = len(mesh)\n    value_shape = u.shape\n    if len(value_shape) - 2 != n_dim:\n        raise ValueError(\n            f\"the value shape {value_shape} is not compatible with mesh dim {n_dim}\"\n        )\n    for i in range(n_dim):\n        if value_shape[i + 2] != mesh[i][2]:\n            raise ValueError(\n                f\"Expect to have {mesh[i][2]} points in dim {i} but got {value_shape[i+2]}\"\n            )\n</code></pre>"},{"location":"apis/operator_base/","title":"9. Base Classes for Operators","text":""},{"location":"apis/operator_base/#torchfsm.operator.LinearCoef","title":"torchfsm.operator.LinearCoef","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for linear coefficients.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>class LinearCoef(ABC):\n\n    r\"\"\"\n    Abstract class for linear coefficients.\n    \"\"\"\n\n    @abstractmethod\n    def __call__(\n        self, f_mesh: FourierMesh, n_channel: int\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        r\"\"\"\n        Abstract method to be implemented by subclasses. It should define the linear coefficient tensor.\n\n        Args:\n            f_mesh (FourierMesh): Fourier mesh object.\n            n_channel (int): Number of channels of the input tensor.\n\n        Returns:\n            FourierTensor: Linear coefficient tensor.\n        \"\"\"\n\n        raise NotImplementedError\n\n    def nonlinear_like(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        r\"\"\"\n        Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.\n\n        Args:\n            u_fft (FourierTensor): Fourier-transformed input tensor.\n            f_mesh (FourierMesh): Fourier mesh object.\n            u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n        Returns:\n            FourierTensor: Nonlinear-like tensor.\n        \"\"\"\n        return self(f_mesh, u_fft.shape[1]) * u_fft\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearCoef.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> <p>Abstract method to be implemented by subclasses. It should define the linear coefficient tensor.</p> <p>Parameters:</p> Name Type Description Default <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <p>Returns:</p> Name Type Description <code>FourierTensor</code> <code>FourierTensor['B C H ...']</code> <p>Linear coefficient tensor.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>@abstractmethod\ndef __call__(\n    self, f_mesh: FourierMesh, n_channel: int\n) -&gt; FourierTensor[\"B C H ...\"]:\n    r\"\"\"\n    Abstract method to be implemented by subclasses. It should define the linear coefficient tensor.\n\n    Args:\n        f_mesh (FourierMesh): Fourier mesh object.\n        n_channel (int): Number of channels of the input tensor.\n\n    Returns:\n        FourierTensor: Linear coefficient tensor.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearCoef.nonlinear_like","title":"nonlinear_like","text":"<pre><code>nonlinear_like(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> <p>Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FourierTensor</code> <code>FourierTensor['B C H ...']</code> <p>Nonlinear-like tensor.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def nonlinear_like(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    r\"\"\"\n    Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        FourierTensor: Nonlinear-like tensor.\n    \"\"\"\n    return self(f_mesh, u_fft.shape[1]) * u_fft\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearFunc","title":"torchfsm.operator.NonlinearFunc","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for nonlinear functions.</p> <p>Parameters:</p> Name Type Description Default <code>dealiasing_swtich</code> <code>bool</code> <p>Whether to apply dealiasing. Default is True. If True, the dealiased version of u_fft will be input to the function in operator. If False, the original u_fft will be used.</p> <code>True</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>class NonlinearFunc(ABC):\n\n    r\"\"\"\n    Abstract class for nonlinear functions.\n\n    Args:\n        dealiasing_swtich (bool): Whether to apply dealiasing. Default is True.\n            If True, the dealiased version of u_fft will be input to the function in operator.\n            If False, the original u_fft will be used.\n    \"\"\"\n\n    def __init__(self, dealiasing_swtich: bool = True) -&gt; None:\n        self._dealiasing_swtich = dealiasing_swtich\n\n    @abstractmethod\n    def __call__(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        r\"\"\"\n        Abstract method to be implemented by subclasses. It should define the nonlinear function.\n\n        Args:\n            u_fft (FourierTensor): Fourier-transformed input tensor.\n            f_mesh (FourierMesh): Fourier mesh object.\n            u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n        Returns:\n            FourierTensor: Result of the nonlinear function.\n        \"\"\"\n        raise NotImplementedError\n\n    def spatial_value(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n    ) -&gt; SpatialTensor[\"B C H ...\"]:\n        r\"\"\"\n        Return the result of the nonlinear function in spatial domain.\n\n        Args:\n            u_fft (FourierTensor): Fourier-transformed input tensor.\n            f_mesh (FourierMesh): Fourier mesh object.\n            u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n        Returns:\n            SpatialTensor: Result of the nonlinear function in spatial domain.\n        \"\"\"\n\n        return f_mesh.ifft(self(u_fft, f_mesh, u)).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearFunc.__init__","title":"__init__","text":"<pre><code>__init__(dealiasing_swtich: bool = True) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __init__(self, dealiasing_swtich: bool = True) -&gt; None:\n    self._dealiasing_swtich = dealiasing_swtich\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearFunc.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> <p>Abstract method to be implemented by subclasses. It should define the nonlinear function.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FourierTensor</code> <code>FourierTensor['B C H ...']</code> <p>Result of the nonlinear function.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>@abstractmethod\ndef __call__(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    r\"\"\"\n    Abstract method to be implemented by subclasses. It should define the nonlinear function.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        FourierTensor: Result of the nonlinear function.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearFunc.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Return the result of the nonlinear function in spatial domain.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SpatialTensor</code> <code>SpatialTensor['B C H ...']</code> <p>Result of the nonlinear function in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Return the result of the nonlinear function in spatial domain.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        SpatialTensor: Result of the nonlinear function in spatial domain.\n    \"\"\"\n\n    return f_mesh.ifft(self(u_fft, f_mesh, u)).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.CoreGenerator","title":"torchfsm.operator.CoreGenerator","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract class for core generator. A core generator is a callable that generates a linear coefficient or a nonlinear function based on the Fourier mesh and channels of the tensor.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>class CoreGenerator(ABC):\n\n    r\"\"\"\n    Abstract class for core generator. A core generator is a callable that generates a linear coefficient or a nonlinear function based on the Fourier mesh and channels of the tensor.\n    \"\"\"\n\n    @abstractmethod\n    def __call__(\n        self, f_mesh: FourierMesh, n_channel: int\n    ) -&gt; Union[LinearCoef, NonlinearFunc]:\n        r\"\"\"\n        Abstract method to be implemented by subclasses. It should define the core generator.\n\n        Args:\n            f_mesh (FourierMesh): Fourier mesh object.\n            n_channel (int): Number of channels of the input tensor.\n\n        Returns:\n            Union[LinearCoef, NonlinearFunc]: Linear coefficient or nonlinear function.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.CoreGenerator.__call__","title":"__call__  <code>abstractmethod</code>","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; Union[LinearCoef, NonlinearFunc]\n</code></pre> <p>Abstract method to be implemented by subclasses. It should define the core generator.</p> <p>Parameters:</p> Name Type Description Default <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <p>Returns:</p> Type Description <code>Union[LinearCoef, NonlinearFunc]</code> <p>Union[LinearCoef, NonlinearFunc]: Linear coefficient or nonlinear function.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>@abstractmethod\ndef __call__(\n    self, f_mesh: FourierMesh, n_channel: int\n) -&gt; Union[LinearCoef, NonlinearFunc]:\n    r\"\"\"\n    Abstract method to be implemented by subclasses. It should define the core generator.\n\n    Args:\n        f_mesh (FourierMesh): Fourier mesh object.\n        n_channel (int): Number of channels of the input tensor.\n\n    Returns:\n        Union[LinearCoef, NonlinearFunc]: Linear coefficient or nonlinear function.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._MutableMixIn","title":"torchfsm.operator._base._MutableMixIn","text":"<p>Mixin class for mutable operations. This class supports basic arithmetic operations for the operator.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>class _MutableMixIn:\n\n    r'''\n    Mixin class for mutable operations. This class supports basic arithmetic operations for the operator.\n    '''\n\n    def __radd__(self, other):\n        return self + other\n\n    def __iadd__(self, other):\n        return self + other\n\n    def __sub__(self, other):\n        try:\n            return self + (-1 * other)\n        except Exception:\n            return NotImplemented\n\n    def __rsub__(self, other):\n        try:\n            return other + (-1 * self)\n        except Exception:\n            return NotImplemented\n\n    def __isub__(self, other):\n        return self - other\n\n    def __rmul__(self, other):\n        return self * other\n\n    def __imul__(self, other):\n        return self * other\n\n    def __truediv__(self, other):\n        try:\n            return self * (1 / other)\n        except:\n            return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._MutableMixIn.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._MutableMixIn.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._MutableMixIn.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._MutableMixIn.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._MutableMixIn.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._MutableMixIn.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._MutableMixIn.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._MutableMixIn.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._InverseSolveMixin","title":"torchfsm.operator._base._InverseSolveMixin","text":"Source code in <code>torchfsm/operator/_base.py</code> <pre><code>class _InverseSolveMixin:\n    _state_dict: Optional[dict]\n    register_mesh: Callable\n\n    r'''\n    Mixin class for inverse solving operations. This class supports solving the linear operator equation.\n    '''\n\n    def solve(\n        self,\n        b: Optional[torch.Tensor] = None,\n        b_fft: Optional[torch.Tensor] = None,\n        mesh: Optional[\n            Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n        ] = None,\n        n_channel: Optional[int] = None,\n        return_in_fourier=False,\n    ) -&gt; Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]]:\n\n        r\"\"\"\n        Solve the linear operator equation $Ax = b$, where $A$ is the linear operator and $b$ is the right-hand side.\n\n        Args:\n            b (Optional[torch.Tensor]): Right-hand side tensor in spatial domain. If None, b_fft should be provided.\n            b_fft (Optional[torch.Tensor]): Right-hand side tensor in Fourier domain. If None, b should be provided.\n            mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. If None, the mesh registered in the operator will be used.\n            n_channel (Optional[int]): Number of channels of $x$. If None, the number of channels registered in the operator will be used.\n            return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain.\n\n        Returns:\n            Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.\n        \"\"\"\n        if not (mesh is not None and n_channel is not None):\n            assert (\n                self._state_dict[\"f_mesh\"] is not None\n            ), \"Mesh and n_channel should be given when calling solve\"\n        if not (mesh is None and n_channel is None):\n            mesh = self._state_dict[\"f_mesh\"] if mesh is None else mesh\n            n_channel = (\n                self._state_dict[\"n_channel\"] if n_channel is None else n_channel\n            )\n            self.register_mesh(mesh, n_channel)\n        if self._state_dict[\"invert_linear_coef\"] is None:\n            self._state_dict[\"invert_linear_coef\"] = torch.where(\n                self._state_dict[\"linear_coef\"] == 0,\n                1.0,\n                1 / self._state_dict[\"linear_coef\"],\n            )\n        if b_fft is None:\n            b_fft = self._state_dict[\"f_mesh\"].fft(b)\n        value_fft = b_fft * self._state_dict[\"invert_linear_coef\"]\n        if return_in_fourier:\n            return value_fft\n        else:\n            return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._InverseSolveMixin.register_mesh","title":"register_mesh  <code>instance-attribute</code>","text":"<pre><code>register_mesh: Callable\n</code></pre> <p>Mixin class for inverse solving operations. This class supports solving the linear operator equation.</p>"},{"location":"apis/operator_base/#torchfsm.operator._base._InverseSolveMixin.solve","title":"solve","text":"<pre><code>solve(\n    b: Optional[Tensor] = None,\n    b_fft: Optional[Tensor] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]\n]\n</code></pre> <p>Solve the linear operator equation \\(Ax = b\\), where \\(A\\) is the linear operator and \\(b\\) is the right-hand side.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in spatial domain. If None, b_fft should be provided.</p> <code>None</code> <code>b_fft</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in Fourier domain. If None, b should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. If None, the mesh registered in the operator will be used.</p> <code>None</code> <code>n_channel</code> <code>Optional[int]</code> <p>Number of channels of \\(x\\). If None, the number of channels registered in the operator will be used.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def solve(\n    self,\n    b: Optional[torch.Tensor] = None,\n    b_fft: Optional[torch.Tensor] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]]:\n\n    r\"\"\"\n    Solve the linear operator equation $Ax = b$, where $A$ is the linear operator and $b$ is the right-hand side.\n\n    Args:\n        b (Optional[torch.Tensor]): Right-hand side tensor in spatial domain. If None, b_fft should be provided.\n        b_fft (Optional[torch.Tensor]): Right-hand side tensor in Fourier domain. If None, b should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. If None, the mesh registered in the operator will be used.\n        n_channel (Optional[int]): Number of channels of $x$. If None, the number of channels registered in the operator will be used.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.\n    \"\"\"\n    if not (mesh is not None and n_channel is not None):\n        assert (\n            self._state_dict[\"f_mesh\"] is not None\n        ), \"Mesh and n_channel should be given when calling solve\"\n    if not (mesh is None and n_channel is None):\n        mesh = self._state_dict[\"f_mesh\"] if mesh is None else mesh\n        n_channel = (\n            self._state_dict[\"n_channel\"] if n_channel is None else n_channel\n        )\n        self.register_mesh(mesh, n_channel)\n    if self._state_dict[\"invert_linear_coef\"] is None:\n        self._state_dict[\"invert_linear_coef\"] = torch.where(\n            self._state_dict[\"linear_coef\"] == 0,\n            1.0,\n            1 / self._state_dict[\"linear_coef\"],\n        )\n    if b_fft is None:\n        b_fft = self._state_dict[\"f_mesh\"].fft(b)\n    value_fft = b_fft * self._state_dict[\"invert_linear_coef\"]\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._DeAliasMixin","title":"torchfsm.operator._base._DeAliasMixin","text":"Source code in <code>torchfsm/operator/_base.py</code> <pre><code>class _DeAliasMixin:\n    _de_aliasing_rate: float\n    _state_dict: Optional[dict]\n\n    r'''\n    Mixin class for de-aliasing operations. This class supports setting the de-aliasing rate for the nonlinear operator.\n    '''\n\n    def set_de_aliasing_rate(self, de_aliasing_rate: float):\n        r\"\"\"\n        Set the de-aliasing rate for the nonlinear operator.\n        Args:\n            de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n        \"\"\"\n\n        self._de_aliasing_rate = de_aliasing_rate\n        self._state_dict = None\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator._base._DeAliasMixin.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike","title":"torchfsm.operator.OperatorLike","text":"<p>               Bases: <code>_MutableMixIn</code></p> <p>Base class for All Operators.</p> <p>Parameters:</p> Name Type Description Default <code>operator_generators</code> <code>Optional[ValueList[GeneratorLike]]</code> <p>List of operator generators. Default is None. Each generator should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> <code>None</code> <code>coefs</code> <code>Optional[List]</code> <p>List of coefficients for each operator generator. Default is None. If None, all coefficients are set to 1. The length of the list should match the number of operator generators.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>class OperatorLike(_MutableMixIn):\n\n    r\"\"\"\n    Base class for All Operators.\n\n    Args:\n        operator_generators (Optional[ValueList[GeneratorLike]]): List of operator generators. Default is None.\n            Each generator should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coefs (Optional[List]): List of coefficients for each operator generator. Default is None.\n            If None, all coefficients are set to 1.\n            The length of the list should match the number of operator generators.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        operator_generators: Optional[ValueList[GeneratorLike]] = None,\n        coefs: Optional[List] = None,\n    ) -&gt; None:\n        super().__init__()\n        self.operator_generators = default(operator_generators, [])\n        if not isinstance(self.operator_generators, list):\n            self.operator_generators = [self.operator_generators]\n        self.coefs = default(coefs, [1] * len(self.operator_generators))\n        self._state_dict = {\n            \"f_mesh\": None,\n            \"n_channel\": None,\n            \"linear_coef\": None,\n            \"nonlinear_func\": None,\n            \"operator\": None,\n            \"integrator\": None,\n            \"invert_linear_coef\": None,\n        }\n        self._nonlinear_funcs = []\n        self._de_aliasing_rate = 2 / 3\n        self._value_mesh_check_func = lambda dim_value, dim_mesh: True\n        self._integrator = \"auto\"\n        self._integrator_config = {}\n        self._is_etdrk_integrator = True\n\n    @property\n    def is_linear(self) -&gt; bool:\n        r\"\"\"\n        Check if the operator is linear.\n\n        Returns:\n            bool: True if the operator is linear, False otherwise.\n        \"\"\"\n        assert (\n            self._state_dict[\"f_mesh\"] is not None\n        ), \"Mesh should be registered before checking if the operator is linear\"\n        return (\n            self._state_dict[\"nonlinear_func\"] is None\n            and self._state_dict[\"linear_coef\"] is not None\n        )\n\n    def _build_linear_coefs(\n        self, linear_coefs: Optional[Sequence[LinearCoef]]\n    ):\n        r\"\"\"\n        Build the linear coefficients based on the provided linear coefficient generators.\n\n        Args:\n            linear_coefs (Optional[Sequence[LinearCoef]]): List of linear coefficient generators.\n\n        \"\"\"\n        if len(linear_coefs) == 0:\n            linear_coefs = None\n        else:\n            linear_coefs = sum(\n                [\n                    coef * op(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n                    for coef, op in linear_coefs\n                ]\n            )\n        self._state_dict[\"linear_coef\"] = linear_coefs\n\n    def _build_nonlinear_funcs(\n        self, nonlinear_funcs: Optional[Sequence[NonlinearFunc]]\n    ):\n        r\"\"\"\n        Build the nonlinear functions based on the provided nonlinear function generators.\n\n        Args:\n            nonlinear_funcs (Optional[Sequence[NonlinearFunc]]): List of nonlinear function generators.\n        \"\"\"\n        if len(nonlinear_funcs) == 0:\n            nonlinear_funcs_all = None\n        else:\n            self._state_dict[\"f_mesh\"].set_default_freq_threshold(\n                self._de_aliasing_rate\n            )\n\n            def nonlinear_funcs_all(u_fft):\n                result = 0.0\n                dealiased_u_fft = None\n                dealiased_u = None\n                u = None\n                for coef, fun in nonlinear_funcs:\n                    if fun._dealiasing_swtich:\n                        if dealiased_u_fft is None:\n                            dealiased_u_fft = u_fft * self._state_dict[\n                                \"f_mesh\"\n                            ].low_pass_filter(self._de_aliasing_rate)\n                            dealiased_u = (\n                                self._state_dict[\"f_mesh\"].ifft(dealiased_u_fft).real\n                            )\n                        result += coef * fun(\n                            dealiased_u_fft,\n                            self._state_dict[\"f_mesh\"],\n                            dealiased_u,\n                        )\n                    else:\n                        if u is None:\n                            u = self._state_dict[\"f_mesh\"].ifft(u_fft).real\n                        result += coef * fun(\n                            u_fft,\n                            self._state_dict[\"f_mesh\"],\n                            u,\n                        )\n\n                return result\n\n        self._state_dict[\"nonlinear_func\"] = nonlinear_funcs_all\n\n    def _build_operator(self):\n        r\"\"\"\n        Build the operator based on the linear coefficient and nonlinear function.\n        If both linear coefficient and nonlinear function are None, the operator is set to None.\n        \"\"\"\n        if self._state_dict[\"nonlinear_func\"] is None:\n            def operator(u_fft):\n                return self._state_dict[\"linear_coef\"] * u_fft\n        elif self._state_dict[\"linear_coef\"] is None:\n            def operator(u_fft):\n                return self._state_dict[\"nonlinear_func\"](u_fft)\n        elif self._state_dict[\"nonlinear_func\"] is not None and self._state_dict[\"linear_coef\"] is not None:\n            def operator(u_fft):\n                return self._state_dict[\"linear_coef\"] * u_fft + self._state_dict[\n                    \"nonlinear_func\"\n                ](u_fft)\n        else:\n            raise ValueError(\n                \"Both linear coefficient and nonlinear function are None. Cannot build operator.\"\n            )\n\n        self._state_dict[\"operator\"] = operator\n\n    def _build_integrator(\n        self,\n        dt: float,\n    ):\n        r\"\"\"\n        Build the integrator based on the provided time step and integrator type.\n\n        Args:\n            dt (float): Time step for the integrator.\n        \"\"\"\n        if self._integrator == \"auto\":\n            if self.is_linear:\n                solver = ETDRKIntegrator.ETDRK0\n            else:\n                solver = ETDRKIntegrator.ETDRK4\n        else:\n            solver = self._integrator\n        self._is_etdrk_integrator = isinstance(solver, ETDRKIntegrator)\n        if self._is_etdrk_integrator:\n            if solver == ETDRKIntegrator.ETDRK0:\n                assert self.is_linear, \"The ETDRK0 integrator only supports linear term\"\n                self._state_dict[\"integrator\"] = solver.value(\n                    dt,\n                    self._state_dict[\"linear_coef\"],\n                    **self._integrator_config,\n                )\n            else:\n                if self._state_dict[\"linear_coef\"] is None:\n                    linear_coef = torch.tensor(\n                        [0.0],\n                        dtype=self._state_dict[\"f_mesh\"].dtype,\n                        device=self._state_dict[\"f_mesh\"].device,\n                    )\n                else:\n                    linear_coef = self._state_dict[\"linear_coef\"]\n                self._state_dict[\"integrator\"] = solver.value(\n                    dt,\n                    linear_coef,\n                    self._state_dict[\"nonlinear_func\"],\n                    **self._integrator_config,\n                )\n            setattr(\n                self._state_dict[\"integrator\"],\n                \"forward\",\n                lambda u_fft, dt: self._state_dict[\"integrator\"].step(u_fft),\n            )\n        elif isinstance(solver, RKIntegrator):\n            if self._state_dict[\"operator\"] is None:\n                self._build_operator()\n            self._state_dict[\"integrator\"] = solver.value(**self._integrator_config)\n            setattr(\n                self._state_dict[\"integrator\"],\n                \"forward\",\n                lambda u_fft, dt: self._state_dict[\"integrator\"].step(\n                    self._state_dict[\"operator\"], u_fft, dt\n                ),\n            )\n\n    def _pre_check(\n        self,\n        u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n        u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n        mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh] = None,\n    ) -&gt; Tuple[FourierMesh, int]:\n        r\"\"\"\n        Pre-check the input tensor and mesh. If the mesh is not registered, register it.\n\n        Args:\n            u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n            u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n                At least one of u or u_fft should be provided.\n            mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object. Default is None.\n                If None, the mesh registered in the operator will be used.\n\n        Returns:\n            Tuple[FourierMesh, int]: Tuple of Fourier mesh and number of channels.\n        \"\"\"\n\n        if u_fft is None and u is None:\n            raise ValueError(\"Either u or u_fft should be given\")\n        if u_fft is not None and u is not None:\n            assert u.shape == u_fft.shape, \"The shape of u and u_fft should be the same\"\n        assert mesh is not None, \"Mesh should be given\"\n        value_device = u.device if u is not None else u_fft.device\n        value_dtype = u.dtype if u is not None else u_fft.dtype\n        if not isinstance(mesh, FourierMesh):\n            if not isinstance(mesh, MeshGrid):\n                mesh = FourierMesh(mesh, device=value_device, dtype=value_dtype)\n            else:\n                mesh = FourierMesh(mesh)\n        n_channel = u.shape[1] if u is not None else u_fft.shape[1]\n        value_shape = u.shape if u is not None else u_fft.shape\n        assert (\n            len(value_shape) == mesh.n_dim + 2\n        ), f\"the value shape {value_shape} is not compatible with mesh dim {mesh.n_dim}\"\n        for i in range(mesh.n_dim):\n            assert (\n                value_shape[i + 2] == mesh.mesh_info[i][2]\n            ), f\"Expect to have {mesh.mesh_info[i][2]} points in dim {i} but got {value_shape[i+2]}\"\n        assert (\n            value_device == mesh.device\n        ), \"The device of mesh {} and the device of value {} are not the same\".format(\n            mesh.device, value_device\n        )\n        # assert value_dtype==mesh.dtype, \"The dtype of mesh {} and the dtype of value {} are not the same\".format(mesh.dtype,value_dtype)\n        # value fft is a complex dtype\n        assert self._value_mesh_check_func(\n            len(value_shape) - 2, mesh.n_dim\n        ), \"Value and mesh do not match the requirement\"\n        return mesh, n_channel\n\n    def register_mesh(\n        self,\n        mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n        n_channel: int,\n        device=None,\n        dtype=None,\n    ):\n        r\"\"\"\n        Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n        Args:\n            mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n            n_channel (int): Number of channels of the input tensor.\n            device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n            dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n        \"\"\"\n        if isinstance(mesh, FourierMesh):\n            f_mesh = mesh\n            if device is not None or dtype is not None:\n                f_mesh.to(device=device, dtype=dtype)\n        else:\n            f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n        for key in self._state_dict:\n            self._state_dict[key] = None\n        self._state_dict.update(\n            {\n                \"f_mesh\": f_mesh,\n                \"n_channel\": n_channel,\n            }\n        )\n        linear_coefs = []\n        nonlinear_funcs = []\n        for coef, generator in zip(self.coefs, self.operator_generators):\n            op = generator(f_mesh, n_channel)\n            if isinstance(op, LinearCoef):\n                linear_coefs.append((coef, op))\n            elif isinstance(op, NonlinearFunc):\n                nonlinear_funcs.append((coef, op))\n            else:\n                raise ValueError(f\"Operator {op} is not supported\")\n        self._nonlinear_funcs = nonlinear_funcs\n        self._build_linear_coefs(linear_coefs)\n        self._build_nonlinear_funcs(self._nonlinear_funcs)\n\n    def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n        r\"\"\"\n        Register an additional check function for the value and mesh compatibility.\n\n        Args:\n            func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n        \"\"\"\n        self._value_mesh_check_func = func\n\n    def add_generator(self, generator: GeneratorLike, coef=1):\n        r\"\"\"\n        Add a generator to the operator.\n\n        Args:\n            generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n            coef (float): Coefficient for the generator. Default is 1.\n        \"\"\"\n        self.operator_generators.append(generator)\n        self.coefs.append(coef)\n\n    def set_integrator(\n        self,\n        integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n        **integrator_config,\n    ):\n        r\"\"\"\n        Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n        Args:\n            integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n                If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n            **integrator_config: Additional configuration for the integrator.\n        \"\"\"\n\n        if isinstance(integrator, str):\n            assert (\n                integrator == \"auto\"\n            ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n        else:\n            assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n                integrator, RKIntegrator\n            ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n        self._integrator = integrator\n        self._integrator_config = integrator_config\n        self._state_dict[\"integrator\"] = None\n\n    def integrate(\n        self,\n        u_0: Optional[torch.Tensor] = None,\n        u_0_fft: Optional[torch.Tensor] = None,\n        dt: float = 1,\n        step: int = 1,\n        mesh: Optional[\n            Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n        ] = None,\n        progressive: bool = False,\n        trajectory_recorder: Optional[_TrajRecorder] = None,\n        return_in_fourier: bool = False,\n\n    ) -&gt; Union[\n            SpatialTensor[\"B C H ...\"],\n            SpatialTensor[\"B T C H ...\"],\n            FourierTensor[\"B C H ...\"],\n            FourierTensor[\"B T C H ...\"],\n        ]:\n        r\"\"\"\n        Integrate the operator using the provided initial condition and time step.  \n\n        Args:\n            u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n            u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n                At least one of u_0 or u_0_fft should be provided.\n            dt (float): Time step for the integrator. Default is 1.\n            step (int): Number of time steps to integrate. Default is 1.\n            mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n                If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n            progressive (bool): If True, show a progress bar during integration. Default is False.\n            trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n                If None, no trajectory will be recorded. The function will only return the final frame.\n            return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n        Returns:\n            Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n                If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n                If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n        \"\"\"\n        if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n            mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n            self.register_mesh(mesh, n_channel)\n        else:\n            self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n        if self._state_dict[\"integrator\"] is None:\n            self._build_integrator(dt)\n        elif self._is_etdrk_integrator:\n            if self._state_dict[\"integrator\"].dt != dt:\n                self._build_integrator(dt)\n        f_mesh = self._state_dict[\"f_mesh\"]\n        if u_0_fft is None:\n            u_0_fft = f_mesh.fft(u_0)\n        p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n        for i in p_bar:\n            if trajectory_recorder is not None:\n                trajectory_recorder.record(i, u_0_fft)\n            u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i + 1, u_0_fft)\n            trajectory_recorder.return_in_fourier = return_in_fourier\n            return trajectory_recorder.trajectory\n        else:\n            if return_in_fourier:\n                return u_0_fft\n            else:\n                return f_mesh.ifft(u_0_fft).real\n\n    def __call__(\n        self,\n        u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n        u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n        mesh: Optional[\n            Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n        ] = None,\n        return_in_fourier=False,\n    ) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n        r\"\"\"\n        Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n        Args:\n            u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n            u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n                At least one of u or u_fft should be provided.\n            mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n                If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n            return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n        Returns:\n            Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n        \"\"\"    \n\n        if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n            mesh, n_channel = self._pre_check(u, u_fft, mesh)\n            self.register_mesh(mesh, n_channel)\n        else:\n            self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n        if self._state_dict[\"operator\"] is None:\n            self._build_operator()\n        if u_fft is None:\n            u_fft = self._state_dict[\"f_mesh\"].fft(u)\n        value_fft = self._state_dict[\"operator\"](u_fft)\n        if return_in_fourier:\n            return value_fft\n        else:\n            return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n\n    def to(self, device=None, dtype=None):\n        r\"\"\"\n        Move the operator to the specified device and change the data type.\n\n        Args:\n            device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n            dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n        \"\"\"\n        if self._state_dict is not None:\n            self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n            self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear: bool\n</code></pre> <p>Check if the operator is linear.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the operator is linear, False otherwise.</p>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.__init__","title":"__init__","text":"<pre><code>__init__(\n    operator_generators: Optional[\n        ValueList[GeneratorLike]\n    ] = None,\n    coefs: Optional[List] = None,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __init__(\n    self,\n    operator_generators: Optional[ValueList[GeneratorLike]] = None,\n    coefs: Optional[List] = None,\n) -&gt; None:\n    super().__init__()\n    self.operator_generators = default(operator_generators, [])\n    if not isinstance(self.operator_generators, list):\n        self.operator_generators = [self.operator_generators]\n    self.coefs = default(coefs, [1] * len(self.operator_generators))\n    self._state_dict = {\n        \"f_mesh\": None,\n        \"n_channel\": None,\n        \"linear_coef\": None,\n        \"nonlinear_func\": None,\n        \"operator\": None,\n        \"integrator\": None,\n        \"invert_linear_coef\": None,\n    }\n    self._nonlinear_funcs = []\n    self._de_aliasing_rate = 2 / 3\n    self._value_mesh_check_func = lambda dim_value, dim_mesh: True\n    self._integrator = \"auto\"\n    self._integrator_config = {}\n    self._is_etdrk_integrator = True\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.OperatorLike.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator","title":"torchfsm.operator.Operator","text":"<p>               Bases: <code>OperatorLike</code>, <code>_DeAliasMixin</code></p> <p>Operator class for linear and nonlinear operations.</p> <p>Parameters:</p> Name Type Description Default <code>operator_generators</code> <code>Optional[ValueList[GeneratorLike]]</code> <p>List of operator generators. Default is None. Each generator should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> <code>None</code> <code>coefs</code> <code>Optional[List]</code> <p>List of coefficients for each operator generator. Default is None. If None, all coefficients are set to 1. The length of the list should match the number of operator generators.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>class Operator(OperatorLike, _DeAliasMixin):\n    r\"\"\"\n    Operator class for linear and nonlinear operations.\n\n    Args:\n        operator_generators (Optional[ValueList[GeneratorLike]]): List of operator generators. Default is None.\n            Each generator should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coefs (Optional[List]): List of coefficients for each operator generator. Default is None.\n            If None, all coefficients are set to 1.\n            The length of the list should match the number of operator generators.\n    \"\"\"\n\n    def __init__(\n        self,\n        operator_generators: Optional[ValueList[GeneratorLike]] = None,\n        coefs: Optional[List] = None,\n    ) -&gt; None:\n        super().__init__(operator_generators, coefs)\n\n    def __add__(self, other):\n        if isinstance(other, OperatorLike):\n            return Operator(\n                self.operator_generators + other.operator_generators,\n                self.coefs + other.coefs,\n            )\n        elif isinstance(other, Tensor):\n            return Operator(\n                self.operator_generators\n                + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n                self.coefs + [1],\n            )\n        else:\n            return NotImplemented\n\n    def __mul__(self, other):\n        if isinstance(other, OperatorLike):\n            return NotImplemented\n        else:\n            return Operator(\n                self.operator_generators, [coef * other for coef in self.coefs]\n            )\n\n    def __neg__(self):\n        return Operator(self.operator_generators, [-1 * coef for coef in self.coefs])\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear: bool\n</code></pre> <p>Check if the operator is linear.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the operator is linear, False otherwise.</p>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__init__","title":"__init__","text":"<pre><code>__init__(\n    operator_generators: Optional[\n        ValueList[GeneratorLike]\n    ] = None,\n    coefs: Optional[List] = None,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __init__(\n    self,\n    operator_generators: Optional[ValueList[GeneratorLike]] = None,\n    coefs: Optional[List] = None,\n) -&gt; None:\n    super().__init__(operator_generators, coefs)\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return Operator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.Operator.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return Operator(self.operator_generators, [-1 * coef for coef in self.coefs])\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator","title":"torchfsm.operator.LinearOperator","text":"<p>               Bases: <code>OperatorLike</code>, <code>_InverseSolveMixin</code></p> <p>Operators that contain only linear operations.</p> <p>Parameters:</p> Name Type Description Default <code>linear_coef</code> <code>ValueList[Union[LinearCoef, GeneratorLike]]</code> <p>List of linear coefficient generators. Default is None. Each generator should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient.</p> <code>None</code> <code>coefs</code> <code>Optional[List]</code> <p>List of coefficients for each linear coefficient generator. Default is None. If None, all coefficients are set to 1. The length of the list should match the number of linear coefficient generators.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>class LinearOperator(OperatorLike, _InverseSolveMixin):\n\n    r\"\"\"\n    Operators that contain only linear operations.\n\n    Args:\n        linear_coef (ValueList[Union[LinearCoef, GeneratorLike]]): List of linear coefficient generators. Default is None.\n            Each generator should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient.\n        coefs (Optional[List]): List of coefficients for each linear coefficient generator. Default is None.\n            If None, all coefficients are set to 1.\n            The length of the list should match the number of linear coefficient generators.\n    \"\"\"\n\n\n    def __init__(\n        self,\n        linear_coef: ValueList[Union[LinearCoef, GeneratorLike]] = None,\n        coefs: Optional[List] = None,\n    ) -&gt; None:\n        if not isinstance(linear_coef, list):\n            linear_coef = [linear_coef]\n        super().__init__(\n            operator_generators=[\n                (\n                    linear_coef_i\n                    if not isinstance(linear_coef_i, LinearCoef)\n                    else lambda f_mesh, n_channel: linear_coef_i\n                )\n                for linear_coef_i in linear_coef\n            ],\n            coefs=coefs,\n        )\n\n    @property\n    def is_linear(self):\n        return True\n\n    def __add__(self, other):\n        if isinstance(other, LinearOperator):\n            return LinearOperator(\n                self.operator_generators + other.operator_generators,\n                self.coefs + other.coefs,\n            )\n        elif isinstance(other, OperatorLike):\n            return Operator(\n                self.operator_generators + other.operator_generators,\n                self.coefs + other.coefs,\n            )\n        elif isinstance(other, Tensor):\n            return Operator(\n                self.operator_generators\n                + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n                self.coefs + [1],\n            )\n        else:\n            return NotImplemented\n\n    def __mul__(self, other):\n        if isinstance(other, OperatorLike):\n            return NotImplemented\n        else:\n            return LinearOperator(\n                self.operator_generators, [coef * other for coef in self.coefs]\n            )\n\n    def __neg__(self):\n        return LinearOperator(\n            self.operator_generators, [-1 * coef for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.solve","title":"solve","text":"<pre><code>solve(\n    b: Optional[Tensor] = None,\n    b_fft: Optional[Tensor] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]\n]\n</code></pre> <p>Solve the linear operator equation \\(Ax = b\\), where \\(A\\) is the linear operator and \\(b\\) is the right-hand side.</p> <p>Parameters:</p> Name Type Description Default <code>b</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in spatial domain. If None, b_fft should be provided.</p> <code>None</code> <code>b_fft</code> <code>Optional[Tensor]</code> <p>Right-hand side tensor in Fourier domain. If None, b should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. If None, the mesh registered in the operator will be used.</p> <code>None</code> <code>n_channel</code> <code>Optional[int]</code> <p>Number of channels of \\(x\\). If None, the number of channels registered in the operator will be used.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def solve(\n    self,\n    b: Optional[torch.Tensor] = None,\n    b_fft: Optional[torch.Tensor] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    n_channel: Optional[int] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B C H ...\"]]:\n\n    r\"\"\"\n    Solve the linear operator equation $Ax = b$, where $A$ is the linear operator and $b$ is the right-hand side.\n\n    Args:\n        b (Optional[torch.Tensor]): Right-hand side tensor in spatial domain. If None, b_fft should be provided.\n        b_fft (Optional[torch.Tensor]): Right-hand side tensor in Fourier domain. If None, b should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. If None, the mesh registered in the operator will be used.\n        n_channel (Optional[int]): Number of channels of $x$. If None, the number of channels registered in the operator will be used.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Solution tensor in spatial or Fourier domain.\n    \"\"\"\n    if not (mesh is not None and n_channel is not None):\n        assert (\n            self._state_dict[\"f_mesh\"] is not None\n        ), \"Mesh and n_channel should be given when calling solve\"\n    if not (mesh is None and n_channel is None):\n        mesh = self._state_dict[\"f_mesh\"] if mesh is None else mesh\n        n_channel = (\n            self._state_dict[\"n_channel\"] if n_channel is None else n_channel\n        )\n        self.register_mesh(mesh, n_channel)\n    if self._state_dict[\"invert_linear_coef\"] is None:\n        self._state_dict[\"invert_linear_coef\"] = torch.where(\n            self._state_dict[\"linear_coef\"] == 0,\n            1.0,\n            1 / self._state_dict[\"linear_coef\"],\n        )\n    if b_fft is None:\n        b_fft = self._state_dict[\"f_mesh\"].fft(b)\n    value_fft = b_fft * self._state_dict[\"invert_linear_coef\"]\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__init__","title":"__init__","text":"<pre><code>__init__(\n    linear_coef: ValueList[\n        Union[LinearCoef, GeneratorLike]\n    ] = None,\n    coefs: Optional[List] = None,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __init__(\n    self,\n    linear_coef: ValueList[Union[LinearCoef, GeneratorLike]] = None,\n    coefs: Optional[List] = None,\n) -&gt; None:\n    if not isinstance(linear_coef, list):\n        linear_coef = [linear_coef]\n    super().__init__(\n        operator_generators=[\n            (\n                linear_coef_i\n                if not isinstance(linear_coef_i, LinearCoef)\n                else lambda f_mesh, n_channel: linear_coef_i\n            )\n            for linear_coef_i in linear_coef\n        ],\n        coefs=coefs,\n    )\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, LinearOperator):\n        return LinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return LinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.LinearOperator.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return LinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator","title":"torchfsm.operator.NonlinearOperator","text":"<p>               Bases: <code>OperatorLike</code>, <code>_DeAliasMixin</code></p> <p>Operators that contain only nonlinear operations.</p> <p>Parameters:</p> Name Type Description Default <code>nonlinear_func</code> <code>ValueList[Union[NonlinearFunc, GeneratorLike]]</code> <p>List of nonlinear function generators. Default is None. Each generator should be a callable that takes a Fourier mesh and number of channels as input and returns a nonlinear function.</p> <code>None</code> <code>coefs</code> <code>Optional[List]</code> <p>List of coefficients for each nonlinear function generator. Default is None. If None, all coefficients are set to 1. The length of the list should match the number of nonlinear function generators.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>class NonlinearOperator(OperatorLike, _DeAliasMixin):\n\n    r\"\"\"\n    Operators that contain only nonlinear operations.\n\n    Args:\n        nonlinear_func (ValueList[Union[NonlinearFunc, GeneratorLike]]): List of nonlinear function generators. Default is None.\n            Each generator should be a callable that takes a Fourier mesh and number of channels as input and returns a nonlinear function.\n        coefs (Optional[List]): List of coefficients for each nonlinear function generator. Default is None.\n            If None, all coefficients are set to 1.\n            The length of the list should match the number of nonlinear function generators.\n    \"\"\"\n\n    def __init__(\n        self,\n        nonlinear_func: ValueList[Union[NonlinearFunc, GeneratorLike]] = None,\n        coefs: Optional[List] = None,\n    ) -&gt; None:\n        if not isinstance(nonlinear_func, list):\n            nonlinear_func = [nonlinear_func]\n        super().__init__(\n            operator_generators=[\n                (\n                    nonlinear_func_i\n                    if not isinstance(nonlinear_func_i, NonlinearFunc)\n                    else lambda f_mesh, n_channel: nonlinear_func_i\n                )\n                for nonlinear_func_i in nonlinear_func\n            ],\n            coefs=coefs,\n        )\n\n    @property\n    def is_linear(self):\n        return False\n\n    def __add__(self, other):\n        if isinstance(other, NonlinearOperator):\n            return NonlinearOperator(\n                self.operator_generators + other.operator_generators,\n                self.coefs + other.coefs,\n            )\n        elif isinstance(other, OperatorLike):\n            return Operator(\n                self.operator_generators + other.operator_generators,\n                self.coefs + other.coefs,\n            )\n        elif isinstance(other, Tensor):\n            return Operator(\n                self.operator_generators\n                + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n                self.coefs + [1],\n            )\n        else:\n            return NotImplemented\n\n    def __mul__(self, other):\n        if isinstance(other, OperatorLike):\n            return NotImplemented\n        else:\n            return NonlinearOperator(\n                self.operator_generators, [coef * other for coef in self.coefs]\n            )\n\n    def __neg__(self):\n        return NonlinearOperator(\n            self.operator_generators, [-1 * coef for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.operator_generators","title":"operator_generators  <code>instance-attribute</code>","text":"<pre><code>operator_generators = default(operator_generators, [])\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.coefs","title":"coefs  <code>instance-attribute</code>","text":"<pre><code>coefs = default(coefs, [1] * len(operator_generators))\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.is_linear","title":"is_linear  <code>property</code>","text":"<pre><code>is_linear\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.set_de_aliasing_rate","title":"set_de_aliasing_rate","text":"<pre><code>set_de_aliasing_rate(de_aliasing_rate: float)\n</code></pre> <p>Set the de-aliasing rate for the nonlinear operator. Args:     de_aliasing_rate (float): De-aliasing rate. Default is \u2154.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_de_aliasing_rate(self, de_aliasing_rate: float):\n    r\"\"\"\n    Set the de-aliasing rate for the nonlinear operator.\n    Args:\n        de_aliasing_rate (float): De-aliasing rate. Default is 2/3.\n    \"\"\"\n\n    self._de_aliasing_rate = de_aliasing_rate\n    self._state_dict = None\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__radd__","title":"__radd__","text":"<pre><code>__radd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __radd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__iadd__","title":"__iadd__","text":"<pre><code>__iadd__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __iadd__(self, other):\n    return self + other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__sub__","title":"__sub__","text":"<pre><code>__sub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __sub__(self, other):\n    try:\n        return self + (-1 * other)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__rsub__","title":"__rsub__","text":"<pre><code>__rsub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rsub__(self, other):\n    try:\n        return other + (-1 * self)\n    except Exception:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__isub__","title":"__isub__","text":"<pre><code>__isub__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __isub__(self, other):\n    return self - other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__rmul__","title":"__rmul__","text":"<pre><code>__rmul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __rmul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__imul__","title":"__imul__","text":"<pre><code>__imul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __imul__(self, other):\n    return self * other\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__truediv__","title":"__truediv__","text":"<pre><code>__truediv__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __truediv__(self, other):\n    try:\n        return self * (1 / other)\n    except:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.register_mesh","title":"register_mesh","text":"<pre><code>register_mesh(\n    mesh: Union[\n        Sequence[tuple[float, float, int]],\n        MeshGrid,\n        FourierMesh,\n    ],\n    n_channel: int,\n    device=None,\n    dtype=None,\n)\n</code></pre> <p>Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.</p> <p>Parameters:</p> Name Type Description Default <code>mesh</code> <code>Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]</code> <p>Mesh information or mesh object.</p> required <code>n_channel</code> <code>int</code> <p>Number of channels of the input tensor.</p> required <code>device</code> <code>Optional[device]</code> <p>Device to which the mesh should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the mesh. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def register_mesh(\n    self,\n    mesh: Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh],\n    n_channel: int,\n    device=None,\n    dtype=None,\n):\n    r\"\"\"\n    Register the mesh and number of channels for the operator. Once a mesh is registered, mesh information is not required for integration and operator call.\n\n    Args:\n        mesh (Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]): Mesh information or mesh object.\n        n_channel (int): Number of channels of the input tensor.\n        device (Optional[torch.device]): Device to which the mesh should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the mesh. Default is None.\n    \"\"\"\n    if isinstance(mesh, FourierMesh):\n        f_mesh = mesh\n        if device is not None or dtype is not None:\n            f_mesh.to(device=device, dtype=dtype)\n    else:\n        f_mesh = FourierMesh(mesh, device=device, dtype=dtype)\n    for key in self._state_dict:\n        self._state_dict[key] = None\n    self._state_dict.update(\n        {\n            \"f_mesh\": f_mesh,\n            \"n_channel\": n_channel,\n        }\n    )\n    linear_coefs = []\n    nonlinear_funcs = []\n    for coef, generator in zip(self.coefs, self.operator_generators):\n        op = generator(f_mesh, n_channel)\n        if isinstance(op, LinearCoef):\n            linear_coefs.append((coef, op))\n        elif isinstance(op, NonlinearFunc):\n            nonlinear_funcs.append((coef, op))\n        else:\n            raise ValueError(f\"Operator {op} is not supported\")\n    self._nonlinear_funcs = nonlinear_funcs\n    self._build_linear_coefs(linear_coefs)\n    self._build_nonlinear_funcs(self._nonlinear_funcs)\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.regisiter_additional_check","title":"regisiter_additional_check","text":"<pre><code>regisiter_additional_check(\n    func: Callable[[int, int], bool],\n)\n</code></pre> <p>Register an additional check function for the value and mesh compatibility.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[int, int], bool]</code> <p>Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def regisiter_additional_check(self, func: Callable[[int, int], bool]):\n    r\"\"\"\n    Register an additional check function for the value and mesh compatibility.\n\n    Args:\n        func (Callable[[int, int], bool]): Function that takes the dimension of the value and mesh as input and returns a boolean indicating whether they are compatible.\n    \"\"\"\n    self._value_mesh_check_func = func\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.add_generator","title":"add_generator","text":"<pre><code>add_generator(generator: GeneratorLike, coef=1)\n</code></pre> <p>Add a generator to the operator.</p> <p>Parameters:</p> Name Type Description Default <code>generator</code> <code>GeneratorLike</code> <p>Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.</p> required <code>coef</code> <code>float</code> <p>Coefficient for the generator. Default is 1.</p> <code>1</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def add_generator(self, generator: GeneratorLike, coef=1):\n    r\"\"\"\n    Add a generator to the operator.\n\n    Args:\n        generator (GeneratorLike): Generator to be added. It should be a callable that takes a Fourier mesh and number of channels as input and returns a linear coefficient or nonlinear function.\n        coef (float): Coefficient for the generator. Default is 1.\n    \"\"\"\n    self.operator_generators.append(generator)\n    self.coefs.append(coef)\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.set_integrator","title":"set_integrator","text":"<pre><code>set_integrator(\n    integrator: Union[\n        Literal[\"auto\"], ETDRKIntegrator, RKIntegrator\n    ],\n    **integrator_config\n)\n</code></pre> <p>Set the integrator for the operator. The integrator is used for time integration of the operator.</p> <p>Parameters:</p> Name Type Description Default <code>integrator</code> <code>Union[Literal['auto'], ETDRKIntegrator, RKIntegrator]</code> <p>Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type. If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.</p> required <code>**integrator_config</code> <p>Additional configuration for the integrator.</p> <code>{}</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def set_integrator(\n    self,\n    integrator: Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator],\n    **integrator_config,\n):\n    r\"\"\"\n    Set the integrator for the operator. The integrator is used for time integration of the operator.\n\n    Args:\n        integrator (Union[Literal[\"auto\"], ETDRKIntegrator, RKIntegrator]): Integrator to be used. If \"auto\", the integrator will be chosen automatically based on the operator type.\n            If \"auto\", the integrator will be set as ETDRKIntegrator.ETDRK0 for linear operators and ETDRKIntegrator.ETDRK4 for nonlinear operators.\n        **integrator_config: Additional configuration for the integrator.\n    \"\"\"\n\n    if isinstance(integrator, str):\n        assert (\n            integrator == \"auto\"\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    else:\n        assert isinstance(integrator, ETDRKIntegrator) or isinstance(\n            integrator, RKIntegrator\n        ), \"The integrator should be 'auto' or an instance of ETDRKIntegrator or RKIntegrator\"\n    self._integrator = integrator\n    self._integrator_config = integrator_config\n    self._state_dict[\"integrator\"] = None\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.integrate","title":"integrate","text":"<pre><code>integrate(\n    u_0: Optional[Tensor] = None,\n    u_0_fft: Optional[Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"],\n    SpatialTensor[\"B T C H ...\"],\n    FourierTensor[\"B C H ...\"],\n    FourierTensor[\"B T C H ...\"],\n]\n</code></pre> <p>Integrate the operator using the provided initial condition and time step.  </p> <p>Parameters:</p> Name Type Description Default <code>u_0</code> <code>Optional[Tensor]</code> <p>Initial condition in spatial domain. Default is None.</p> <code>None</code> <code>u_0_fft</code> <code>Optional[Tensor]</code> <p>Initial condition in Fourier domain. Default is None. At least one of u_0 or u_0_fft should be provided.</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step for the integrator. Default is 1.</p> <code>1</code> <code>step</code> <code>int</code> <p>Number of time steps to integrate. Default is 1.</p> <code>1</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before integration.</p> <code>None</code> <code>progressive</code> <code>bool</code> <p>If True, show a progress bar during integration. Default is False.</p> <code>False</code> <code>trajectory_recorder</code> <code>Optional[_TrajRecorder]</code> <p>Trajectory recorder for recording the trajectory during integration. Default is None. If None, no trajectory will be recorded. The function will only return the final frame.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], SpatialTensor['B T C H ...'], FourierTensor['B C H ...'], FourierTensor['B T C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain. If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...). If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def integrate(\n    self,\n    u_0: Optional[torch.Tensor] = None,\n    u_0_fft: Optional[torch.Tensor] = None,\n    dt: float = 1,\n    step: int = 1,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    progressive: bool = False,\n    trajectory_recorder: Optional[_TrajRecorder] = None,\n    return_in_fourier: bool = False,\n\n) -&gt; Union[\n        SpatialTensor[\"B C H ...\"],\n        SpatialTensor[\"B T C H ...\"],\n        FourierTensor[\"B C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n    ]:\n    r\"\"\"\n    Integrate the operator using the provided initial condition and time step.  \n\n    Args:\n        u_0 (Optional[torch.Tensor]): Initial condition in spatial domain. Default is None.\n        u_0_fft (Optional[torch.Tensor]): Initial condition in Fourier domain. Default is None.\n            At least one of u_0 or u_0_fft should be provided.\n        dt (float): Time step for the integrator. Default is 1.\n        step (int): Number of time steps to integrate. Default is 1.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before integration.\n        progressive (bool): If True, show a progress bar during integration. Default is False.\n        trajectory_recorder (Optional[_TrajRecorder]): Trajectory recorder for recording the trajectory during integration. Default is None.\n            If None, no trajectory will be recorded. The function will only return the final frame.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], SpatialTensor[\"B T C H ...\"], FourierTensor[\"B C H ...\"], FourierTensor[\"B T C H ...\"]]: Integrated result in spatial or Fourier domain.\n            If trajectory_recorder is provided, the result will be a trajectory tensor of shape (B, T, C, H, ...). Otherwise, the result will be a tensor of shape (B, C, H, ...).\n            If return_in_fourier is True, the result will be in Fourier domain. Otherwise, it will be in spatial domain.\n\n    \"\"\"\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u=u_0, u_fft=u_0_fft, mesh=mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u_0, u_fft=u_0_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"integrator\"] is None:\n        self._build_integrator(dt)\n    elif self._is_etdrk_integrator:\n        if self._state_dict[\"integrator\"].dt != dt:\n            self._build_integrator(dt)\n    f_mesh = self._state_dict[\"f_mesh\"]\n    if u_0_fft is None:\n        u_0_fft = f_mesh.fft(u_0)\n    p_bar = tqdm(range(step), desc=\"Integrating\", disable=not progressive)\n    for i in p_bar:\n        if trajectory_recorder is not None:\n            trajectory_recorder.record(i, u_0_fft)\n        u_0_fft = self._state_dict[\"integrator\"].forward(u_0_fft, dt)\n    if trajectory_recorder is not None:\n        trajectory_recorder.record(i + 1, u_0_fft)\n        trajectory_recorder.return_in_fourier = return_in_fourier\n        return trajectory_recorder.trajectory\n    else:\n        if return_in_fourier:\n            return u_0_fft\n        else:\n            return f_mesh.ifft(u_0_fft).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__call__","title":"__call__","text":"<pre><code>__call__(\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[\n            Sequence[tuple[float, float, int]],\n            MeshGrid,\n            FourierMesh,\n        ]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[\n    SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]\n]\n</code></pre> <p>Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>Optional[SpatialTensor]</code> <p>Input tensor in spatial domain. Default is None.</p> <code>None</code> <code>u_fft</code> <code>Optional[FourierTensor]</code> <p>Input tensor in Fourier domain. Default is None. At least one of u or u_fft should be provided.</p> <code>None</code> <code>mesh</code> <code>Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]</code> <p>Mesh information or mesh object. Default is None. If None, the mesh registered in the operator will be used. You can use <code>register_mesh</code> to register a mesh before calling the operator.</p> <code>None</code> <code>return_in_fourier</code> <code>bool</code> <p>If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[SpatialTensor['B C H ...'], FourierTensor['B C H ...']]</code> <p>Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    u_fft: Optional[FourierTensor[\"B C H ...\"]] = None,\n    mesh: Optional[\n        Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]\n    ] = None,\n    return_in_fourier=False,\n) -&gt; Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]:\n    r\"\"\"\n    Call the operator with the provided input tensor. The operator will apply the linear coefficient and nonlinear function to the input tensor.\n\n    Args:\n        u (Optional[SpatialTensor]): Input tensor in spatial domain. Default is None.\n        u_fft (Optional[FourierTensor]): Input tensor in Fourier domain. Default is None.\n            At least one of u or u_fft should be provided.\n        mesh (Optional[Union[Sequence[tuple[float, float, int]], MeshGrid, FourierMesh]]): Mesh information or mesh object. Default is None.\n            If None, the mesh registered in the operator will be used. You can use `register_mesh` to register a mesh before calling the operator.\n        return_in_fourier (bool): If True, return the result in Fourier domain. If False, return the result in spatial domain. Default is False.\n\n    Returns:\n        Union[SpatialTensor[\"B C H ...\"], FourierTensor[\"B C H ...\"]]: Result of the operator in spatial or Fourier domain.\n    \"\"\"    \n\n    if self._state_dict[\"f_mesh\"] is None or mesh is not None:\n        mesh, n_channel = self._pre_check(u, u_fft, mesh)\n        self.register_mesh(mesh, n_channel)\n    else:\n        self._pre_check(u=u, u_fft=u_fft, mesh=self._state_dict[\"f_mesh\"])\n    if self._state_dict[\"operator\"] is None:\n        self._build_operator()\n    if u_fft is None:\n        u_fft = self._state_dict[\"f_mesh\"].fft(u)\n    value_fft = self._state_dict[\"operator\"](u_fft)\n    if return_in_fourier:\n        return value_fft\n    else:\n        return self._state_dict[\"f_mesh\"].ifft(value_fft).real\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.to","title":"to","text":"<pre><code>to(device=None, dtype=None)\n</code></pre> <p>Move the operator to the specified device and change the data type.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[device]</code> <p>Device to which the operator should be moved. Default is None.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>Data type of the operator. Default is None.</p> <code>None</code> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def to(self, device=None, dtype=None):\n    r\"\"\"\n    Move the operator to the specified device and change the data type.\n\n    Args:\n        device (Optional[torch.device]): Device to which the operator should be moved. Default is None.\n        dtype (Optional[torch.dtype]): Data type of the operator. Default is None.\n    \"\"\"\n    if self._state_dict is not None:\n        self._state_dict[\"f_mesh\"].to(device=device, dtype=dtype)\n        self.register_mesh(self._state_dict[\"f_mesh\"], self._state_dict[\"n_channel\"])\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__init__","title":"__init__","text":"<pre><code>__init__(\n    nonlinear_func: ValueList[\n        Union[NonlinearFunc, GeneratorLike]\n    ] = None,\n    coefs: Optional[List] = None,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __init__(\n    self,\n    nonlinear_func: ValueList[Union[NonlinearFunc, GeneratorLike]] = None,\n    coefs: Optional[List] = None,\n) -&gt; None:\n    if not isinstance(nonlinear_func, list):\n        nonlinear_func = [nonlinear_func]\n    super().__init__(\n        operator_generators=[\n            (\n                nonlinear_func_i\n                if not isinstance(nonlinear_func_i, NonlinearFunc)\n                else lambda f_mesh, n_channel: nonlinear_func_i\n            )\n            for nonlinear_func_i in nonlinear_func\n        ],\n        coefs=coefs,\n    )\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__add__","title":"__add__","text":"<pre><code>__add__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __add__(self, other):\n    if isinstance(other, NonlinearOperator):\n        return NonlinearOperator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, OperatorLike):\n        return Operator(\n            self.operator_generators + other.operator_generators,\n            self.coefs + other.coefs,\n        )\n    elif isinstance(other, Tensor):\n        return Operator(\n            self.operator_generators\n            + [lambda f_mesh, n_channel: _ExplicitSourceCore(other)],\n            self.coefs + [1],\n        )\n    else:\n        return NotImplemented\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__mul__","title":"__mul__","text":"<pre><code>__mul__(other)\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __mul__(self, other):\n    if isinstance(other, OperatorLike):\n        return NotImplemented\n    else:\n        return NonlinearOperator(\n            self.operator_generators, [coef * other for coef in self.coefs]\n        )\n</code></pre>"},{"location":"apis/operator_base/#torchfsm.operator.NonlinearOperator.__neg__","title":"__neg__","text":"<pre><code>__neg__()\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __neg__(self):\n    return NonlinearOperator(\n        self.operator_generators, [-1 * coef for coef in self.coefs]\n    )\n</code></pre>"},{"location":"apis/operator_core/","title":"Cores","text":""},{"location":"apis/operator_core/#torchfsm.operator.generic._biharmonic._BiharmonicCore","title":"torchfsm.operator.generic._biharmonic._BiharmonicCore","text":"<p>               Bases: <code>LinearCoef</code></p> <p>Implementation of the Biharmonic operator.</p> Source code in <code>torchfsm/operator/generic/_biharmonic.py</code> <pre><code>class _BiharmonicCore(LinearCoef):\n    r\"\"\"\n    Implementation of the Biharmonic operator.\n    \"\"\"\n\n    def __call__(\n        self, f_mesh: FourierMesh, n_channel: int\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        return torch.cat([f_mesh.laplacian() * f_mesh.laplacian()] * n_channel, dim=1)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._biharmonic._BiharmonicCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/generic/_biharmonic.py</code> <pre><code>def __call__(\n    self, f_mesh: FourierMesh, n_channel: int\n) -&gt; FourierTensor[\"B C H ...\"]:\n    return torch.cat([f_mesh.laplacian() * f_mesh.laplacian()] * n_channel, dim=1)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._biharmonic._BiharmonicCore.nonlinear_like","title":"nonlinear_like","text":"<pre><code>nonlinear_like(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> <p>Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FourierTensor</code> <code>FourierTensor['B C H ...']</code> <p>Nonlinear-like tensor.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def nonlinear_like(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    r\"\"\"\n    Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        FourierTensor: Nonlinear-like tensor.\n    \"\"\"\n    return self(f_mesh, u_fft.shape[1]) * u_fft\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._conservative_convection._ConservativeConvectionCore","title":"torchfsm.operator.generic._conservative_convection._ConservativeConvectionCore","text":"<p>               Bases: <code>NonlinearFunc</code></p> <p>Implementation of the Conservative Convection operator.</p> Source code in <code>torchfsm/operator/generic/_conservative_convection.py</code> <pre><code>class _ConservativeConvectionCore(NonlinearFunc):\n\n    r\"\"\"\n    Implementation of the Conservative Convection operator.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    def __call__(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        if u is None:\n            u = f_mesh.ifft(u_fft).real\n        uu = u.unsqueeze(2) * u.unsqueeze(1)\n        uu_fft = f_mesh.fft(uu)\n        return (f_mesh.nabla_vector(1).unsqueeze(2) * uu_fft).sum(1)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._conservative_convection._ConservativeConvectionCore.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>torchfsm/operator/generic/_conservative_convection.py</code> <pre><code>def __init__(self):\n    super().__init__()\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._conservative_convection._ConservativeConvectionCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/generic/_conservative_convection.py</code> <pre><code>def __call__(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    if u is None:\n        u = f_mesh.ifft(u_fft).real\n    uu = u.unsqueeze(2) * u.unsqueeze(1)\n    uu_fft = f_mesh.fft(uu)\n    return (f_mesh.nabla_vector(1).unsqueeze(2) * uu_fft).sum(1)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._conservative_convection._ConservativeConvectionCore.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Return the result of the nonlinear function in spatial domain.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SpatialTensor</code> <code>SpatialTensor['B C H ...']</code> <p>Result of the nonlinear function in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Return the result of the nonlinear function in spatial domain.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        SpatialTensor: Result of the nonlinear function in spatial domain.\n    \"\"\"\n\n    return f_mesh.ifft(self(u_fft, f_mesh, u)).real\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._convection._ConvectionCore","title":"torchfsm.operator.generic._convection._ConvectionCore","text":"<p>               Bases: <code>NonlinearFunc</code></p> <p>Implementation of the Convection operator.</p> Source code in <code>torchfsm/operator/generic/_convection.py</code> <pre><code>class _ConvectionCore(NonlinearFunc):\n\n    r\"\"\"\n    Implementation of the Convection operator.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n    def __call__(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        return f_mesh.fft(self.spatial_value(u_fft, f_mesh, u))\n\n    def spatial_value(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: FourierTensor[\"B C H ...\"] | None,\n    ) -&gt; SpatialTensor[\"B C H ...\"]:\n        r\"\"\"\n        Return the result of the nonlinear function in spatial domain.\n\n        Args:\n            u_fft (FourierTensor): Fourier-transformed input tensor.\n            f_mesh (FourierMesh): Fourier mesh object.\n            u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n        Returns:\n            SpatialTensor: Result of the nonlinear function in spatial domain.\n        \"\"\"\n        if u is None:\n            u = f_mesh.ifft(u_fft).real\n        nabla_u = f_mesh.nabla_vector(1).unsqueeze(2) * u_fft.unsqueeze(1)\n        return (u.unsqueeze(2) * f_mesh.ifft(nabla_u).real).sum(1)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._convection._ConvectionCore.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>torchfsm/operator/generic/_convection.py</code> <pre><code>def __init__(self):\n    super().__init__()\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._convection._ConvectionCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/generic/_convection.py</code> <pre><code>def __call__(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    return f_mesh.fft(self.spatial_value(u_fft, f_mesh, u))\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._convection._ConvectionCore.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: FourierTensor[\"B C H ...\"] | None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Return the result of the nonlinear function in spatial domain.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> required <p>Returns:</p> Name Type Description <code>SpatialTensor</code> <code>SpatialTensor['B C H ...']</code> <p>Result of the nonlinear function in spatial domain.</p> Source code in <code>torchfsm/operator/generic/_convection.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: FourierTensor[\"B C H ...\"] | None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Return the result of the nonlinear function in spatial domain.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        SpatialTensor: Result of the nonlinear function in spatial domain.\n    \"\"\"\n    if u is None:\n        u = f_mesh.ifft(u_fft).real\n    nabla_u = f_mesh.nabla_vector(1).unsqueeze(2) * u_fft.unsqueeze(1)\n    return (u.unsqueeze(2) * f_mesh.ifft(nabla_u).real).sum(1)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._curl._Curl2DCore","title":"torchfsm.operator.generic._curl._Curl2DCore","text":"<p>               Bases: <code>NonlinearFunc</code></p> <p>Implementation of the Curl operator for 2D vector fields.</p> Source code in <code>torchfsm/operator/generic/_curl.py</code> <pre><code>class _Curl2DCore(NonlinearFunc):\n\n    r\"\"\"\n    Implementation of the Curl operator for 2D vector fields.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(False)\n\n    def __call__(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        return (\n            f_mesh.grad(0, 1) * u_fft[:, 1:2, ...]\n            - f_mesh.grad(1, 1) * u_fft[:, 0:1, ...]\n        )\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._curl._Curl2DCore.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>torchfsm/operator/generic/_curl.py</code> <pre><code>def __init__(self):\n    super().__init__(False)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._curl._Curl2DCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/generic/_curl.py</code> <pre><code>def __call__(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    return (\n        f_mesh.grad(0, 1) * u_fft[:, 1:2, ...]\n        - f_mesh.grad(1, 1) * u_fft[:, 0:1, ...]\n    )\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._curl._Curl2DCore.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Return the result of the nonlinear function in spatial domain.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SpatialTensor</code> <code>SpatialTensor['B C H ...']</code> <p>Result of the nonlinear function in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Return the result of the nonlinear function in spatial domain.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        SpatialTensor: Result of the nonlinear function in spatial domain.\n    \"\"\"\n\n    return f_mesh.ifft(self(u_fft, f_mesh, u)).real\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._curl._Curl3DCore","title":"torchfsm.operator.generic._curl._Curl3DCore","text":"<p>               Bases: <code>NonlinearFunc</code></p> <p>Implementation of the Curl operator for 3D vector fields.</p> Source code in <code>torchfsm/operator/generic/_curl.py</code> <pre><code>class _Curl3DCore(NonlinearFunc):\n\n    r\"\"\"\n    Implementation of the Curl operator for 3D vector fields.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(False)\n\n    def __call__(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        return torch.cat(\n            [\n                f_mesh.grad(1, 1) * u_fft[:, 2:3, ...]\n                - f_mesh.grad(2, 1) * u_fft[:, 1:2, ...],\n                f_mesh.grad(2, 1) * u_fft[:, 0:1, ...]\n                - f_mesh.grad(0, 1) * u_fft[:, 2:3, ...],\n                f_mesh.grad(0, 1) * u_fft[:, 1:2, ...]\n                - f_mesh.grad(1, 1) * u_fft[:, 0:1, ...],\n            ],\n            dim=1,\n        )\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._curl._Curl3DCore.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>torchfsm/operator/generic/_curl.py</code> <pre><code>def __init__(self):\n    super().__init__(False)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._curl._Curl3DCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/generic/_curl.py</code> <pre><code>def __call__(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    return torch.cat(\n        [\n            f_mesh.grad(1, 1) * u_fft[:, 2:3, ...]\n            - f_mesh.grad(2, 1) * u_fft[:, 1:2, ...],\n            f_mesh.grad(2, 1) * u_fft[:, 0:1, ...]\n            - f_mesh.grad(0, 1) * u_fft[:, 2:3, ...],\n            f_mesh.grad(0, 1) * u_fft[:, 1:2, ...]\n            - f_mesh.grad(1, 1) * u_fft[:, 0:1, ...],\n        ],\n        dim=1,\n    )\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._curl._Curl3DCore.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Return the result of the nonlinear function in spatial domain.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SpatialTensor</code> <code>SpatialTensor['B C H ...']</code> <p>Result of the nonlinear function in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Return the result of the nonlinear function in spatial domain.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        SpatialTensor: Result of the nonlinear function in spatial domain.\n    \"\"\"\n\n    return f_mesh.ifft(self(u_fft, f_mesh, u)).real\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._div._DivCore","title":"torchfsm.operator.generic._div._DivCore","text":"<p>               Bases: <code>NonlinearFunc</code></p> <p>Implementation of the Divergence operator.</p> Source code in <code>torchfsm/operator/generic/_div.py</code> <pre><code>class _DivCore(NonlinearFunc):\n    r\"\"\"\n    Implementation of the Divergence operator.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(False)\n\n    def __call__(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        return torch.sum(f_mesh.nabla_vector(1) * u_fft, dim=1, keepdim=True)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._div._DivCore.__init__","title":"__init__","text":"<pre><code>__init__()\n</code></pre> Source code in <code>torchfsm/operator/generic/_div.py</code> <pre><code>def __init__(self):\n    super().__init__(False)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._div._DivCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/generic/_div.py</code> <pre><code>def __call__(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    return torch.sum(f_mesh.nabla_vector(1) * u_fft, dim=1, keepdim=True)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._div._DivCore.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Return the result of the nonlinear function in spatial domain.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SpatialTensor</code> <code>SpatialTensor['B C H ...']</code> <p>Result of the nonlinear function in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Return the result of the nonlinear function in spatial domain.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        SpatialTensor: Result of the nonlinear function in spatial domain.\n    \"\"\"\n\n    return f_mesh.ifft(self(u_fft, f_mesh, u)).real\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._grad._GradCore","title":"torchfsm.operator.generic._grad._GradCore","text":"<p>               Bases: <code>LinearCoef</code></p> <p>Implementation of the Grad operator.</p> Source code in <code>torchfsm/operator/generic/_grad.py</code> <pre><code>class _GradCore(LinearCoef):\n\n    r\"\"\"\n    Implementation of the Grad operator.\n    \"\"\"\n\n    def __call__(\n        self, f_mesh: FourierMesh, n_channel: int\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        return f_mesh.nabla_vector(1)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._grad._GradCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/generic/_grad.py</code> <pre><code>def __call__(\n    self, f_mesh: FourierMesh, n_channel: int\n) -&gt; FourierTensor[\"B C H ...\"]:\n    return f_mesh.nabla_vector(1)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._grad._GradCore.nonlinear_like","title":"nonlinear_like","text":"<pre><code>nonlinear_like(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> <p>Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FourierTensor</code> <code>FourierTensor['B C H ...']</code> <p>Nonlinear-like tensor.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def nonlinear_like(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    r\"\"\"\n    Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        FourierTensor: Nonlinear-like tensor.\n    \"\"\"\n    return self(f_mesh, u_fft.shape[1]) * u_fft\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator._base._ExplicitSourceCore","title":"torchfsm.operator._base._ExplicitSourceCore","text":"<p>               Bases: <code>NonlinearFunc</code></p> <p>Implementation of the explicit source term for the operator.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>SpatialTensor['B C H ...']</code> <p>Source term in spatial domain. This is a tensor that represents the source term in the spatial domain.</p> required Source code in <code>torchfsm/operator/_base.py</code> <pre><code>class _ExplicitSourceCore(NonlinearFunc):\n\n    r\"\"\"\n    Implementation of the explicit source term for the operator.\n\n    Args:\n        source (SpatialTensor[\"B C H ...\"]): Source term in spatial domain. This is a tensor that represents the source term in the spatial domain.\n    \"\"\"\n\n    def __init__(self, source: SpatialTensor[\"B C H ...\"]) -&gt; None:\n        super().__init__(dealiasing_swtich=False)\n        fft_dim = [i + 2 for i in range(source.dim() - 2)]\n        self.source = torch.fft.fftn(source, dim=fft_dim)\n\n    def __call__(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        if self.source.device != f_mesh.device:\n            self.source = self.source.to(f_mesh.device)\n        return self.source\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator._base._ExplicitSourceCore.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source = fftn(source, dim=fft_dim)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator._base._ExplicitSourceCore.__init__","title":"__init__","text":"<pre><code>__init__(source: SpatialTensor['B C H ...']) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __init__(self, source: SpatialTensor[\"B C H ...\"]) -&gt; None:\n    super().__init__(dealiasing_swtich=False)\n    fft_dim = [i + 2 for i in range(source.dim() - 2)]\n    self.source = torch.fft.fftn(source, dim=fft_dim)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator._base._ExplicitSourceCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def __call__(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    if self.source.device != f_mesh.device:\n        self.source = self.source.to(f_mesh.device)\n    return self.source\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator._base._ExplicitSourceCore.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Return the result of the nonlinear function in spatial domain.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SpatialTensor</code> <code>SpatialTensor['B C H ...']</code> <p>Result of the nonlinear function in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Return the result of the nonlinear function in spatial domain.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        SpatialTensor: Result of the nonlinear function in spatial domain.\n    \"\"\"\n\n    return f_mesh.ifft(self(u_fft, f_mesh, u)).real\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._source._ImplicitUnitSourceCore","title":"torchfsm.operator.generic._source._ImplicitUnitSourceCore","text":"<p>               Bases: <code>LinearCoef</code></p> <p>Implementation of the ImplicitSource operator with unit form.</p> Source code in <code>torchfsm/operator/generic/_source.py</code> <pre><code>class _ImplicitUnitSourceCore(LinearCoef):\n    r\"\"\"\n    Implementation of the ImplicitSource operator with unit form.\n    \"\"\"\n\n    def __call__(\n        self, f_mesh: FourierMesh, n_channel: int\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        return torch.ones_like(f_mesh.bf_x)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._source._ImplicitUnitSourceCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/generic/_source.py</code> <pre><code>def __call__(\n    self, f_mesh: FourierMesh, n_channel: int\n) -&gt; FourierTensor[\"B C H ...\"]:\n    return torch.ones_like(f_mesh.bf_x)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._source._ImplicitUnitSourceCore.nonlinear_like","title":"nonlinear_like","text":"<pre><code>nonlinear_like(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> <p>Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FourierTensor</code> <code>FourierTensor['B C H ...']</code> <p>Nonlinear-like tensor.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def nonlinear_like(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    r\"\"\"\n    Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        FourierTensor: Nonlinear-like tensor.\n    \"\"\"\n    return self(f_mesh, u_fft.shape[1]) * u_fft\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._source._ImplicitFuncSourceCore","title":"torchfsm.operator.generic._source._ImplicitFuncSourceCore","text":"<p>               Bases: <code>NonlinearFunc</code></p> <p>Implementation of the ImplicitSource operator with function form.</p> Source code in <code>torchfsm/operator/generic/_source.py</code> <pre><code>class _ImplicitFuncSourceCore(NonlinearFunc):\n    r\"\"\"\n    Implementation of the ImplicitSource operator with function form.\n    \"\"\"\n\n    def __init__(\n        self,\n        source_func: Callable[[torch.Tensor], torch.Tensor],\n        non_linear: bool = True,\n    ) -&gt; None:\n        super().__init__(non_linear)\n        self.source_func = source_func\n\n    def __call__(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        if u is None:\n            u = f_mesh.ifft(u_fft).real\n        return f_mesh.fft(self.source_func(u))\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._source._ImplicitFuncSourceCore.source_func","title":"source_func  <code>instance-attribute</code>","text":"<pre><code>source_func = source_func\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._source._ImplicitFuncSourceCore.__init__","title":"__init__","text":"<pre><code>__init__(\n    source_func: Callable[[Tensor], Tensor],\n    non_linear: bool = True,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/generic/_source.py</code> <pre><code>def __init__(\n    self,\n    source_func: Callable[[torch.Tensor], torch.Tensor],\n    non_linear: bool = True,\n) -&gt; None:\n    super().__init__(non_linear)\n    self.source_func = source_func\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._source._ImplicitFuncSourceCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/generic/_source.py</code> <pre><code>def __call__(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    if u is None:\n        u = f_mesh.ifft(u_fft).real\n    return f_mesh.fft(self.source_func(u))\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._source._ImplicitFuncSourceCore.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Return the result of the nonlinear function in spatial domain.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SpatialTensor</code> <code>SpatialTensor['B C H ...']</code> <p>Result of the nonlinear function in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Return the result of the nonlinear function in spatial domain.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        SpatialTensor: Result of the nonlinear function in spatial domain.\n    \"\"\"\n\n    return f_mesh.ifft(self(u_fft, f_mesh, u)).real\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._laplacian._LaplacianCore","title":"torchfsm.operator.generic._laplacian._LaplacianCore","text":"<p>               Bases: <code>LinearCoef</code></p> <p>Implementation of the Laplacian operator.</p> Source code in <code>torchfsm/operator/generic/_laplacian.py</code> <pre><code>class _LaplacianCore(LinearCoef):\n    r\"\"\"\n    Implementation of the Laplacian operator.\n    \"\"\"\n\n    def __call__(self, \n                 f_mesh: FourierMesh, \n                 n_channel: int) -&gt; FourierTensor[\"B C H ...\"]:\n        return torch.cat([f_mesh.laplacian()]*n_channel,dim=1)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._laplacian._LaplacianCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/generic/_laplacian.py</code> <pre><code>def __call__(self, \n             f_mesh: FourierMesh, \n             n_channel: int) -&gt; FourierTensor[\"B C H ...\"]:\n    return torch.cat([f_mesh.laplacian()]*n_channel,dim=1)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._laplacian._LaplacianCore.nonlinear_like","title":"nonlinear_like","text":"<pre><code>nonlinear_like(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> <p>Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FourierTensor</code> <code>FourierTensor['B C H ...']</code> <p>Nonlinear-like tensor.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def nonlinear_like(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    r\"\"\"\n    Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        FourierTensor: Nonlinear-like tensor.\n    \"\"\"\n    return self(f_mesh, u_fft.shape[1]) * u_fft\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._spatial_derivative._SpatialDerivativeCore","title":"torchfsm.operator.generic._spatial_derivative._SpatialDerivativeCore","text":"<p>               Bases: <code>LinearCoef</code></p> <p>Implementation of the SpatialDerivative operator.</p> Source code in <code>torchfsm/operator/generic/_spatial_derivative.py</code> <pre><code>class _SpatialDerivativeCore(LinearCoef):\n    r\"\"\"\n    Implementation of the SpatialDerivative operator.\n    \"\"\"\n\n    def __init__(self, dim_index, order) -&gt; None:\n        super().__init__()\n        self.dim_index = dim_index\n        self.order = order\n\n    def __call__(\n        self, f_mesh: FourierMesh, n_channel: int\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        return f_mesh.grad(self.dim_index, self.order)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._spatial_derivative._SpatialDerivativeCore.dim_index","title":"dim_index  <code>instance-attribute</code>","text":"<pre><code>dim_index = dim_index\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._spatial_derivative._SpatialDerivativeCore.order","title":"order  <code>instance-attribute</code>","text":"<pre><code>order = order\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._spatial_derivative._SpatialDerivativeCore.__init__","title":"__init__","text":"<pre><code>__init__(dim_index, order) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/generic/_spatial_derivative.py</code> <pre><code>def __init__(self, dim_index, order) -&gt; None:\n    super().__init__()\n    self.dim_index = dim_index\n    self.order = order\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._spatial_derivative._SpatialDerivativeCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/generic/_spatial_derivative.py</code> <pre><code>def __call__(\n    self, f_mesh: FourierMesh, n_channel: int\n) -&gt; FourierTensor[\"B C H ...\"]:\n    return f_mesh.grad(self.dim_index, self.order)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.generic._spatial_derivative._SpatialDerivativeCore.nonlinear_like","title":"nonlinear_like","text":"<pre><code>nonlinear_like(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> <p>Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FourierTensor</code> <code>FourierTensor['B C H ...']</code> <p>Nonlinear-like tensor.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def nonlinear_like(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    r\"\"\"\n    Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        FourierTensor: Nonlinear-like tensor.\n    \"\"\"\n    return self(f_mesh, u_fft.shape[1]) * u_fft\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._ks_convection._KSConvectionCore","title":"torchfsm.operator.dedicated._ks_convection._KSConvectionCore","text":"<p>               Bases: <code>NonlinearFunc</code></p> <p>Implementation of the KSConvection operator.</p> Source code in <code>torchfsm/operator/dedicated/_ks_convection.py</code> <pre><code>class _KSConvectionCore(NonlinearFunc):\n\n    r\"\"\"\n    Implementation of the KSConvection operator.\n    \"\"\"\n\n    def __init__(self, remove_mean: bool) -&gt; None:\n        super().__init__()\n        self.remove_mean = remove_mean\n\n    def __call__(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        n_channel: int,\n        u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        return f_mesh.fft(self.spatial_value(u_fft, f_mesh, u))\n\n    def spatial_value(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n    ) -&gt; SpatialTensor[\"B C H ...\"]:\n        grad_u = f_mesh.ifft(f_mesh.nabla_vector(1) * u_fft).real\n        if self.remove_mean:\n            re = 0.5 * torch.sum(grad_u**2, dim=1, keepdim=True)\n            return re - re.mean()\n        else:\n            return 0.5 * torch.sum(grad_u**2, dim=1, keepdim=True)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._ks_convection._KSConvectionCore.remove_mean","title":"remove_mean  <code>instance-attribute</code>","text":"<pre><code>remove_mean = remove_mean\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._ks_convection._KSConvectionCore.__init__","title":"__init__","text":"<pre><code>__init__(remove_mean: bool) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_ks_convection.py</code> <pre><code>def __init__(self, remove_mean: bool) -&gt; None:\n    super().__init__()\n    self.remove_mean = remove_mean\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._ks_convection._KSConvectionCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    n_channel: int,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_ks_convection.py</code> <pre><code>def __call__(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    n_channel: int,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    return f_mesh.fft(self.spatial_value(u_fft, f_mesh, u))\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._ks_convection._KSConvectionCore.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_ks_convection.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    grad_u = f_mesh.ifft(f_mesh.nabla_vector(1) * u_fft).real\n    if self.remove_mean:\n        re = 0.5 * torch.sum(grad_u**2, dim=1, keepdim=True)\n        return re - re.mean()\n    else:\n        return 0.5 * torch.sum(grad_u**2, dim=1, keepdim=True)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._VorticityConvectionCore","title":"torchfsm.operator.dedicated._navier_stokes._VorticityConvectionCore","text":"<p>               Bases: <code>NonlinearFunc</code></p> <p>Implementation of the VorticityConvection operator.</p> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class _VorticityConvectionCore(NonlinearFunc):\n\n    r\"\"\"\n    Implementation of the VorticityConvection operator.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n    def __call__(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        return f_mesh.fft(self.spatial_value(u_fft, f_mesh, u))\n\n    def spatial_value(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n    ) -&gt; SpatialTensor[\"B C H ...\"]:\n        psi = -u_fft * f_mesh.invert_laplacian()\n        ux = f_mesh.ifft(f_mesh.grad(1, 1) * psi).real\n        uy = f_mesh.ifft(-f_mesh.grad(0, 1) * psi).real\n        grad_x_w = f_mesh.ifft(f_mesh.grad(0, 1) * u_fft).real\n        grad_y_w = f_mesh.ifft(f_mesh.grad(1, 1) * u_fft).real\n        return ux * grad_x_w + uy * grad_y_w\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._VorticityConvectionCore.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __init__(self) -&gt; None:\n    super().__init__()\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._VorticityConvectionCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __call__(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    return f_mesh.fft(self.spatial_value(u_fft, f_mesh, u))\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._VorticityConvectionCore.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    psi = -u_fft * f_mesh.invert_laplacian()\n    ux = f_mesh.ifft(f_mesh.grad(1, 1) * psi).real\n    uy = f_mesh.ifft(-f_mesh.grad(0, 1) * psi).real\n    grad_x_w = f_mesh.ifft(f_mesh.grad(0, 1) * u_fft).real\n    grad_y_w = f_mesh.ifft(f_mesh.grad(1, 1) * u_fft).real\n    return ux * grad_x_w + uy * grad_y_w\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Vorticity2VelocityCore","title":"torchfsm.operator.dedicated._navier_stokes._Vorticity2VelocityCore","text":"<p>               Bases: <code>LinearCoef</code></p> <p>Implementation of the Vorticity2Velocity operator.</p> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class _Vorticity2VelocityCore(LinearCoef):\n    r\"\"\"\n    Implementation of the Vorticity2Velocity operator.\n    \"\"\"\n\n    def __call__(self, f_mesh, n_channel) -&gt; FourierTensor[\"B C H ...\"]:\n        return (\n            -1\n            * f_mesh.invert_laplacian()\n            * torch.cat(\n                [\n                    f_mesh.grad(1, 1).repeat([1, 1, f_mesh.mesh_info[0][-1], 1]),\n                    -f_mesh.grad(0, 1).repeat([1, 1, 1, f_mesh.mesh_info[1][-1]]),\n                ],\n                dim=1,\n            )\n        )\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Vorticity2VelocityCore.__call__","title":"__call__","text":"<pre><code>__call__(f_mesh, n_channel) -&gt; FourierTensor['B C H ...']\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __call__(self, f_mesh, n_channel) -&gt; FourierTensor[\"B C H ...\"]:\n    return (\n        -1\n        * f_mesh.invert_laplacian()\n        * torch.cat(\n            [\n                f_mesh.grad(1, 1).repeat([1, 1, f_mesh.mesh_info[0][-1], 1]),\n                -f_mesh.grad(0, 1).repeat([1, 1, 1, f_mesh.mesh_info[1][-1]]),\n            ],\n            dim=1,\n        )\n    )\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Vorticity2VelocityCore.nonlinear_like","title":"nonlinear_like","text":"<pre><code>nonlinear_like(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> <p>Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>FourierTensor</code> <code>FourierTensor['B C H ...']</code> <p>Nonlinear-like tensor.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def nonlinear_like(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    r\"\"\"\n    Calculate the result out based on the linear coefficient. It is designed to have same pattern as the nonlinear function.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        FourierTensor: Nonlinear-like tensor.\n    \"\"\"\n    return self(f_mesh, u_fft.shape[1]) * u_fft\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Vorticity2PressureCore","title":"torchfsm.operator.dedicated._navier_stokes._Vorticity2PressureCore","text":"<p>               Bases: <code>NonlinearFunc</code></p> <p>Implementation of the Vorticity2Pressure operator.</p> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class _Vorticity2PressureCore(NonlinearFunc):\n    r\"\"\"\n    Implementation of the Vorticity2Pressure operator.\n    \"\"\"\n    def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n        # if exeternal_force is not None, the external force may need the original u_fft, thus we do not dealiasing at the beginning\n        super().__init__(dealiasing_swtich=external_force is None)\n        self.external_force = external_force\n        self._vorticity2velocity = _Vorticity2VelocityCore()\n        self._convection = _ConvectionCore()\n\n    def __call__(self, u_fft, f_mesh, u) -&gt; FourierTensor[\"B C H ...\"]:\n        velocity_fft = u_fft * self._vorticity2velocity(f_mesh, 1)\n        if self.external_force is not None:\n            velocity_fft *= f_mesh.low_pass_filter()\n        convection = self._convection(\n            velocity_fft, f_mesh, f_mesh.ifft(velocity_fft).real\n        )\n        if self.external_force is not None:\n            convection -= self.external_force(\n                u_fft=u_fft, mesh=f_mesh, return_in_fourier=True\n            )\n        p = torch.sum(\n            f_mesh.nabla_vector(1) * convection, dim=1, keepdim=True\n        )  # nabla.(u.nabla_u)\n        return -1 * p * f_mesh.invert_laplacian()  #  p = - nabla.(u.nabla_u)/laplacian\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Vorticity2PressureCore.external_force","title":"external_force  <code>instance-attribute</code>","text":"<pre><code>external_force = external_force\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Vorticity2PressureCore.__init__","title":"__init__","text":"<pre><code>__init__(\n    external_force: Optional[OperatorLike] = None,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n    # if exeternal_force is not None, the external force may need the original u_fft, thus we do not dealiasing at the beginning\n    super().__init__(dealiasing_swtich=external_force is None)\n    self.external_force = external_force\n    self._vorticity2velocity = _Vorticity2VelocityCore()\n    self._convection = _ConvectionCore()\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Vorticity2PressureCore.__call__","title":"__call__","text":"<pre><code>__call__(u_fft, f_mesh, u) -&gt; FourierTensor['B C H ...']\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __call__(self, u_fft, f_mesh, u) -&gt; FourierTensor[\"B C H ...\"]:\n    velocity_fft = u_fft * self._vorticity2velocity(f_mesh, 1)\n    if self.external_force is not None:\n        velocity_fft *= f_mesh.low_pass_filter()\n    convection = self._convection(\n        velocity_fft, f_mesh, f_mesh.ifft(velocity_fft).real\n    )\n    if self.external_force is not None:\n        convection -= self.external_force(\n            u_fft=u_fft, mesh=f_mesh, return_in_fourier=True\n        )\n    p = torch.sum(\n        f_mesh.nabla_vector(1) * convection, dim=1, keepdim=True\n    )  # nabla.(u.nabla_u)\n    return -1 * p * f_mesh.invert_laplacian()  #  p = - nabla.(u.nabla_u)/laplacian\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Vorticity2PressureCore.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Return the result of the nonlinear function in spatial domain.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SpatialTensor</code> <code>SpatialTensor['B C H ...']</code> <p>Result of the nonlinear function in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Return the result of the nonlinear function in spatial domain.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        SpatialTensor: Result of the nonlinear function in spatial domain.\n    \"\"\"\n\n    return f_mesh.ifft(self(u_fft, f_mesh, u)).real\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Velocity2PressureCore","title":"torchfsm.operator.dedicated._navier_stokes._Velocity2PressureCore","text":"<p>               Bases: <code>NonlinearFunc</code></p> <p>Implementation of the Velocity2Pressure operator.</p> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class _Velocity2PressureCore(NonlinearFunc):\n    r\"\"\"\n    Implementation of the Velocity2Pressure operator.\n    \"\"\"\n\n    def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n        # if exeternal_force is not None, the external force may need the original u_fft, thus we do not dealiasing at the beginning\n        super().__init__(dealiasing_swtich=external_force is None)\n        self.external_force = external_force\n        self._convection = _ConvectionCore()\n\n    def __call__(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    ) -&gt; FourierTensor[\"B C H ...\"]:\n        if self.external_force is not None:  # u_fft is original version\n            force = self.external_force(\n                u_fft=u_fft, mesh=f_mesh, return_in_fourier=True\n            )\n            u_fft *= f_mesh.low_pass_filter()\n            u = f_mesh.ifft(u_fft).real\n        else:  # u_fft is dealiased version\n            if u is None:\n                u = f_mesh.ifft(u_fft).real\n        convection = self._convection(u_fft, f_mesh, u)\n        if self.external_force is not None:\n            convection -= force\n        p = torch.sum(\n            f_mesh.nabla_vector(1) * convection, dim=1, keepdim=True\n        )  # nabla.(u.nabla_u)\n        return -1 * p * f_mesh.invert_laplacian()  #  p = - nabla.(u.nabla_u)/laplacian\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Velocity2PressureCore.external_force","title":"external_force  <code>instance-attribute</code>","text":"<pre><code>external_force = external_force\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Velocity2PressureCore.__init__","title":"__init__","text":"<pre><code>__init__(\n    external_force: Optional[OperatorLike] = None,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n    # if exeternal_force is not None, the external force may need the original u_fft, thus we do not dealiasing at the beginning\n    super().__init__(dealiasing_swtich=external_force is None)\n    self.external_force = external_force\n    self._convection = _ConvectionCore()\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Velocity2PressureCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __call__(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; FourierTensor[\"B C H ...\"]:\n    if self.external_force is not None:  # u_fft is original version\n        force = self.external_force(\n            u_fft=u_fft, mesh=f_mesh, return_in_fourier=True\n        )\n        u_fft *= f_mesh.low_pass_filter()\n        u = f_mesh.ifft(u_fft).real\n    else:  # u_fft is dealiased version\n        if u is None:\n            u = f_mesh.ifft(u_fft).real\n    convection = self._convection(u_fft, f_mesh, u)\n    if self.external_force is not None:\n        convection -= force\n    p = torch.sum(\n        f_mesh.nabla_vector(1) * convection, dim=1, keepdim=True\n    )  # nabla.(u.nabla_u)\n    return -1 * p * f_mesh.invert_laplacian()  #  p = - nabla.(u.nabla_u)/laplacian\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._Velocity2PressureCore.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Return the result of the nonlinear function in spatial domain.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SpatialTensor</code> <code>SpatialTensor['B C H ...']</code> <p>Result of the nonlinear function in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Return the result of the nonlinear function in spatial domain.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        SpatialTensor: Result of the nonlinear function in spatial domain.\n    \"\"\"\n\n    return f_mesh.ifft(self(u_fft, f_mesh, u)).real\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._NSPressureConvectionCore","title":"torchfsm.operator.dedicated._navier_stokes._NSPressureConvectionCore","text":"<p>               Bases: <code>NonlinearFunc</code></p> <p>Implementation of the Navier-Stokes pressure convection operator.</p> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class _NSPressureConvectionCore(NonlinearFunc):\n    r\"\"\"\n    Implementation of the Navier-Stokes pressure convection operator.\n    \"\"\"\n\n    def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n        super().__init__(dealiasing_swtich=external_force is None)\n        self.external_force = external_force\n        self._convection = _ConvectionCore()\n\n    def __call__(\n        self,\n        u_fft: FourierTensor[\"B C H ...\"],\n        f_mesh: FourierMesh,\n        u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n    ) -&gt; torch.Tensor:\n        if self.external_force is not None:  # u_fft is original version\n            force = self.external_force(\n                u_fft=u_fft, mesh=f_mesh, return_in_fourier=True\n            )\n            u_fft *= f_mesh.low_pass_filter()\n            u = f_mesh.ifft(u_fft).real\n        else:  # u_fft is dealiased version\n            if u is None:\n                u = f_mesh.ifft(u_fft).real\n        convection = self._convection(u_fft, f_mesh,u)\n        if self.external_force is not None:\n            convection -= force\n        p = f_mesh.invert_laplacian() * torch.sum(\n            f_mesh.nabla_vector(1) * convection, dim=1, keepdim=True\n        )  # - p = nabla.(u.nabla_u)/laplacian\n        if self.external_force is not None:\n            return f_mesh.nabla_vector(1) * p - convection + force # -nabla(p) - nabla.(u.nabla_u) + f\n        return f_mesh.nabla_vector(1) * p - convection  # -nabla(p) - nabla.(u.nabla_u)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._NSPressureConvectionCore.external_force","title":"external_force  <code>instance-attribute</code>","text":"<pre><code>external_force = external_force\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._NSPressureConvectionCore.__init__","title":"__init__","text":"<pre><code>__init__(\n    external_force: Optional[OperatorLike] = None,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n    super().__init__(dealiasing_swtich=external_force is None)\n    self.external_force = external_force\n    self._convection = _ConvectionCore()\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._NSPressureConvectionCore.__call__","title":"__call__","text":"<pre><code>__call__(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; torch.Tensor\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __call__(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; torch.Tensor:\n    if self.external_force is not None:  # u_fft is original version\n        force = self.external_force(\n            u_fft=u_fft, mesh=f_mesh, return_in_fourier=True\n        )\n        u_fft *= f_mesh.low_pass_filter()\n        u = f_mesh.ifft(u_fft).real\n    else:  # u_fft is dealiased version\n        if u is None:\n            u = f_mesh.ifft(u_fft).real\n    convection = self._convection(u_fft, f_mesh,u)\n    if self.external_force is not None:\n        convection -= force\n    p = f_mesh.invert_laplacian() * torch.sum(\n        f_mesh.nabla_vector(1) * convection, dim=1, keepdim=True\n    )  # - p = nabla.(u.nabla_u)/laplacian\n    if self.external_force is not None:\n        return f_mesh.nabla_vector(1) * p - convection + force # -nabla(p) - nabla.(u.nabla_u) + f\n    return f_mesh.nabla_vector(1) * p - convection  # -nabla(p) - nabla.(u.nabla_u)\n</code></pre>"},{"location":"apis/operator_core/#torchfsm.operator.dedicated._navier_stokes._NSPressureConvectionCore.spatial_value","title":"spatial_value","text":"<pre><code>spatial_value(\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]] = None,\n) -&gt; SpatialTensor[\"B C H ...\"]\n</code></pre> <p>Return the result of the nonlinear function in spatial domain.</p> <p>Parameters:</p> Name Type Description Default <code>u_fft</code> <code>FourierTensor</code> <p>Fourier-transformed input tensor.</p> required <code>f_mesh</code> <code>FourierMesh</code> <p>Fourier mesh object.</p> required <code>u</code> <code>Optional[SpatialTensor]</code> <p>Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>SpatialTensor</code> <code>SpatialTensor['B C H ...']</code> <p>Result of the nonlinear function in spatial domain.</p> Source code in <code>torchfsm/operator/_base.py</code> <pre><code>def spatial_value(\n    self,\n    u_fft: FourierTensor[\"B C H ...\"],\n    f_mesh: FourierMesh,\n    u: Optional[SpatialTensor[\"B C H ...\"]]=None,\n) -&gt; SpatialTensor[\"B C H ...\"]:\n    r\"\"\"\n    Return the result of the nonlinear function in spatial domain.\n\n    Args:\n        u_fft (FourierTensor): Fourier-transformed input tensor.\n        f_mesh (FourierMesh): Fourier mesh object.\n        u (Optional[SpatialTensor]): Corresponding tensor of u_fft in spatial domain. This option aims to avoid repeating the inverse FFT operation in operators.\n\n    Returns:\n        SpatialTensor: Result of the nonlinear function in spatial domain.\n    \"\"\"\n\n    return f_mesh.ifft(self(u_fft, f_mesh, u)).real\n</code></pre>"},{"location":"apis/operator_generator/","title":"Generators","text":""},{"location":"apis/operator_generator/#torchfsm.operator.generic._conservative_convection._ConservativeConvectionGenerator","title":"torchfsm.operator.generic._conservative_convection._ConservativeConvectionGenerator","text":"<p>               Bases: <code>CoreGenerator</code></p> <p>Generator of the Conservative Convection operator. It ensures that the operator is only applied to vector fields with the same dimension as the mesh.</p> Source code in <code>torchfsm/operator/generic/_conservative_convection.py</code> <pre><code>class _ConservativeConvectionGenerator(CoreGenerator):\n\n    r\"\"\"\n    Generator of the Conservative Convection operator. It ensures that the operator is only applied to vector fields with the same dimension as the mesh.\n    \"\"\"\n\n    def __call__(\n        self, f_mesh: FourierMesh, n_channel: int\n    ) -&gt; LinearCoef | NonlinearFunc:\n        if f_mesh.n_dim != n_channel:\n            raise ValueError(\n                f\"div operator only works for vector field with the same dimension as mesh\"\n            )\n        return _ConservativeConvectionCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._conservative_convection._ConservativeConvectionGenerator.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; LinearCoef | NonlinearFunc\n</code></pre> Source code in <code>torchfsm/operator/generic/_conservative_convection.py</code> <pre><code>def __call__(\n    self, f_mesh: FourierMesh, n_channel: int\n) -&gt; LinearCoef | NonlinearFunc:\n    if f_mesh.n_dim != n_channel:\n        raise ValueError(\n            f\"div operator only works for vector field with the same dimension as mesh\"\n        )\n    return _ConservativeConvectionCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._convection._ConvectionGenerator","title":"torchfsm.operator.generic._convection._ConvectionGenerator","text":"<p>               Bases: <code>CoreGenerator</code></p> <p>Generator of the Convection operator. It ensures that the operator is only applied to vector fields with the same dimension as the mesh.</p> Source code in <code>torchfsm/operator/generic/_convection.py</code> <pre><code>class _ConvectionGenerator(CoreGenerator):\n\n    r\"\"\"\n    Generator of the Convection operator. It ensures that the operator is only applied to vector fields with the same dimension as the mesh.\n    \"\"\"\n\n    def __call__(\n        self, f_mesh: FourierMesh, n_channel: int\n    ) -&gt; LinearCoef | NonlinearFunc:\n        if f_mesh.n_dim != n_channel:\n            raise ValueError(\n                f\"convection operator only works for vector field with the same dimension as mesh\"\n            )\n        return _ConvectionCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._convection._ConvectionGenerator.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; LinearCoef | NonlinearFunc\n</code></pre> Source code in <code>torchfsm/operator/generic/_convection.py</code> <pre><code>def __call__(\n    self, f_mesh: FourierMesh, n_channel: int\n) -&gt; LinearCoef | NonlinearFunc:\n    if f_mesh.n_dim != n_channel:\n        raise ValueError(\n            f\"convection operator only works for vector field with the same dimension as mesh\"\n        )\n    return _ConvectionCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._curl._CurlGenerator","title":"torchfsm.operator.generic._curl._CurlGenerator","text":"<p>               Bases: <code>CoreGenerator</code></p> <p>Generator of the Curl operator.      It ensure that curl only works for 2D or 3D vector field with the same dimension as the mesh.</p> Source code in <code>torchfsm/operator/generic/_curl.py</code> <pre><code>class _CurlGenerator(CoreGenerator):\n    r\"\"\"\n    Generator of the Curl operator. \n        It ensure that curl only works for 2D or 3D vector field with the same dimension as the mesh.\n    \"\"\"\n\n    def __call__(\n        self, f_mesh: FourierMesh, n_channel: int\n    ) -&gt; LinearCoef | NonlinearFunc:\n        if f_mesh.n_dim != n_channel:\n            raise ValueError(\n                f\"div operator only works for vector field with the same dimension as mesh\"\n            )\n        if n_channel &gt; 3 or n_channel &lt; 2:\n            raise ValueError(f\"div operator only works for 2D or 3D vector field\")\n        if n_channel == 2:\n            return _Curl2DCore()\n        else:\n            return _Curl3DCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._curl._CurlGenerator.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; LinearCoef | NonlinearFunc\n</code></pre> Source code in <code>torchfsm/operator/generic/_curl.py</code> <pre><code>def __call__(\n    self, f_mesh: FourierMesh, n_channel: int\n) -&gt; LinearCoef | NonlinearFunc:\n    if f_mesh.n_dim != n_channel:\n        raise ValueError(\n            f\"div operator only works for vector field with the same dimension as mesh\"\n        )\n    if n_channel &gt; 3 or n_channel &lt; 2:\n        raise ValueError(f\"div operator only works for 2D or 3D vector field\")\n    if n_channel == 2:\n        return _Curl2DCore()\n    else:\n        return _Curl3DCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._div._DivGenerator","title":"torchfsm.operator.generic._div._DivGenerator","text":"<p>               Bases: <code>CoreGenerator</code></p> <p>Generator of the Divergence operator.     It ensures that divergence only works for vector fields with the same dimension as the mesh.</p> Source code in <code>torchfsm/operator/generic/_div.py</code> <pre><code>class _DivGenerator(CoreGenerator):\n\n    r\"\"\"\n    Generator of the Divergence operator.\n        It ensures that divergence only works for vector fields with the same dimension as the mesh.\n    \"\"\"\n\n    def __call__(\n        self, f_mesh: FourierMesh, n_channel: int\n    ) -&gt; LinearCoef | NonlinearFunc:\n        if f_mesh.n_dim != n_channel:\n            raise ValueError(\n                f\"div operator only works for vector field with the same dimension as mesh\"\n            )\n        return _DivCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._div._DivGenerator.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; LinearCoef | NonlinearFunc\n</code></pre> Source code in <code>torchfsm/operator/generic/_div.py</code> <pre><code>def __call__(\n    self, f_mesh: FourierMesh, n_channel: int\n) -&gt; LinearCoef | NonlinearFunc:\n    if f_mesh.n_dim != n_channel:\n        raise ValueError(\n            f\"div operator only works for vector field with the same dimension as mesh\"\n        )\n    return _DivCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._grad._GradGenerator","title":"torchfsm.operator.generic._grad._GradGenerator","text":"<p>               Bases: <code>CoreGenerator</code></p> <p>Generator of the Grad operator.     It ensures that grad only works for scalar field.</p> Source code in <code>torchfsm/operator/generic/_grad.py</code> <pre><code>class _GradGenerator(CoreGenerator):\n    r\"\"\"\n    Generator of the Grad operator.\n        It ensures that grad only works for scalar field.\n    \"\"\"\n\n    def __call__(self, f_mesh: FourierMesh, n_channel: int) -&gt; LinearCoef:\n        if n_channel != 1:\n            raise ValueError(\"The Grad operator only supports scalar field.\")\n        return _GradCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._grad._GradGenerator.__call__","title":"__call__","text":"<pre><code>__call__(f_mesh: FourierMesh, n_channel: int) -&gt; LinearCoef\n</code></pre> Source code in <code>torchfsm/operator/generic/_grad.py</code> <pre><code>def __call__(self, f_mesh: FourierMesh, n_channel: int) -&gt; LinearCoef:\n    if n_channel != 1:\n        raise ValueError(\"The Grad operator only supports scalar field.\")\n    return _GradCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._spatial_derivative._SpatialDerivativeGenerator","title":"torchfsm.operator.generic._spatial_derivative._SpatialDerivativeGenerator","text":"<p>               Bases: <code>CoreGenerator</code></p> <p>Generator of the SpatialDerivative operator.     It ensures that spatial derivative only works for scalar field.</p> Source code in <code>torchfsm/operator/generic/_spatial_derivative.py</code> <pre><code>class _SpatialDerivativeGenerator(CoreGenerator):\n\n    r\"\"\"\n    Generator of the SpatialDerivative operator.\n        It ensures that spatial derivative only works for scalar field.\n    \"\"\"\n\n    def __init__(self, dim_index, order) -&gt; None:\n        super().__init__()\n        self.dim_index = dim_index\n        self.order = order\n\n    def __call__(self, f_mesh: FourierMesh, n_channel: int) -&gt; LinearCoef:\n        if n_channel != 1:\n            raise ValueError(\n                \"The SpatialDerivative operator only supports scalar field.\"\n            )\n        return _SpatialDerivativeCore(self.dim_index, self.order)\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._spatial_derivative._SpatialDerivativeGenerator.dim_index","title":"dim_index  <code>instance-attribute</code>","text":"<pre><code>dim_index = dim_index\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._spatial_derivative._SpatialDerivativeGenerator.order","title":"order  <code>instance-attribute</code>","text":"<pre><code>order = order\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._spatial_derivative._SpatialDerivativeGenerator.__init__","title":"__init__","text":"<pre><code>__init__(dim_index, order) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/generic/_spatial_derivative.py</code> <pre><code>def __init__(self, dim_index, order) -&gt; None:\n    super().__init__()\n    self.dim_index = dim_index\n    self.order = order\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.generic._spatial_derivative._SpatialDerivativeGenerator.__call__","title":"__call__","text":"<pre><code>__call__(f_mesh: FourierMesh, n_channel: int) -&gt; LinearCoef\n</code></pre> Source code in <code>torchfsm/operator/generic/_spatial_derivative.py</code> <pre><code>def __call__(self, f_mesh: FourierMesh, n_channel: int) -&gt; LinearCoef:\n    if n_channel != 1:\n        raise ValueError(\n            \"The SpatialDerivative operator only supports scalar field.\"\n        )\n    return _SpatialDerivativeCore(self.dim_index, self.order)\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.dedicated._ks_convection._KSConvectionGenerator","title":"torchfsm.operator.dedicated._ks_convection._KSConvectionGenerator","text":"<p>               Bases: <code>CoreGenerator</code></p> <p>Generator of the KSConvection operator. It ensures that the operator is only applied to scalar fields.</p> Source code in <code>torchfsm/operator/dedicated/_ks_convection.py</code> <pre><code>class _KSConvectionGenerator(CoreGenerator):\n    r\"\"\"\n    Generator of the KSConvection operator. It ensures that the operator is only applied to scalar fields.\n    \"\"\"\n\n    def __init__(self, remove_mean: bool) -&gt; None:\n        self.remove_mean = remove_mean\n\n    def __call__(self, f_mesh: FourierMesh, n_channel: int) -&gt; NonlinearFunc:\n        if n_channel != 1:\n            return NotImplementedError(\"KSConvection only supports scalar field\")\n        return _KSConvectionCore(self.remove_mean)\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.dedicated._ks_convection._KSConvectionGenerator.remove_mean","title":"remove_mean  <code>instance-attribute</code>","text":"<pre><code>remove_mean = remove_mean\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.dedicated._ks_convection._KSConvectionGenerator.__init__","title":"__init__","text":"<pre><code>__init__(remove_mean: bool) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_ks_convection.py</code> <pre><code>def __init__(self, remove_mean: bool) -&gt; None:\n    self.remove_mean = remove_mean\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.dedicated._ks_convection._KSConvectionGenerator.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; NonlinearFunc\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_ks_convection.py</code> <pre><code>def __call__(self, f_mesh: FourierMesh, n_channel: int) -&gt; NonlinearFunc:\n    if n_channel != 1:\n        return NotImplementedError(\"KSConvection only supports scalar field\")\n    return _KSConvectionCore(self.remove_mean)\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.dedicated._navier_stokes._VorticityConvectionGenerator","title":"torchfsm.operator.dedicated._navier_stokes._VorticityConvectionGenerator","text":"<p>               Bases: <code>CoreGenerator</code></p> <p>Generator of the VorticityConvection operator.      It ensures that the operator is only applied to scalar vorticity fields in 2D.</p> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class _VorticityConvectionGenerator(CoreGenerator):\n\n    r\"\"\"\n    Generator of the VorticityConvection operator. \n        It ensures that the operator is only applied to scalar vorticity fields in 2D.\n    \"\"\"\n\n    def __call__(self, f_mesh: FourierMesh, n_channel: int) -&gt; NonlinearFunc:\n        if f_mesh.n_dim != 2 or n_channel != 1:\n            raise ValueError(\"Only vorticity in 2Dmesh is supported\")\n        return _VorticityConvectionCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.dedicated._navier_stokes._VorticityConvectionGenerator.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; NonlinearFunc\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __call__(self, f_mesh: FourierMesh, n_channel: int) -&gt; NonlinearFunc:\n    if f_mesh.n_dim != 2 or n_channel != 1:\n        raise ValueError(\"Only vorticity in 2Dmesh is supported\")\n    return _VorticityConvectionCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.dedicated._navier_stokes._Vorticity2VelocityGenerator","title":"torchfsm.operator.dedicated._navier_stokes._Vorticity2VelocityGenerator","text":"<p>               Bases: <code>CoreGenerator</code></p> <p>Generator of the Vorticity2Velocity operator.     It ensures that the operator is only applied to scalar vorticity fields in 2D.</p> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class _Vorticity2VelocityGenerator(CoreGenerator):\n\n    r\"\"\"\n    Generator of the Vorticity2Velocity operator.\n        It ensures that the operator is only applied to scalar vorticity fields in 2D.\"\"\"\n\n    def __call__(self, f_mesh: FourierMesh, n_channel: int) -&gt; NonlinearFunc:\n        if f_mesh.n_dim != 2 or n_channel != 1:\n            raise ValueError(\"Only vorticity in 2Dmesh is supported\")\n        return _Vorticity2VelocityCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.dedicated._navier_stokes._Vorticity2VelocityGenerator.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; NonlinearFunc\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __call__(self, f_mesh: FourierMesh, n_channel: int) -&gt; NonlinearFunc:\n    if f_mesh.n_dim != 2 or n_channel != 1:\n        raise ValueError(\"Only vorticity in 2Dmesh is supported\")\n    return _Vorticity2VelocityCore()\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.dedicated._navier_stokes._Vorticity2PressureGenerator","title":"torchfsm.operator.dedicated._navier_stokes._Vorticity2PressureGenerator","text":"<p>               Bases: <code>CoreGenerator</code></p> <p>Generator of the Vorticity2Pressure operator.     It ensures that the operator is only applied to scalar vorticity fields in 2D.</p> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>class _Vorticity2PressureGenerator(CoreGenerator):\n    r\"\"\"\n    Generator of the Vorticity2Pressure operator.\n        It ensures that the operator is only applied to scalar vorticity fields in 2D.\n    \"\"\"\n\n    def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n        self.external_force = external_force\n\n    def __call__(self, f_mesh: FourierMesh, n_channel: int) -&gt; NonlinearFunc:\n        if f_mesh.n_dim != 2 or n_channel != 1:\n            raise ValueError(\"Only vorticity in 2Dmesh is supported\")\n        return _Vorticity2PressureCore(self.external_force)\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.dedicated._navier_stokes._Vorticity2PressureGenerator.external_force","title":"external_force  <code>instance-attribute</code>","text":"<pre><code>external_force = external_force\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.dedicated._navier_stokes._Vorticity2PressureGenerator.__init__","title":"__init__","text":"<pre><code>__init__(\n    external_force: Optional[OperatorLike] = None,\n) -&gt; None\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __init__(self, external_force: Optional[OperatorLike] = None) -&gt; None:\n    self.external_force = external_force\n</code></pre>"},{"location":"apis/operator_generator/#torchfsm.operator.dedicated._navier_stokes._Vorticity2PressureGenerator.__call__","title":"__call__","text":"<pre><code>__call__(\n    f_mesh: FourierMesh, n_channel: int\n) -&gt; NonlinearFunc\n</code></pre> Source code in <code>torchfsm/operator/dedicated/_navier_stokes.py</code> <pre><code>def __call__(self, f_mesh: FourierMesh, n_channel: int) -&gt; NonlinearFunc:\n    if f_mesh.n_dim != 2 or n_channel != 1:\n        raise ValueError(\"Only vorticity in 2Dmesh is supported\")\n    return _Vorticity2PressureCore(self.external_force)\n</code></pre>"},{"location":"apis/pde/","title":"2. pde","text":""},{"location":"apis/pde/#torchfsm.pde.Burgers","title":"torchfsm.pde.Burgers","text":"<pre><code>Burgers(nu: float) -&gt; Operator\n</code></pre> Burgers equation \\[\\frac{\\partial \\mathbf{u}}{\\partial t} =-\\mathbf{u} \\cdot \\nabla \\mathbf{u} + \\nu \\nabla^2 \\mathbf{u}\\] <p>Parameters:</p> Name Type Description Default <code>nu</code> <code>float</code> <p>Viscosity coefficient.    </p> required <p>Returns:</p> Name Type Description <code>Operator</code> <code>Operator</code> <p>The operator representing the Burgers equation.</p> Source code in <code>torchfsm/pde.py</code> <pre><code>def Burgers(nu: float) -&gt; Operator:\n    r\"\"\"\n    Burgers equation:\n        $$\\frac{\\partial \\mathbf{u}}{\\partial t} =-\\mathbf{u} \\cdot \\nabla \\mathbf{u} + \\nu \\nabla^2 \\mathbf{u}$$\n\n    Args:\n        nu (float): Viscosity coefficient.    \n\n    Returns:\n        Operator: The operator representing the Burgers equation.\n\n    \"\"\"\n    return nu * Laplacian() - Convection()\n</code></pre>"},{"location":"apis/pde/#torchfsm.pde.KortewegDeVries","title":"torchfsm.pde.KortewegDeVries","text":"<pre><code>KortewegDeVries(\n    dispersion_coef=1, convection_coef: float = 6.0\n) -&gt; Operator\n</code></pre> Korteweg-De Vries equation \\[\\frac{\\partial \\phi}{\\partial t}=-c_1\\frac{\\partial^3 \\phi}{\\partial x^3} + c_2 \\phi\\frac{\\partial\\phi}{\\partial x}\\] <p>Parameters:</p> Name Type Description Default <code>dispersion_coef</code> <code>float</code> <p>Dispersion coefficient. Default is 1.</p> <code>1</code> <code>convection_coef</code> <code>float</code> <p>Convection coefficient. Default is 6.0.</p> <code>6.0</code> <p>Returns:</p> Name Type Description <code>Operator</code> <code>Operator</code> <p>The operator representing the Korteweg-De Vries equation.</p> Source code in <code>torchfsm/pde.py</code> <pre><code>def KortewegDeVries(dispersion_coef=1, convection_coef: float = 6.0) -&gt; Operator:\n    r\"\"\"\n    Korteweg-De Vries equation:\n        $$\\frac{\\partial \\phi}{\\partial t}=-c_1\\frac{\\partial^3 \\phi}{\\partial x^3} + c_2 \\phi\\frac{\\partial\\phi}{\\partial x}$$\n\n    Args:\n        dispersion_coef (float): Dispersion coefficient. Default is 1.\n        convection_coef (float): Convection coefficient. Default is 6.0.\n\n    Returns:\n        Operator: The operator representing the Korteweg-De Vries equation.    \n\n    \"\"\"\n    return -dispersion_coef * SpatialDerivative(0, 3) + convection_coef * Convection()\n</code></pre>"},{"location":"apis/pde/#torchfsm.pde.KuramotoSivashinsky","title":"torchfsm.pde.KuramotoSivashinsky","text":"<pre><code>KuramotoSivashinsky() -&gt; Operator\n</code></pre> 1D Kuramoto-Sivashinsky equation \\[\\frac{\\partial \\phi}{\\partial t}=-\\frac{\\partial^2 \\phi}{\\partial x^2} -\\frac{\\partial^4 \\phi}{\\partial x^4} - \\phi\\frac{\\partial\\phi}{\\partial x}\\] <p>Returns:</p> Name Type Description <code>Operator</code> <code>Operator</code> <p>The operator representing the Kuramoto-Sivashinsky equation.</p> Source code in <code>torchfsm/pde.py</code> <pre><code>def KuramotoSivashinsky() -&gt; Operator:\n    r\"\"\"\n    1D Kuramoto-Sivashinsky equation:\n        $$\\frac{\\partial \\phi}{\\partial t}=-\\frac{\\partial^2 \\phi}{\\partial x^2} -\\frac{\\partial^4 \\phi}{\\partial x^4} - \\phi\\frac{\\partial\\phi}{\\partial x}$$\n\n    Returns:\n        Operator: The operator representing the Kuramoto-Sivashinsky equation.\n    \"\"\"\n    ks_eqn = -Laplacian() - Biharmonic() - Convection()\n    ks_eqn.regisiter_additional_check(\n        lambda dim_value, dim_mesh: dim_value == 1 and dim_mesh == 1\n    )\n    return ks_eqn\n</code></pre>"},{"location":"apis/pde/#torchfsm.pde.KuramotoSivashinskyHighDim","title":"torchfsm.pde.KuramotoSivashinskyHighDim","text":"<pre><code>KuramotoSivashinskyHighDim() -&gt; Operator\n</code></pre> High dimensional Kuramoto-Sivashinsky equation \\[\\frac{\\partial \\mathbf{\\phi}}{\\partial t}=-\\nabla^2 \\phi- \\nabla^4 \\phi - \\frac{1}{2}|\\nabla \\phi|^2\\] <p>Returns:</p> Name Type Description <code>Operator</code> <code>Operator</code> <p>The operator representing the Kuramoto-Sivashinsky equation.</p> Source code in <code>torchfsm/pde.py</code> <pre><code>def KuramotoSivashinskyHighDim() -&gt; Operator:\n    r\"\"\"\n    High dimensional Kuramoto-Sivashinsky equation:\n        $$\\frac{\\partial \\mathbf{\\phi}}{\\partial t}=-\\nabla^2 \\phi- \\nabla^4 \\phi - \\frac{1}{2}|\\nabla \\phi|^2$$\n\n    Returns:\n        Operator: The operator representing the Kuramoto-Sivashinsky equation.\n    \"\"\"\n    return -Laplacian() - Biharmonic() - KSConvection()\n</code></pre>"},{"location":"apis/pde/#torchfsm.pde.NavierStokesVorticity","title":"torchfsm.pde.NavierStokesVorticity","text":"<pre><code>NavierStokesVorticity(\n    Re: float, force: Optional[Operator] = None\n) -&gt; Operator\n</code></pre> Navier-Stokes equation in vorticity form \\[\\frac{\\partial \\omega}{\\partial t} + (\\mathbf{u}\\cdot\\nabla) \\omega = \\frac{1}{Re} \\nabla^2 \\omega + \\nabla \\times \\mathbf{f}\\] <p>Parameters:</p> Name Type Description Default <code>Re</code> <code>float</code> <p>Reynolds number.</p> required <code>force</code> <code>Optional[Operator]</code> <p>Optional external force term. Default is None. If provided, it will be added to the vorticity equation. Note that the provided force should be \\(\\nabla \\times \\mathbf{f}\\) rather than \\(\\mathbf{f}\\) itself.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Operator</code> <code>Operator</code> <p>The operator representing the Navier-Stokes equation in vorticity form.</p> Source code in <code>torchfsm/pde.py</code> <pre><code>def NavierStokesVorticity(Re:float,force:Optional[Operator]=None)-&gt;Operator:\n    r\"\"\"\n    Navier-Stokes equation in vorticity form:\n        $$\\frac{\\partial \\omega}{\\partial t} + (\\mathbf{u}\\cdot\\nabla) \\omega = \\frac{1}{Re} \\nabla^2 \\omega + \\nabla \\times \\mathbf{f}$$\n\n    Args:\n        Re (float): Reynolds number.\n        force (Optional[Operator]): Optional external force term. Default is None.\n            If provided, it will be added to the vorticity equation. Note that the provided force should be $\\nabla \\times \\mathbf{f}$ rather than $\\mathbf{f}$ itself.\n\n    Returns:\n        Operator: The operator representing the Navier-Stokes equation in vorticity form.\n\n    \"\"\"\n    ns_vorticity=-VorticityConvection() + 1/Re*Laplacian()\n    if force is not None:\n        ns_vorticity+=force\n    return ns_vorticity\n</code></pre>"},{"location":"apis/pde/#torchfsm.pde.NavierStokes","title":"torchfsm.pde.NavierStokes","text":"<pre><code>NavierStokes(\n    Re: float, force: Optional[Operator] = None\n) -&gt; Operator\n</code></pre> Navier-Stokes equation \\[\\frac{\\partial\\mathbf{u}}{\\partial t}=-\\nabla (\\nabla^{-2} \\nabla \\cdot (\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}-f))-\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}+\\nu \\nabla^2 \\mathbf{u} + \\mathbf{f}\\] <p>Parameters:</p> Name Type Description Default <code>Re</code> <code>float</code> <p>Reynolds number.</p> required <code>force</code> <code>Optional[Operator]</code> <p>Optional external force term. Default is None. If provided, it will be added to the vorticity equation. </p> <code>None</code> <p>Returns:</p> Name Type Description <code>Operator</code> <code>Operator</code> <p>The operator representing the Navier-Stokes equation.</p> Source code in <code>torchfsm/pde.py</code> <pre><code>def NavierStokes(Re:float,force:Optional[Operator]=None)-&gt;Operator:\n    r\"\"\"\n    Navier-Stokes equation:\n        $$\\frac{\\partial\\mathbf{u}}{\\partial t}=-\\nabla (\\nabla^{-2} \\nabla \\cdot (\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}-f))-\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}+\\nu \\nabla^2 \\mathbf{u} + \\mathbf{f}$$\n\n    Args:\n        Re (float): Reynolds number.\n        force (Optional[Operator]): Optional external force term. Default is None.\n            If provided, it will be added to the vorticity equation. \n\n    Returns:\n        Operator: The operator representing the Navier-Stokes equation.\n\n    \"\"\"\n\n    return NSPressureConvection(force)+1/Re*Laplacian()\n</code></pre>"},{"location":"apis/plot/","title":"6. plot","text":""},{"location":"apis/plot/#torchfsm.plot.plot_1D_field","title":"torchfsm.plot.plot_1D_field","text":"<pre><code>plot_1D_field(\n    ax: Axes,\n    data: Union[ndarray, Tensor],\n    x_label: Optional[str] = None,\n    y_label: Optional[str] = None,\n    title: Optional[str] = None,\n    title_loc=\"center\",\n    show_ticks=True,\n    ticks_x: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_y: Tuple[Sequence[float], Sequence[str]] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    extend_value_range: bool = True,\n    grid=True,\n    **kwargs\n)\n</code></pre> <p>Plot a 1D field.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes to plot on.</p> required <code>data</code> <code>Union[ndarray, Tensor]</code> <p>The data to plot.</p> required <code>x_label</code> <code>Optional[str]</code> <p>The label for the x-axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>Optional[str]</code> <p>The label for the y-axis. Defaults to None.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>The title of the plot. Defaults to None.</p> <code>None</code> <code>title_loc</code> <code>str</code> <p>The location of the title. Defaults to \"center\".</p> <code>'center'</code> <code>show_ticks</code> <code>bool</code> <p>Whether to show ticks. Defaults to True.</p> <code>True</code> <code>ticks_x</code> <code>Tuple[Sequence[float], Sequence[str]]</code> <p>Custom ticks for the x-axis. Defaults to None.</p> <code>None</code> <code>ticks_y</code> <code>Tuple[Sequence[float], Sequence[str]]</code> <p>Custom ticks for the y-axis. Defaults to None.</p> <code>None</code> <code>vmin</code> <code>Optional[float]</code> <p>The minimum value for the color scale. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>Optional[float]</code> <p>The maximum value for the color scale. Defaults to None.</p> <code>None</code> <code>extend_value_range</code> <code>bool</code> <p>Whether to extend the value range. Defaults to True.</p> <code>True</code> <code>grid</code> <code>bool</code> <p>Whether to show grid lines. Defaults to True.</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments for the plot.</p> <code>{}</code> Source code in <code>torchfsm/plot.py</code> <pre><code>def plot_1D_field(\n    ax: plt.Axes,\n    data: Union[np.ndarray, torch.Tensor],\n    x_label: Optional[str] = None,\n    y_label: Optional[str] = None,\n    title: Optional[str] = None,\n    title_loc=\"center\",\n    show_ticks=True,\n    ticks_x: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_y: Tuple[Sequence[float], Sequence[str]] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    extend_value_range: bool = True,\n    grid=True,\n    **kwargs\n):\n    \"\"\"\n    Plot a 1D field.\n\n    Args:\n        ax (plt.Axes): The axes to plot on.\n        data (Union[np.ndarray, torch.Tensor]): The data to plot.\n        x_label (Optional[str], optional): The label for the x-axis. Defaults to None.\n        y_label (Optional[str], optional): The label for the y-axis. Defaults to None.\n        title (Optional[str], optional): The title of the plot. Defaults to None.\n        title_loc (str, optional): The location of the title. Defaults to \"center\".\n        show_ticks (bool, optional): Whether to show ticks. Defaults to True.\n        ticks_x (Tuple[Sequence[float], Sequence[str]], optional): Custom ticks for the x-axis. Defaults to None.\n        ticks_y (Tuple[Sequence[float], Sequence[str]], optional): Custom ticks for the y-axis. Defaults to None.\n        vmin (Optional[float], optional): The minimum value for the color scale. Defaults to None.\n        vmax (Optional[float], optional): The maximum value for the color scale. Defaults to None.\n        extend_value_range (bool, optional): Whether to extend the value range. Defaults to True.\n        grid (bool, optional): Whether to show grid lines. Defaults to True.\n        **kwargs: Additional keyword arguments for the plot.\n\n    \"\"\"\n    if isinstance(data, torch.Tensor):\n        data = data.detach().cpu().numpy()\n    elif not isinstance(data, np.ndarray):\n        data = np.asarray(data)\n    if len(data.shape) != 1:\n        raise ValueError(\"Only support 1D data.\")\n    ax.plot(data, **kwargs)\n    if not show_ticks:\n        ax.set_xticks([])\n        ax.set_yticks([])\n    else:\n        if ticks_x is not None:\n            ax.set_xticks(ticks_x[0], labels=ticks_x[1])\n        if ticks_y is not None:\n            ax.set_yticks(ticks_y[0], labels=ticks_y[1])\n    if x_label is not None:\n        ax.set_xlabel(x_label)\n    if y_label is not None:\n        ax.set_ylabel(y_label)\n    if title is not None:\n        ax.set_title(title, loc=title_loc)\n    if vmin is not None and vmax is not None:\n        if extend_value_range:\n            ax.set_ylim(vmin * 1.05, vmax * 1.05)\n        else:\n            ax.set_ylim(vmin, vmax)\n    if grid:\n        ax.grid()\n</code></pre>"},{"location":"apis/plot/#torchfsm.plot.plot_2D_field","title":"torchfsm.plot.plot_2D_field","text":"<pre><code>plot_2D_field(\n    ax: Axes,\n    data: Union[ndarray, Tensor],\n    x_label: Optional[str] = None,\n    y_label: Optional[str] = None,\n    title: Optional[str] = None,\n    title_loc=\"center\",\n    interpolation=\"none\",\n    aspect=\"auto\",\n    cmap: Union[str, Colormap] = \"coolwarm\",\n    show_ticks=True,\n    ticks_x: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_y: Tuple[Sequence[float], Sequence[str]] = None,\n    **kwargs\n)\n</code></pre> <p>Plot a 2D field.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes to plot on.</p> required <code>data</code> <code>Union[ndarray, Tensor]</code> <p>The data to plot.</p> required <code>x_label</code> <code>Optional[str]</code> <p>The label for the x-axis. Defaults to None.</p> <code>None</code> <code>y_label</code> <code>Optional[str]</code> <p>The label for the y-axis. Defaults to None.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>The title of the plot. Defaults to None.</p> <code>None</code> <code>title_loc</code> <code>str</code> <p>The location of the title. Defaults to \"center\".</p> <code>'center'</code> <code>interpolation</code> <code>str</code> <p>The interpolation method. Defaults to \"none\".</p> <code>'none'</code> <code>aspect</code> <code>str</code> <p>The aspect ratio. Defaults to \"auto\".</p> <code>'auto'</code> <code>cmap</code> <code>Union[str, Colormap]</code> <p>The colormap to use. Defaults to \"coolwarm\".</p> <code>'coolwarm'</code> <code>show_ticks</code> <code>bool</code> <p>Whether to show ticks. Defaults to True.</p> <code>True</code> <code>ticks_x</code> <code>Tuple[Sequence[float], Sequence[str]]</code> <p>Custom ticks for the x-axis. Defaults to None.</p> <code>None</code> <code>ticks_y</code> <code>Tuple[Sequence[float], Sequence[str]]</code> <p>Custom ticks for the y-axis. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the plot.</p> <code>{}</code> Source code in <code>torchfsm/plot.py</code> <pre><code>def plot_2D_field(\n    ax: plt.Axes,\n    data: Union[np.ndarray, torch.Tensor],\n    x_label: Optional[str] = None,\n    y_label: Optional[str] = None,\n    title: Optional[str] = None,\n    title_loc=\"center\",\n    interpolation=\"none\",\n    aspect=\"auto\",\n    cmap: Union[str, Colormap] = \"coolwarm\",\n    show_ticks=True,\n    ticks_x: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_y: Tuple[Sequence[float], Sequence[str]] = None,\n    **kwargs\n):\n    \"\"\"\n    Plot a 2D field.\n\n    Args:\n        ax (plt.Axes): The axes to plot on.\n        data (Union[np.ndarray, torch.Tensor]): The data to plot.\n        x_label (Optional[str], optional): The label for the x-axis. Defaults to None.\n        y_label (Optional[str], optional): The label for the y-axis. Defaults to None.\n        title (Optional[str], optional): The title of the plot. Defaults to None.\n        title_loc (str, optional): The location of the title. Defaults to \"center\".\n        interpolation (str, optional): The interpolation method. Defaults to \"none\".\n        aspect (str, optional): The aspect ratio. Defaults to \"auto\".\n        cmap (Union[str, Colormap], optional): The colormap to use. Defaults to \"coolwarm\".\n        show_ticks (bool, optional): Whether to show ticks. Defaults to True.\n        ticks_x (Tuple[Sequence[float], Sequence[str]], optional): Custom ticks for the x-axis. Defaults to None.\n        ticks_y (Tuple[Sequence[float], Sequence[str]], optional): Custom ticks for the y-axis. Defaults to None.\n        **kwargs: Additional keyword arguments for the plot.\n    \"\"\"\n    if isinstance(data, torch.Tensor):\n        data = data.detach().cpu().numpy()\n    elif not isinstance(data, np.ndarray):\n        data = np.asarray(data)\n    if len(data.shape) != 2:\n        raise ValueError(\"Only support 2D data.\")\n    im = ax.imshow(\n        data.T,\n        interpolation=interpolation,\n        cmap=cmap,\n        origin=\"lower\",\n        aspect=aspect,\n        **kwargs\n    )\n    if not show_ticks:\n        ax.set_xticks([])\n        ax.set_yticks([])\n    if x_label is not None:\n        ax.set_xlabel(x_label)\n    if y_label is not None:\n        ax.set_ylabel(y_label)\n    if title is not None:\n        ax.set_title(title, loc=title_loc)\n    if ticks_x is not None:\n        ax.set_xticks(ticks_x[0], labels=ticks_x[1])\n    if ticks_y is not None:\n        ax.set_yticks(ticks_y[0], labels=ticks_y[1])\n    return im\n</code></pre>"},{"location":"apis/plot/#torchfsm.plot.plot_3D_field","title":"torchfsm.plot.plot_3D_field","text":"<pre><code>plot_3D_field(\n    ax: Axes,\n    data: Union[ndarray, Tensor],\n    bottom_label: Optional[str] = None,\n    left_label: Optional[str] = None,\n    title: Optional[str] = None,\n    title_loc=\"center\",\n    aspect=\"auto\",\n    cmap: Union[str, Colormap] = \"coolwarm\",\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    return_cmap: bool = False,\n    distance_scale: float = 10,\n    background=(0, 0, 0, 0),\n    width=512,\n    height=512,\n    alpha_func: Literal[\n        \"zigzag\", \"diverging\", \"linear\"\n    ] = \"zigzag\",\n    gamma_correction: float = 2.4,\n    **kwargs\n)\n</code></pre> <p>Plot a 3D field. Powered by https://github.com/KeKsBoTer/vape4d</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes</code> <p>The axes to plot on.</p> required <code>data</code> <code>Union[ndarray, Tensor]</code> <p>The data to plot.</p> required <code>bottom_label</code> <code>Optional[str]</code> <p>The label for the bottom axis. Defaults to None.</p> <code>None</code> <code>left_label</code> <code>Optional[str]</code> <p>The label for the left axis. Defaults to None.</p> <code>None</code> <code>title</code> <code>Optional[str]</code> <p>The title of the plot. Defaults to None.</p> <code>None</code> <code>title_loc</code> <code>str</code> <p>The location of the title. Defaults to \"center\".</p> <code>'center'</code> <code>aspect</code> <code>str</code> <p>The aspect ratio. Defaults to \"auto\".</p> <code>'auto'</code> <code>cmap</code> <code>Union[str, Colormap]</code> <p>The colormap to use. Defaults to \"coolwarm\".</p> <code>'coolwarm'</code> <code>vmin</code> <code>Optional[float]</code> <p>The minimum value for the color scale. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>Optional[float]</code> <p>The maximum value for the color scale. Defaults to None.</p> <code>None</code> <code>return_cmap</code> <code>bool</code> <p>Whether to return the colormap. Defaults to False.</p> <code>False</code> <code>distance_scale</code> <code>float</code> <p>The distance scale for rendering. Defaults to 10.</p> <code>10</code> <code>background</code> <code>tuple</code> <p>The background color. Defaults to (0, 0, 0, 0).</p> <code>(0, 0, 0, 0)</code> <code>width</code> <code>int</code> <p>The width of the rendered image. Defaults to 512.</p> <code>512</code> <code>height</code> <code>int</code> <p>The height of the rendered image. Defaults to 512.</p> <code>512</code> <code>alpha_func</code> <code>str</code> <p>The alpha function. Defaults to \"zigzag\".</p> <code>'zigzag'</code> <code>gamma_correction</code> <code>float</code> <p>The gamma correction factor. Defaults to 2.4.</p> <code>2.4</code> <code>**kwargs</code> <p>Additional keyword arguments for the plot.</p> <code>{}</code> Source code in <code>torchfsm/plot.py</code> <pre><code>def plot_3D_field(\n    ax: plt.Axes,\n    data: Union[np.ndarray, torch.Tensor],\n    bottom_label: Optional[str] = None,\n    left_label: Optional[str] = None,\n    title: Optional[str] = None,\n    title_loc=\"center\",\n    aspect=\"auto\",\n    cmap: Union[str, Colormap] = \"coolwarm\",\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    return_cmap: bool = False,\n    distance_scale: float = 10,\n    background=(0, 0, 0, 0),\n    width=512,\n    height=512,\n    alpha_func: Literal[\"zigzag\", \"diverging\", \"linear\"] = \"zigzag\",\n    gamma_correction: float = 2.4,\n    **kwargs\n):\n    \"\"\"\n    Plot a 3D field.\n    Powered by https://github.com/KeKsBoTer/vape4d\n\n    Args:\n        ax (plt.Axes): The axes to plot on.\n        data (Union[np.ndarray, torch.Tensor]): The data to plot.\n        bottom_label (Optional[str], optional): The label for the bottom axis. Defaults to None.\n        left_label (Optional[str], optional): The label for the left axis. Defaults to None.\n        title (Optional[str], optional): The title of the plot. Defaults to None.\n        title_loc (str, optional): The location of the title. Defaults to \"center\".\n        aspect (str, optional): The aspect ratio. Defaults to \"auto\".\n        cmap (Union[str, Colormap], optional): The colormap to use. Defaults to \"coolwarm\".\n        vmin (Optional[float], optional): The minimum value for the color scale. Defaults to None.\n        vmax (Optional[float], optional): The maximum value for the color scale. Defaults to None.\n        return_cmap (bool, optional): Whether to return the colormap. Defaults to False.\n        distance_scale (float, optional): The distance scale for rendering. Defaults to 10.\n        background (tuple, optional): The background color. Defaults to (0, 0, 0, 0).\n        width (int, optional): The width of the rendered image. Defaults to 512.\n        height (int, optional): The height of the rendered image. Defaults to 512.\n        alpha_func (str, optional): The alpha function. Defaults to \"zigzag\".\n        gamma_correction (float, optional): The gamma correction factor. Defaults to 2.4.\n        **kwargs: Additional keyword arguments for the plot.\n    \"\"\"\n    if isinstance(data, torch.Tensor):\n        data = data.detach().cpu().numpy()\n    elif not isinstance(data, np.ndarray):\n        data = np.asarray(data)\n    if len(data.shape) == 3:\n        data = np.expand_dims(data, 0)\n    elif not (len(data.shape) == 4 and data.shape[0] == 1):\n        raise ValueError(\"Only support 3D data with shape of [X,Y,Z] or [1,X,Y,Z].\")\n    img = _render(\n        data,\n        cmap,\n        vmin,\n        vmax,\n        distance_scale,\n        background,\n        width,\n        height,\n        alpha_func,\n        gamma_correction,\n        **kwargs\n    )\n    im = _plot_3D_field(\n        ax,\n        img,\n        bottom_label=bottom_label,\n        left_label=left_label,\n        title=title,\n        title_loc=title_loc,\n        aspect=aspect,\n    )\n    if return_cmap:\n        return im, cmap\n    return im\n</code></pre>"},{"location":"apis/plot/#torchfsm.plot.plot_traj","title":"torchfsm.plot.plot_traj","text":"<pre><code>plot_traj(\n    traj: Union[\n        SpatialTensor[\"B T C H ...\"],\n        Annotated[ndarray, \"Spatial, B T C H ...\"],\n    ],\n    channel_names: Optional[Sequence[str]] = None,\n    batch_names: Optional[Sequence[str]] = None,\n    vmin: Union[float, Sequence[Optional[float]]] = None,\n    vmax: Union[float, Sequence[Optional[float]]] = None,\n    subfig_size: float = 3.5,\n    x_space: float = 0.7,\n    y_space: float = 0.1,\n    cbar_pad: float = 0.1,\n    aspect: Literal[\"auto\", \"equal\"] = \"auto\",\n    num_colorbar_value: int = 4,\n    ctick_format: Optional[str] = \"%.1f\",\n    show_ticks: Union[Literal[\"auto\"], bool] = \"auto\",\n    show_time_index: bool = True,\n    use_sym_colormap: bool = True,\n    cmap: Union[str, Colormap] = \"coolwarm\",\n    ticks_t: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_x: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_y: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_z: Tuple[Sequence[float], Sequence[str]] = None,\n    animation: bool = True,\n    fps=30,\n    show_in_notebook: bool = True,\n    animation_engine: Literal[\"jshtml\", \"html5\"] = \"html5\",\n    save_name: Optional[str] = None,\n    **kwargs\n)\n</code></pre> <p>Plot a trajectory. The dimension of the trajectory can be 1D, 2D, or 3D.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>Union[SpatialTensor[\"B T C H ...], Annotated[np.ndarray, \"Spatial, B T C H ...\"]]</code> <p>The trajectory to plot.</p> required <code>channel_names</code> <code>Optional[Sequence[str]]</code> <p>The names of the channels. Defaults to None.</p> <code>None</code> <code>batch_names</code> <code>Optional[Sequence[str]]</code> <p>The names of the batches. Defaults to None.</p> <code>None</code> <code>vmin</code> <code>Union[float, Sequence[Optional[float]]]</code> <p>The minimum value for the color scale. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>Union[float, Sequence[Optional[float]]]</code> <p>The maximum value for the color scale. Defaults to None.</p> <code>None</code> <code>subfig_size</code> <code>float</code> <p>The size of the subfigures. Defaults to 3.5.</p> <code>3.5</code> <code>x_space</code> <code>float</code> <p>The space between subfigures in the x direction. Defaults to 0.7.</p> <code>0.7</code> <code>y_space</code> <code>float</code> <p>The space between subfigures in the y direction. Defaults to 0.1.</p> <code>0.1</code> <code>cbar_pad</code> <code>float</code> <p>The padding for the colorbar. Defaults to 0.1.</p> <code>0.1</code> <code>aspect</code> <code>Literal['auto', 'equal']</code> <p>The aspect ratio. Defaults to \"auto\".</p> <code>'auto'</code> <code>num_colorbar_value</code> <code>int</code> <p>The number of values for the colorbar. Defaults to 4.</p> <code>4</code> <code>ctick_format</code> <code>Optional[str]</code> <p>The format for the colorbar ticks. Defaults to \"%.1f\".</p> <code>'%.1f'</code> <code>show_ticks</code> <code>Union[Literal['auto'], bool]</code> <p>Whether to show ticks. Defaults to \"auto\".</p> <code>'auto'</code> <code>show_time_index</code> <code>bool</code> <p>Whether to show time index in the title. Defaults to True.</p> <code>True</code> <code>use_sym_colormap</code> <code>bool</code> <p>Whether to use a symmetric colormap. Defaults to True.</p> <code>True</code> <code>cmap</code> <code>Union[str, Colormap]</code> <p>The colormap to use. Defaults to \"coolwarm\".</p> <code>'coolwarm'</code> <code>ticks_t</code> <code>Tuple[Sequence[float], Sequence[str]]</code> <p>Custom ticks for the t-axis. Defaults to None.</p> <code>None</code> <code>ticks_x</code> <code>Tuple[Sequence[float], Sequence[str]]</code> <p>Custom ticks for the x-axis. Defaults to None.</p> <code>None</code> <code>ticks_y</code> <code>Tuple[Sequence[float], Sequence[str]]</code> <p>Custom ticks for the y-axis. Defaults to None.</p> <code>None</code> <code>ticks_z</code> <code>Tuple[Sequence[float], Sequence[str]]</code> <p>Custom ticks for the z-axis. Defaults to None.</p> <code>None</code> <code>animation</code> <code>bool</code> <p>Whether to animate the plot. Defaults to True This only works for 1D and 2D data. If set to False, the 1d trajectory will be plotted as a 2D plot and the 2D trajectory will be plotted as a 3D plot.</p> <code>True</code> <code>fps</code> <code>int</code> <p>The frames per second for the animation. Defaults to 30.</p> <code>30</code> <code>show_in_notebook</code> <code>bool</code> <p>Whether to show the plot in a notebook. Defaults to True.</p> <code>True</code> <code>animation_engine</code> <code>Literal['jshtml', 'html5']</code> <p>The engine for the animation. Defaults to \"html5\".</p> <code>'html5'</code> <code>save_name</code> <code>Optional[str]</code> <p>The name of the file to save the plot. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the plot.</p> <code>{}</code> Source code in <code>torchfsm/plot.py</code> <pre><code>def plot_traj(\n    traj: Union[\n        SpatialTensor[\"B T C H ...\"], Annotated[np.ndarray, \"Spatial, B T C H ...\"]\n    ],\n    channel_names: Optional[Sequence[str]] = None,\n    batch_names: Optional[Sequence[str]] = None,\n    vmin: Union[float, Sequence[Optional[float]]] = None,\n    vmax: Union[float, Sequence[Optional[float]]] = None,\n    subfig_size: float = 3.5,\n    x_space: float = 0.7,\n    y_space: float = 0.1,\n    cbar_pad: float = 0.1,\n    aspect: Literal[\"auto\", \"equal\"] = \"auto\",\n    num_colorbar_value: int = 4,\n    ctick_format: Optional[str] = \"%.1f\",\n    show_ticks: Union[Literal[\"auto\"], bool] = \"auto\",\n    show_time_index: bool = True,\n    use_sym_colormap: bool = True,\n    cmap: Union[str, Colormap] = \"coolwarm\",\n    ticks_t: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_x: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_y: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_z: Tuple[Sequence[float], Sequence[str]] = None,\n    animation: bool = True,\n    fps=30,\n    show_in_notebook: bool = True,\n    animation_engine: Literal[\"jshtml\", \"html5\"] = \"html5\",\n    save_name: Optional[str] = None,\n    **kwargs\n):\n    \"\"\"\n    Plot a trajectory. The dimension of the trajectory can be 1D, 2D, or 3D.\n\n    Args:\n        traj (Union[SpatialTensor[\"B T C H ...], Annotated[np.ndarray, \"Spatial, B T C H ...\"]]): The trajectory to plot.\n        channel_names (Optional[Sequence[str]], optional): The names of the channels. Defaults to None.\n        batch_names (Optional[Sequence[str]], optional): The names of the batches. Defaults to None.\n        vmin (Union[float, Sequence[Optional[float]]], optional): The minimum value for the color scale. Defaults to None.\n        vmax (Union[float, Sequence[Optional[float]]], optional): The maximum value for the color scale. Defaults to None.\n        subfig_size (float, optional): The size of the subfigures. Defaults to 3.5.\n        x_space (float, optional): The space between subfigures in the x direction. Defaults to 0.7.\n        y_space (float, optional): The space between subfigures in the y direction. Defaults to 0.1.\n        cbar_pad (float, optional): The padding for the colorbar. Defaults to 0.1.\n        aspect (Literal[\"auto\", \"equal\"], optional): The aspect ratio. Defaults to \"auto\".\n        num_colorbar_value (int, optional): The number of values for the colorbar. Defaults to 4.\n        ctick_format (Optional[str], optional): The format for the colorbar ticks. Defaults to \"%.1f\".\n        show_ticks (Union[Literal[\"auto\"], bool], optional): Whether to show ticks. Defaults to \"auto\".\n        show_time_index (bool, optional): Whether to show time index in the title. Defaults to True.\n        use_sym_colormap (bool, optional): Whether to use a symmetric colormap. Defaults to True.\n        cmap (Union[str, Colormap], optional): The colormap to use. Defaults to \"coolwarm\".\n        ticks_t (Tuple[Sequence[float], Sequence[str]], optional): Custom ticks for the t-axis. Defaults to None.\n        ticks_x (Tuple[Sequence[float], Sequence[str]], optional): Custom ticks for the x-axis. Defaults to None.\n        ticks_y (Tuple[Sequence[float], Sequence[str]], optional): Custom ticks for the y-axis. Defaults to None.\n        ticks_z (Tuple[Sequence[float], Sequence[str]], optional): Custom ticks for the z-axis. Defaults to None.\n        animation (bool, optional): Whether to animate the plot. Defaults to True\n            This only works for 1D and 2D data. If set to False, the 1d trajectory will be plotted as a 2D plot and the 2D trajectory will be plotted as a 3D plot.\n        fps (int, optional): The frames per second for the animation. Defaults to 30.\n        show_in_notebook (bool, optional): Whether to show the plot in a notebook. Defaults to True.\n        animation_engine (Literal[\"jshtml\", \"html5\"], optional): The engine for the animation. Defaults to \"html5\".\n        save_name (Optional[str], optional): The name of the file to save the plot. Defaults to None.\n        **kwargs: Additional keyword arguments for the plot.\n    \"\"\"\n\n    if isinstance(traj, torch.Tensor):\n        traj = traj.cpu().detach().numpy()\n    n_batch, n_frame, n_channel = traj.shape[0], traj.shape[1], traj.shape[2]\n    n_dim = len(traj.shape) - 3\n    channel_names = default(\n        channel_names, [\"channel {}\".format(i) for i in range(n_channel)]\n    )\n    batch_names = default(batch_names, [\"batch {}\".format(i) for i in range(n_batch)])\n    if len(channel_names) != n_channel:\n        raise ValueError(\n            \"The number of channel names should be equal to the number of channels in the input trajectory.\"\n        )\n    if len(batch_names) != n_batch:\n        raise ValueError(\n            \"The number of batch names should be equal to the number of batches in the input trajectory.\"\n        )\n    vmins, vmaxs = _find_min_max(traj, vmin, vmax)\n    if n_batch == 1:\n        cbar_location = \"right\"\n        cbar_mode = \"each\"\n        ticklocation = \"right\"\n    else:\n        cbar_location = \"top\"\n        cbar_mode = \"edge\"\n        ticklocation = \"top\"\n    cmaps = [\n        sym_colormap(vmins[i], vmaxs[i], cmap=cmap) if use_sym_colormap else cmap\n        for i in range(n_channel)\n    ]\n    if show_ticks == \"auto\":\n        show_ticks = True if (n_dim == 1 and animation) else False\n    subfig_h = subfig_size\n    if n_dim == 1:\n        if not animation:\n            subfig_w = subfig_size * n_frame / traj.shape[-1]\n        else:\n            subfig_w = subfig_size * 2\n            cbar_mode = None\n    elif n_dim == 2:\n        subfig_w = subfig_size * traj.shape[-2] / traj.shape[-1]\n    elif n_dim == 3:\n        h = traj.shape[-3] + traj.shape[-3]\n        w = traj.shape[-2] + traj.shape[-1]\n        subfig_w = subfig_size * w / h\n        if (\n            ticks_x is not None\n            or ticks_y is not None\n            or ticks_z is not None\n            or show_ticks\n        ):\n            warn(\"Ticks are not supported for 3D trajectories.\")\n        cmaps = [diverging_alpha(cmap) for cmap in cmaps]\n    else:\n        raise ValueError(\"Only support 1D, 2D, and 3D trajectories.\")\n    fig = plt.figure(figsize=(subfig_w * n_channel, subfig_h * n_batch))\n    # fig=plt.figure()\n    grid = ImageGrid(\n        fig,\n        111,\n        nrows_ncols=(n_batch, n_channel),\n        axes_pad=(x_space, y_space),\n        share_all=True,\n        cbar_location=cbar_location,\n        cbar_mode=cbar_mode,\n        direction=\"row\",\n        cbar_pad=cbar_pad,\n        aspect=False,\n    )\n\n    def set_colorbar():\n        for i in range(n_channel):\n            cb = grid.cbar_axes[i].colorbar(\n                mlp.cm.ScalarMappable(\n                    colors.Normalize(vmin=vmins[i], vmax=vmaxs[i]), cmap=cmaps[i]\n                ),\n                ticklocation=ticklocation,\n                label=channel_names[i],\n                format=ctick_format,\n            )\n            cb.ax.minorticks_on()\n            cb.set_ticks(\n                np.linspace(vmins[i], vmaxs[i], num_colorbar_value, endpoint=True)\n            )\n\n    def title_t(i):\n        if show_time_index:\n            if ticks_t is not None:\n                if i in ticks_t[0]:\n                    fig.suptitle(\"t={}\".format(ticks_t[1][i]))\n            else:\n                fig.suptitle(\"t={}\".format(i))\n\n    if n_dim == 1:\n        if animation:\n\n            def ani_func(i):\n                for j, ax_j in enumerate(grid):\n                    ax_j.clear()\n                    data_i, x_label, y_label, i_column, i_row = _data_plot(\n                        j,\n                        traj,\n                        n_dim,\n                        n_channel,\n                        n_batch,\n                        channel_names,\n                        batch_names,\n                        animation=animation,\n                    )\n                    plot_1D_field(\n                        ax=ax_j,\n                        data=data_i[i],\n                        show_ticks=show_ticks,\n                        x_label=x_label,\n                        y_label=y_label,\n                        ticks_x=ticks_t,\n                        ticks_y=ticks_x,\n                        vmin=vmins[i_column],\n                        vmax=vmaxs[i_column],\n                        **kwargs\n                    )\n                title_t(i)\n\n        else:\n            for i, ax_i in enumerate(grid):\n                data_i, x_label, y_label, i_column, i_row = _data_plot(\n                    i,\n                    traj,\n                    n_dim,\n                    n_channel,\n                    n_batch,\n                    channel_names,\n                    batch_names,\n                    animation=animation,\n                )\n                plot_2D_field(\n                    ax=ax_i,\n                    data=data_i,\n                    show_ticks=show_ticks,\n                    x_label=x_label,\n                    y_label=y_label,\n                    cmap=cmaps[i_column],\n                    vmin=vmins[i_column],\n                    vmax=vmaxs[i_column],\n                    ticks_x=ticks_t,\n                    ticks_y=ticks_x,\n                    aspect=aspect,\n                    **kwargs\n                )\n            set_colorbar()\n            if save_name is not None:\n                plt.savefig(save_name)\n            plt.show()\n            return None\n    elif n_dim == 2:\n        if animation:\n\n            def ani_func(i):\n                for j, ax_j in enumerate(grid):\n                    ax_j.clear()\n                    data_j, x_label, y_label, j_column, j_row = _data_plot(\n                        j,\n                        traj,\n                        n_dim,\n                        n_channel,\n                        n_batch,\n                        channel_names,\n                        batch_names,\n                        animation=animation,\n                    )\n                    plot_2D_field(\n                        ax=ax_j,\n                        data=data_j[i],\n                        show_ticks=show_ticks,\n                        x_label=x_label,\n                        y_label=y_label,\n                        cmap=cmaps[j_column],\n                        vmin=vmins[j_column],\n                        vmax=vmaxs[j_column],\n                        ticks_x=ticks_x,\n                        ticks_y=ticks_y,\n                        aspect=aspect,\n                        **kwargs\n                    )\n                set_colorbar()\n                title_t(i)\n\n        else:\n            for i, ax_i in enumerate(grid):\n                data_i, x_label, y_label, i_column, i_row = _data_plot(\n                    i,\n                    traj,\n                    n_dim,\n                    n_channel,\n                    n_batch,\n                    channel_names,\n                    batch_names,\n                    animation=animation,\n                )\n                plot_3D_field(\n                    ax=ax_i,\n                    data=data_i,\n                    bottom_label=x_label,\n                    left_label=y_label,\n                    aspect=aspect,\n                    cmap=cmaps[i_column],\n                    **kwargs\n                )\n            if save_name is not None:\n                plt.savefig(save_name)\n            set_colorbar()\n            plt.show()\n            return None\n    elif n_dim == 3:\n        imgs = []\n        if n_frame == 1:\n            t = [0, 1]\n        else:\n            t = np.linspace(0, 1, n_frame)\n        for b in range(n_batch):\n            for c in range(n_channel):\n                imgs.append(\n                    _render(\n                        traj[b, :, c, ...].astype(np.float32),\n                        cmaps[c],\n                        time=t,\n                        **kwargs\n                    )\n                )\n\n        def ani_func(i):\n            for j, ax_j in enumerate(grid):\n                ax_j.clear()\n                _, x_label, y_label, i_column, i_row = _data_plot(\n                    j, traj, n_dim, n_channel, n_batch, channel_names, batch_names\n                )\n                _plot_3D_field(\n                    ax_j,\n                    imgs[j][i],\n                    bottom_label=x_label,\n                    left_label=y_label,\n                    aspect=aspect,\n                    **kwargs\n                )\n            title_t(i)\n            set_colorbar()\n\n    if n_frame != 1:\n        ani = FuncAnimation(\n            fig, ani_func, frames=n_frame, repeat=False, interval=1000 / fps\n        )\n        if show_in_notebook:\n            plt.close()\n            if animation_engine == \"jshtml\":\n                return HTML(ani.to_jshtml())\n            elif animation_engine == \"html5\":\n                try:\n                    return HTML(ani.to_html5_video())\n                except Exception as e:\n                    warn_msg = (\n                        \"Error occurs when generating html5 video, use jshtml instead.\"\n                        + os.linesep\n                    )\n                    warn_msg += \"Error message: {}\".format(e) + os.linesep\n                    warn_msg += (\n                        \"This is probably due to the `ffmpeg` is not properly installed.\"\n                        + os.linesep\n                    )\n                    warn_msg += \"Please install `ffmpeg` and try again.\" + os.linesep\n                    warn(warn_msg)\n                    return HTML(ani.to_jshtml())\n            else:\n                raise ValueError(\"The animation engine should be 'jshtml' or 'html5'.\")\n        else:\n            return ani\n    else:\n        ani_func(0)\n        if save_name is not None:\n            plt.savefig(save_name)\n        plt.show()\n</code></pre>"},{"location":"apis/plot/#torchfsm.plot.plot_field","title":"torchfsm.plot.plot_field","text":"<pre><code>plot_field(\n    field: Union[\n        SpatialTensor[\"B C H ...\"],\n        Annotated[ndarray, \"Spatial, B C H ...\"],\n    ],\n    channel_names: Optional[Sequence[str]] = None,\n    batch_names: Optional[Sequence[str]] = None,\n    vmin: Union[float, Sequence[Optional[float]]] = None,\n    vmax: Union[float, Sequence[Optional[float]]] = None,\n    subfig_size: float = 3.5,\n    x_space: float = 0.7,\n    y_space: float = 0.1,\n    cbar_pad: float = 0.1,\n    aspect: Literal[\"auto\", \"equal\"] = \"auto\",\n    num_colorbar_value: int = 4,\n    ctick_format: Optional[str] = \"%.1f\",\n    show_ticks: Union[Literal[\"auto\"], bool] = \"auto\",\n    use_sym_colormap: bool = True,\n    cmap: Union[str, Colormap] = \"coolwarm\",\n    ticks_x: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_y: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_z: Tuple[Sequence[float], Sequence[str]] = None,\n    save_name: Optional[str] = None,\n    **kwargs\n)\n</code></pre> <p>Plot a field. The dimension of the field can be 1D, 2D, or 3D.</p> <p>Parameters:</p> Name Type Description Default <code>field</code> <code>Union[SpatialTensor[\"B C H ...], Annotated[np.ndarray, \"Spatial, B C H ...\"]]</code> <p>The field to plot.</p> required <code>channel_names</code> <code>Optional[Sequence[str]]</code> <p>The names of the channels. Defaults to None.</p> <code>None</code> <code>batch_names</code> <code>Optional[Sequence[str]]</code> <p>The names of the batches. Defaults to None.</p> <code>None</code> <code>vmin</code> <code>Union[float, Sequence[Optional[float]]]</code> <p>The minimum value for the color scale. Defaults to None.</p> <code>None</code> <code>vmax</code> <code>Union[float, Sequence[Optional[float]]]</code> <p>The maximum value for the color scale. Defaults to None.</p> <code>None</code> <code>subfig_size</code> <code>float</code> <p>The size of the subfigures. Defaults to 3.5.</p> <code>3.5</code> <code>x_space</code> <code>float</code> <p>The space between subfigures in the x direction. Defaults to 0.7.</p> <code>0.7</code> <code>y_space</code> <code>float</code> <p>The space between subfigures in the y direction. Defaults to 0.1.</p> <code>0.1</code> <code>cbar_pad</code> <code>float</code> <p>The padding for the colorbar. Defaults to 0.1.</p> <code>0.1</code> <code>aspect</code> <code>Literal['auto', 'equal']</code> <p>The aspect ratio. Defaults to \"auto\".</p> <code>'auto'</code> <code>num_colorbar_value</code> <code>int</code> <p>The number of values for the colorbar. Defaults to 4.</p> <code>4</code> <code>ctick_format</code> <code>Optional[str]</code> <p>The format for the colorbar ticks. Defaults to \"%.1f\".</p> <code>'%.1f'</code> <code>show_ticks</code> <code>Union[Literal['auto'], bool]</code> <p>Whether to show ticks. Defaults to \"auto\".</p> <code>'auto'</code> <code>use_sym_colormap</code> <code>bool</code> <p>Whether to use a symmetric colormap. Defaults to True.</p> <code>True</code> <code>cmap</code> <code>Union[str, Colormap]</code> <p>The colormap to use. Defaults to \"coolwarm\".</p> <code>'coolwarm'</code> <code>ticks_x</code> <code>Tuple[Sequence[float], Sequence[str]]</code> <p>Custom ticks for the x-axis. Defaults to None.</p> <code>None</code> <code>ticks_y</code> <code>Tuple[Sequence[float], Sequence[str]]</code> <p>Custom ticks for the y-axis. Defaults to None.</p> <code>None</code> <code>ticks_z</code> <code>Tuple[Sequence[float], Sequence[str]]</code> <p>Custom ticks for the z-axis. Defaults to None.</p> <code>None</code> <code>save_name</code> <code>Optional[str]</code> <p>The name of the file to save the plot. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the plot.</p> <code>{}</code> Source code in <code>torchfsm/plot.py</code> <pre><code>def plot_field(\n    field: Union[\n        SpatialTensor[\"B C H ...\"], Annotated[np.ndarray, \"Spatial, B C H ...\"]\n    ],\n    channel_names: Optional[Sequence[str]] = None,\n    batch_names: Optional[Sequence[str]] = None,\n    vmin: Union[float, Sequence[Optional[float]]] = None,\n    vmax: Union[float, Sequence[Optional[float]]] = None,\n    subfig_size: float = 3.5,\n    x_space: float = 0.7,\n    y_space: float = 0.1,\n    cbar_pad: float = 0.1,\n    aspect: Literal[\"auto\", \"equal\"] = \"auto\",\n    num_colorbar_value: int = 4,\n    ctick_format: Optional[str] = \"%.1f\",\n    show_ticks: Union[Literal[\"auto\"], bool] = \"auto\",\n    use_sym_colormap: bool = True,\n    cmap: Union[str, Colormap] = \"coolwarm\",\n    ticks_x: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_y: Tuple[Sequence[float], Sequence[str]] = None,\n    ticks_z: Tuple[Sequence[float], Sequence[str]] = None,\n    save_name: Optional[str] = None,\n    **kwargs\n):\n    \"\"\"\n    Plot a field. The dimension of the field can be 1D, 2D, or 3D.\n\n    Args:\n        field (Union[SpatialTensor[\"B C H ...], Annotated[np.ndarray, \"Spatial, B C H ...\"]]): The field to plot.\n        channel_names (Optional[Sequence[str]], optional): The names of the channels. Defaults to None.\n        batch_names (Optional[Sequence[str]], optional): The names of the batches. Defaults to None.\n        vmin (Union[float, Sequence[Optional[float]]], optional): The minimum value for the color scale. Defaults to None.\n        vmax (Union[float, Sequence[Optional[float]]], optional): The maximum value for the color scale. Defaults to None.\n        subfig_size (float, optional): The size of the subfigures. Defaults to 3.5.\n        x_space (float, optional): The space between subfigures in the x direction. Defaults to 0.7.\n        y_space (float, optional): The space between subfigures in the y direction. Defaults to 0.1.\n        cbar_pad (float, optional): The padding for the colorbar. Defaults to 0.1.\n        aspect (Literal[\"auto\", \"equal\"], optional): The aspect ratio. Defaults to \"auto\".\n        num_colorbar_value (int, optional): The number of values for the colorbar. Defaults to 4.\n        ctick_format (Optional[str], optional): The format for the colorbar ticks. Defaults to \"%.1f\".\n        show_ticks (Union[Literal[\"auto\"], bool], optional): Whether to show ticks. Defaults to \"auto\".\n        use_sym_colormap (bool, optional): Whether to use a symmetric colormap. Defaults to True.\n        cmap (Union[str, Colormap], optional): The colormap to use. Defaults to \"coolwarm\".\n        ticks_x (Tuple[Sequence[float], Sequence[str]], optional): Custom ticks for the x-axis. Defaults to None.\n        ticks_y (Tuple[Sequence[float], Sequence[str]], optional): Custom ticks for the y-axis. Defaults to None.\n        ticks_z (Tuple[Sequence[float], Sequence[str]], optional): Custom ticks for the z-axis. Defaults to None.\n        save_name (Optional[str], optional): The name of the file to save the plot. Defaults to None.\n        **kwargs: Additional keyword arguments for the plot.\n    \"\"\"\n\n    if isinstance(field, torch.Tensor):\n        field = field.cpu().detach().numpy()\n    field = np.expand_dims(field, 1)\n    plot_traj(\n        field,\n        channel_names=channel_names,\n        batch_names=batch_names,\n        vmin=vmin,\n        vmax=vmax,\n        subfig_size=subfig_size,\n        x_space=x_space,\n        y_space=y_space,\n        cbar_pad=cbar_pad,\n        aspect=aspect,\n        num_colorbar_value=num_colorbar_value,\n        ctick_format=ctick_format,\n        show_ticks=show_ticks,\n        use_sym_colormap=use_sym_colormap,\n        cmap=cmap,\n        ticks_x=ticks_x,\n        ticks_y=ticks_y,\n        ticks_z=ticks_z,\n        animation=True,\n        show_time_index=False,\n        save_name=save_name,\n        **kwargs\n    )\n</code></pre>"},{"location":"apis/traj_recorder/","title":"7. traj_recorder","text":""},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.IntervalController","title":"torchfsm.traj_recorder.IntervalController","text":"<p>A class to control the recording of trajectories at specified intervals.     This class can be used as an input for the <code>control_func</code> parameters of recorder objects.</p> <p>Parameters:</p> Name Type Description Default <code>interval</code> <code>int</code> <p>The interval at which to record the trajectory.</p> <code>1</code> <code>start</code> <code>int</code> <p>The step at which to start recording the trajectory.</p> <code>0</code> Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>class IntervalController():\n    \"\"\"\n    A class to control the recording of trajectories at specified intervals.\n        This class can be used as an input for the `control_func` parameters of recorder objects.\n\n    Args:\n        interval (int): The interval at which to record the trajectory.\n        start (int): The step at which to start recording the trajectory.\n    \"\"\"\n\n    def __init__(self,interval:int=1,start:int=0,) -&gt; None:\n        self.start=start\n        self.interval=interval\n\n    def __call__(self, step:int) -&gt; bool:\n        return step&gt;=self.start and (step-self.start)%self.interval==0\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.IntervalController.start","title":"start  <code>instance-attribute</code>","text":"<pre><code>start = start\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.IntervalController.interval","title":"interval  <code>instance-attribute</code>","text":"<pre><code>interval = interval\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.IntervalController.__init__","title":"__init__","text":"<pre><code>__init__(interval: int = 1, start: int = 0) -&gt; None\n</code></pre> Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>def __init__(self,interval:int=1,start:int=0,) -&gt; None:\n    self.start=start\n    self.interval=interval\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.IntervalController.__call__","title":"__call__","text":"<pre><code>__call__(step: int) -&gt; bool\n</code></pre> Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>def __call__(self, step:int) -&gt; bool:\n    return step&gt;=self.start and (step-self.start)%self.interval==0\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder._TrajRecorder","title":"torchfsm.traj_recorder._TrajRecorder","text":"<p>A base class for trajectory recorders.     A recorder is an object that helps to control the recording of trajectories during a simulation</p> <p>Parameters:</p> Name Type Description Default <code>control_func</code> <code>Optional[Callable[[int], bool]]</code> <p>A function that takes a step as input and returns a boolean indicating whether to record the trajectory at that step.</p> <code>None</code> <code>include_initial_state</code> <code>bool</code> <p>If True, the initial state will be included in the trajectory.</p> <code>True</code> Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>class _TrajRecorder():\n\n    \"\"\"\n    A base class for trajectory recorders.\n        A recorder is an object that helps to control the recording of trajectories during a simulation\n\n    Args:\n        control_func (Optional[Callable[[int],bool]]): A function that takes a step as input and returns a boolean indicating whether to record the trajectory at that step.\n        include_initial_state (bool): If True, the initial state will be included in the trajectory.\n    \"\"\"\n\n    def __init__(self,\n                 control_func:Optional[Callable[[int],bool]]=None,\n                 include_initial_state:bool=True,\n                 ):\n        control_func=default(control_func,lambda step: True)\n        if include_initial_state:\n            self.control_func=control_func\n        else:\n            self.control_func=lambda step: False if step==0 else control_func(step)\n        self.return_in_fourier=False\n\n    def record(self,step:int,frame:torch.tensor):\n        \"\"\"\n        Record the trajectory at a given step.\n\n        Args:\n            step (int): The current step.\n            frame (torch.tensor): The current frame to be recorded.\n        \"\"\"\n        if self.control_func(step):\n            self._record(step,frame)\n\n    def _record(self,step:int,frame:torch.tensor):\n        \"\"\"\n        Record the trajectory at a given step.\n            This method should be implemented by subclasses.\n\n        Args:\n            step (int): The current step.\n            frame (torch.tensor): The current frame to be recorded.\n        \"\"\"\n        raise NotImplementedError\n\n    def _traj_ifft(self,trajectory:torch.tensor):\n        \"\"\"\n        Perform an inverse FFT on the trajectory.\n\n        Args:\n            trajectory (torch.tensor): The trajectory to be transformed.\n\n        Returns:\n            torch.tensor: The transformed trajectory.\n        \"\"\"\n        fft_dim=tuple(-1*(i+1) for i in range(len(trajectory.shape)-3))\n        return torch.fft.ifftn(trajectory,dim=fft_dim)\n\n    @property\n    def trajectory(self):\n        \"\"\"\n        Get the recorded trajectory.\n            This method should be implemented by subclasses.\n\n        Args:\n            return_in_fourier (bool): If True, return the trajectory in Fourier space. Default is False.\n\n        Returns:\n            torch.tensor: The recorded trajectory.\n        \"\"\"\n        raise NotImplementedError\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder._TrajRecorder.control_func","title":"control_func  <code>instance-attribute</code>","text":"<pre><code>control_func = control_func\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder._TrajRecorder.return_in_fourier","title":"return_in_fourier  <code>instance-attribute</code>","text":"<pre><code>return_in_fourier = False\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder._TrajRecorder.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory\n</code></pre> <p>Get the recorded trajectory.     This method should be implemented by subclasses.</p> <p>Parameters:</p> Name Type Description Default <code>return_in_fourier</code> <code>bool</code> <p>If True, return the trajectory in Fourier space. Default is False.</p> required <p>Returns:</p> Type Description <p>torch.tensor: The recorded trajectory.</p>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder._TrajRecorder.__init__","title":"__init__","text":"<pre><code>__init__(\n    control_func: Optional[Callable[[int], bool]] = None,\n    include_initial_state: bool = True,\n)\n</code></pre> Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>def __init__(self,\n             control_func:Optional[Callable[[int],bool]]=None,\n             include_initial_state:bool=True,\n             ):\n    control_func=default(control_func,lambda step: True)\n    if include_initial_state:\n        self.control_func=control_func\n    else:\n        self.control_func=lambda step: False if step==0 else control_func(step)\n    self.return_in_fourier=False\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder._TrajRecorder.record","title":"record","text":"<pre><code>record(step: int, frame: tensor)\n</code></pre> <p>Record the trajectory at a given step.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>int</code> <p>The current step.</p> required <code>frame</code> <code>tensor</code> <p>The current frame to be recorded.</p> required Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>def record(self,step:int,frame:torch.tensor):\n    \"\"\"\n    Record the trajectory at a given step.\n\n    Args:\n        step (int): The current step.\n        frame (torch.tensor): The current frame to be recorded.\n    \"\"\"\n    if self.control_func(step):\n        self._record(step,frame)\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.AutoRecorder","title":"torchfsm.traj_recorder.AutoRecorder","text":"<p>               Bases: <code>_TrajRecorder</code></p> <p>A recorder that save the trajectory at the same devices as the simulation.</p> <p>Parameters:</p> Name Type Description Default <code>control_func</code> <code>Optional[Callable[[int], bool]]</code> <p>A function that takes a step as input and returns a boolean indicating whether to record the trajectory at that step.</p> <code>None</code> <code>include_initial_state</code> <code>bool</code> <p>If True, the initial state will be included in the trajectory.</p> <code>True</code> Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>class AutoRecorder(_TrajRecorder):\n\n    \"\"\"\n    A recorder that save the trajectory at the same devices as the simulation.\n\n    Args:\n        control_func (Optional[Callable[[int],bool]]): A function that takes a step as input and returns a boolean indicating whether to record the trajectory at that step.\n        include_initial_state (bool): If True, the initial state will be included in the trajectory.\n    \"\"\"\n\n    def __init__(self,\n                 control_func:Optional[Callable[[int],bool]]=None,\n                 include_initial_state:bool=True,\n                 ):\n        super().__init__(control_func,include_initial_state)\n        self._trajectory=[]\n\n    def _record(self,step:int,frame:torch.tensor):\n        if not isinstance(self._trajectory,torch.Tensor):\n            self._trajectory.append(copy.deepcopy(frame))\n        else:\n            raise RuntimeError(\"The trajectory has been finalized.\")\n\n    @property\n    def trajectory(self):\n        if len(self._trajectory)==0:\n            return None\n        if self.return_in_fourier:\n            return torch.stack(self._trajectory,dim=1)\n        else:\n            return self._traj_ifft(torch.stack(self._trajectory,dim=1)).real\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.AutoRecorder.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.AutoRecorder.control_func","title":"control_func  <code>instance-attribute</code>","text":"<pre><code>control_func = control_func\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.AutoRecorder.return_in_fourier","title":"return_in_fourier  <code>instance-attribute</code>","text":"<pre><code>return_in_fourier = False\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.AutoRecorder.__init__","title":"__init__","text":"<pre><code>__init__(\n    control_func: Optional[Callable[[int], bool]] = None,\n    include_initial_state: bool = True,\n)\n</code></pre> Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>def __init__(self,\n             control_func:Optional[Callable[[int],bool]]=None,\n             include_initial_state:bool=True,\n             ):\n    super().__init__(control_func,include_initial_state)\n    self._trajectory=[]\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.AutoRecorder.record","title":"record","text":"<pre><code>record(step: int, frame: tensor)\n</code></pre> <p>Record the trajectory at a given step.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>int</code> <p>The current step.</p> required <code>frame</code> <code>tensor</code> <p>The current frame to be recorded.</p> required Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>def record(self,step:int,frame:torch.tensor):\n    \"\"\"\n    Record the trajectory at a given step.\n\n    Args:\n        step (int): The current step.\n        frame (torch.tensor): The current frame to be recorded.\n    \"\"\"\n    if self.control_func(step):\n        self._record(step,frame)\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.CPURecorder","title":"torchfsm.traj_recorder.CPURecorder","text":"<p>               Bases: <code>AutoRecorder</code></p> <p>A recorder that saves the trajectory on the CPU memory.     This is useful for large trajectories that may not fit in GPU memory during simulation.</p> <p>Parameters:</p> Name Type Description Default <code>control_func</code> <code>Optional[Callable[[int], bool]]</code> <p>A function that takes a step as input and returns a boolean indicating whether to record the trajectory at that step.</p> <code>None</code> <code>include_initial_state</code> <code>bool</code> <p>If True, the initial state will be included in the trajectory.</p> <code>True</code> Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>class CPURecorder(AutoRecorder):\n\n    \"\"\"\n    A recorder that saves the trajectory on the CPU memory.\n        This is useful for large trajectories that may not fit in GPU memory during simulation.\n\n    Args:\n        control_func (Optional[Callable[[int],bool]]): A function that takes a step as input and returns a boolean indicating whether to record the trajectory at that step.\n        include_initial_state (bool): If True, the initial state will be included in the trajectory.\n    \"\"\"\n\n    def __init__(self,\n                 control_func:Optional[Callable[[int],bool]]=None,\n                 include_initial_state:bool=True\n                 ):\n        super().__init__(control_func,include_initial_state)\n\n    def _record(self,step:int,frame:torch.tensor):\n        if frame.is_cpu:\n            self._trajectory.append(copy.deepcopy(frame))\n        else:\n            self._trajectory.append(frame.cpu())\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.CPURecorder.control_func","title":"control_func  <code>instance-attribute</code>","text":"<pre><code>control_func = control_func\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.CPURecorder.return_in_fourier","title":"return_in_fourier  <code>instance-attribute</code>","text":"<pre><code>return_in_fourier = False\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.CPURecorder.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.CPURecorder.__init__","title":"__init__","text":"<pre><code>__init__(\n    control_func: Optional[Callable[[int], bool]] = None,\n    include_initial_state: bool = True,\n)\n</code></pre> Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>def __init__(self,\n             control_func:Optional[Callable[[int],bool]]=None,\n             include_initial_state:bool=True\n             ):\n    super().__init__(control_func,include_initial_state)\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.CPURecorder.record","title":"record","text":"<pre><code>record(step: int, frame: tensor)\n</code></pre> <p>Record the trajectory at a given step.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>int</code> <p>The current step.</p> required <code>frame</code> <code>tensor</code> <p>The current frame to be recorded.</p> required Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>def record(self,step:int,frame:torch.tensor):\n    \"\"\"\n    Record the trajectory at a given step.\n\n    Args:\n        step (int): The current step.\n        frame (torch.tensor): The current frame to be recorded.\n    \"\"\"\n    if self.control_func(step):\n        self._record(step,frame)\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.DiskRecorder","title":"torchfsm.traj_recorder.DiskRecorder","text":"<p>               Bases: <code>_TrajRecorder</code></p> <p>A recorder that saves the trajectory on the disk.     This is useful for large trajectories that may not fit in GPU memory during simulation.     The trajectory is saved in a temporary cache and then written to disk at specified intervals.</p> <p>Parameters:</p> Name Type Description Default <code>control_func</code> <code>Optional[Callable[[int], bool]]</code> <p>A function that takes a step as input and returns a boolean indicating whether to record the trajectory at that step.</p> <code>None</code> <code>include_initial_state</code> <code>bool</code> <p>If True, the initial state will be included in the trajectory.</p> <code>True</code> <code>cache_dir</code> <code>Optional[str]</code> <p>The directory where the trajectory will be saved. Default is \"./saved_traj/\".</p> <code>None</code> <code>cache_freq</code> <code>int</code> <p>The frequency at which to save the trajectory to disk. Default is 1.</p> <code>1</code> <code>temp_cache_loc</code> <code>Literal['auto', 'cpu']</code> <p>The location of the temporary cache. Default is \"cpu\".</p> <code>'cpu'</code> <code>save_format</code> <code>Literal['numpy', 'torch']</code> <p>The format in which to save the trajectory. Default is \"torch\".</p> <code>'torch'</code> Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>class DiskRecorder(_TrajRecorder):\n\n    \"\"\"\n    A recorder that saves the trajectory on the disk.\n        This is useful for large trajectories that may not fit in GPU memory during simulation.\n        The trajectory is saved in a temporary cache and then written to disk at specified intervals.\n\n    Args:\n        control_func (Optional[Callable[[int],bool]]): A function that takes a step as input and returns a boolean indicating whether to record the trajectory at that step.\n        include_initial_state (bool): If True, the initial state will be included in the trajectory.\n        cache_dir (Optional[str]): The directory where the trajectory will be saved. Default is \"./saved_traj/\".\n        cache_freq (int): The frequency at which to save the trajectory to disk. Default is 1.\n        temp_cache_loc (Literal[\"auto\",\"cpu\"]): The location of the temporary cache. Default is \"cpu\".\n        save_format (Literal[\"numpy\",\"torch\"]): The format in which to save the trajectory. Default is \"torch\".\n    \"\"\"\n\n    def __init__(self,\n                 control_func:Optional[Callable[[int],bool]]=None,\n                 include_initial_state:bool=True,\n                 cache_dir:Optional[str]=None,\n                 cache_freq:int=1,\n                 temp_cache_loc:Literal[\"auto\",\"cpu\"]=\"cpu\",\n                 save_format:Literal[\"numpy\",\"torch\"]=\"torch\",\n                 ):\n        super().__init__(control_func,include_initial_state)\n        self.cache_dir=default(cache_dir,\"./saved_traj/\")\n        self.cache_freq=cache_freq\n        self._trajectory=[]\n        self.temp_cache_loc=temp_cache_loc\n        if self.temp_cache_loc not in [\"auto\",\"cpu\"]:\n            raise ValueError(\"temp_cache_loc must be either 'auto' or 'cpu'.\")\n        self.save_format=save_format\n        if self.save_format not in [\"numpy\",\"torch\"]:\n            raise ValueError(\"save_format must be either 'numpy' or 'torch'.\")\n\n    def _record(self,step:int,frame:torch.tensor):\n        if len(self.traj&lt;self.cache_freq):    \n            if self.temp_cache_loc==\"cpu\" and not frame.is_cpu:\n                self._trajectory.append(frame.cpu())\n            else:\n                self._trajectory.append(copy.deepcopy(frame))\n        else:\n            temp_cache=torch.stack(self._trajectory,dim=1)\n            temp_cache=temp_cache.to(\"cpu\") if not temp_cache.is_cpu else temp_cache\n            if not self.return_in_fourier:\n                temp_cache=self._traj_ifft(temp_cache).real\n            if self.save_format==\"numpy\":\n                np.save(self.cache_dir+f\"temp_cache_{step}\",temp_cache.numpy()) \n            else:\n                torch.save(temp_cache,self.cache_dir+f\"temp_cache_{step}\")     \n            self._trajectory=[]      \n\n    @property\n    def trajectory(self):\n        return None\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.DiskRecorder.cache_dir","title":"cache_dir  <code>instance-attribute</code>","text":"<pre><code>cache_dir = default(cache_dir, './saved_traj/')\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.DiskRecorder.cache_freq","title":"cache_freq  <code>instance-attribute</code>","text":"<pre><code>cache_freq = cache_freq\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.DiskRecorder.temp_cache_loc","title":"temp_cache_loc  <code>instance-attribute</code>","text":"<pre><code>temp_cache_loc = temp_cache_loc\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.DiskRecorder.save_format","title":"save_format  <code>instance-attribute</code>","text":"<pre><code>save_format = save_format\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.DiskRecorder.trajectory","title":"trajectory  <code>property</code>","text":"<pre><code>trajectory\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.DiskRecorder.control_func","title":"control_func  <code>instance-attribute</code>","text":"<pre><code>control_func = control_func\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.DiskRecorder.return_in_fourier","title":"return_in_fourier  <code>instance-attribute</code>","text":"<pre><code>return_in_fourier = False\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.DiskRecorder.__init__","title":"__init__","text":"<pre><code>__init__(\n    control_func: Optional[Callable[[int], bool]] = None,\n    include_initial_state: bool = True,\n    cache_dir: Optional[str] = None,\n    cache_freq: int = 1,\n    temp_cache_loc: Literal[\"auto\", \"cpu\"] = \"cpu\",\n    save_format: Literal[\"numpy\", \"torch\"] = \"torch\",\n)\n</code></pre> Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>def __init__(self,\n             control_func:Optional[Callable[[int],bool]]=None,\n             include_initial_state:bool=True,\n             cache_dir:Optional[str]=None,\n             cache_freq:int=1,\n             temp_cache_loc:Literal[\"auto\",\"cpu\"]=\"cpu\",\n             save_format:Literal[\"numpy\",\"torch\"]=\"torch\",\n             ):\n    super().__init__(control_func,include_initial_state)\n    self.cache_dir=default(cache_dir,\"./saved_traj/\")\n    self.cache_freq=cache_freq\n    self._trajectory=[]\n    self.temp_cache_loc=temp_cache_loc\n    if self.temp_cache_loc not in [\"auto\",\"cpu\"]:\n        raise ValueError(\"temp_cache_loc must be either 'auto' or 'cpu'.\")\n    self.save_format=save_format\n    if self.save_format not in [\"numpy\",\"torch\"]:\n        raise ValueError(\"save_format must be either 'numpy' or 'torch'.\")\n</code></pre>"},{"location":"apis/traj_recorder/#torchfsm.traj_recorder.DiskRecorder.record","title":"record","text":"<pre><code>record(step: int, frame: tensor)\n</code></pre> <p>Record the trajectory at a given step.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>int</code> <p>The current step.</p> required <code>frame</code> <code>tensor</code> <p>The current frame to be recorded.</p> required Source code in <code>torchfsm/traj_recorder.py</code> <pre><code>def record(self,step:int,frame:torch.tensor):\n    \"\"\"\n    Record the trajectory at a given step.\n\n    Args:\n        step (int): The current step.\n        frame (torch.tensor): The current frame to be recorded.\n    \"\"\"\n    if self.control_func(step):\n        self._record(step,frame)\n</code></pre>"},{"location":"apis/utils/","title":"8. utils","text":""},{"location":"apis/utils/#torchfsm.utils.default","title":"torchfsm.utils.default","text":"<pre><code>default(value, default)\n</code></pre> <p>Return the default value if the value is None.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The value to check.</p> required <code>default</code> <p>The default value to return if value is None.</p> required <p>Returns:</p> Type Description <p>The value if it is not None, otherwise the default value.</p> Source code in <code>torchfsm/utils.py</code> <pre><code>def default(value, default):\n    \"\"\"\n    Return the default value if the value is None.\n\n    Args:\n        value: The value to check.\n        default: The default value to return if value is None.\n\n    Returns:\n        The value if it is not None, otherwise the default value.\n    \"\"\"\n    return value if value is not None else default\n</code></pre>"},{"location":"apis/utils/#torchfsm.utils.format_device_dtype","title":"torchfsm.utils.format_device_dtype","text":"<pre><code>format_device_dtype(\n    device: Optional[Union[device, str]] = None,\n    dtype: Optional[dtype] = None,\n) -&gt; Tuple[torch.device, torch.dtype]\n</code></pre> <p>Format the device and dtype for PyTorch.</p> <p>Parameters:</p> Name Type Description Default <code>device</code> <code>Optional[Union[device, str]]</code> <p>The device to use. If None, defaults to CPU.</p> <code>None</code> <code>dtype</code> <code>Optional[dtype]</code> <p>The data type to use. If None, defaults to float32.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[device, dtype]</code> <p>tuple[torch.device, torch.dtype]: The formatted device and dtype.</p> Source code in <code>torchfsm/utils.py</code> <pre><code>def format_device_dtype(\n    device: Optional[Union[torch.device, str]] = None,\n    dtype: Optional[torch.dtype] = None,\n)-&gt; Tuple[torch.device, torch.dtype]:\n    \"\"\"\n    Format the device and dtype for PyTorch.\n\n    Args:\n        device (Optional[Union[torch.device, str]]): The device to use. If None, defaults to CPU.\n        dtype (Optional[torch.dtype]): The data type to use. If None, defaults to float32.\n\n    Returns:\n        tuple[torch.device, torch.dtype]: The formatted device and dtype.\n    \"\"\"\n    if device is None:\n        device = torch.device(\"cpu\")\n    elif isinstance(device, str):\n        device = torch.device(device)\n        if device.index is None and device.type != \"cpu\":\n            device = torch.device(device.type, 0)\n    dtype = default(dtype, torch.float32)\n    return device, dtype\n</code></pre>"},{"location":"apis/utils/#torchfsm.utils.statistics_traj","title":"torchfsm.utils.statistics_traj","text":"<pre><code>statistics_traj(\n    traj: ValueList[Union[Tensor, ndarray]],\n) -&gt; Tuple[float, float, float, float]\n</code></pre> <p>Compute the mean, std, min, and max of a trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>ValueList[Union[Tensor, ndarray]]</code> <p>The trajectory to compute statistics for. The trajectory can be a list of tensors or numpy arrays, or a single tensor or numpy array.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[float, float, float, float]</code> <p>A tuple containing the mean, std, min, and max of the trajectory. The mean, std, min, and max are computed along the first dimension of the trajectory.</p> Source code in <code>torchfsm/utils.py</code> <pre><code>def statistics_traj(traj: ValueList[Union[torch.Tensor, np.ndarray]])-&gt; Tuple[float, float, float, float]:\n    \"\"\"\n    Compute the mean, std, min, and max of a trajectory.\n\n    Args:\n        traj (ValueList[Union[torch.Tensor, np.ndarray]]): The trajectory to compute statistics for.\n            The trajectory can be a list of tensors or numpy arrays, or a single tensor or numpy array.\n\n    Returns:\n        tuple: A tuple containing the mean, std, min, and max of the trajectory.\n            The mean, std, min, and max are computed along the first dimension of the trajectory.\n    \"\"\"\n    # [B, T, C, H, ...]\n    if not isinstance(traj, list):\n        traj = [traj]\n    traj = [\n        traj_i if isinstance(traj_i, torch.Tensor) else torch.from_numpy(traj_i)\n        for traj_i in traj\n    ]\n    new_shape = tuple([-1] + list(traj[0].shape[2:]))\n    traj_all = torch.cat([t.reshape(new_shape) for t in traj], dim=0)\n    means = [traj_all[:, i].mean().item() for i in range(traj_all.shape[1])]\n    stds = [traj_all[:, i].std().item() for i in range(traj_all.shape[1])]\n    mins = [traj_all[:, i].min().item() for i in range(traj_all.shape[1])]\n    maxs = [traj_all[:, i].max().item() for i in range(traj_all.shape[1])]\n    return means, stds, mins, maxs\n</code></pre>"},{"location":"apis/utils/#torchfsm.utils.random_clip_traj","title":"torchfsm.utils.random_clip_traj","text":"<pre><code>random_clip_traj(\n    traj: Union[\n        SpatialTensor[\"B T C H ...\"],\n        SpatialArray[\"B T C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n        FourierArray[\"B T C H ...\"],\n    ],\n    length: int,\n) -&gt; Union[\n    SpatialTensor[\"B length C H ...\"],\n    SpatialArray[\"B length C H ...\"],\n    FourierTensor[\"B length C H ...\"],\n    FourierArray[\"B length C H ...\"],\n]\n</code></pre> <p>Randomly clip a trajectory to a specified length.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>Union[SpatialTensor, SpatialArray, FourierTensor, FourierArray]</code> <p>The trajectory to clip. The trajectory can be a tensor or numpy array with shape [B, T, C, H, ...].</p> required <code>length</code> <code>int</code> <p>The length to clip the trajectory to. The length should be less than the original length of the trajectory.</p> required <p>Returns:</p> Type Description <code>Union[SpatialTensor['B length C H ...'], SpatialArray['B length C H ...'], FourierTensor['B length C H ...'], FourierArray['B length C H ...']]</code> <p>Union[SpatialTensor, SpatialArray, FourierTensor, FourierArray]: The clipped trajectory. The clipped trajectory has shape [B, length, C, H, ...].</p> Source code in <code>torchfsm/utils.py</code> <pre><code>def random_clip_traj(\n    traj: Union[\n        SpatialTensor[\"B T C H ...\"],\n        SpatialArray[\"B T C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n        FourierArray[\"B T C H ...\"],\n    ],\n    length: int,\n)-&gt; Union[\n        SpatialTensor[\"B length C H ...\"],\n        SpatialArray[\"B length C H ...\"],\n        FourierTensor[\"B length C H ...\"],\n        FourierArray[\"B length C H ...\"],\n    ]:\n\n    \"\"\"\n    Randomly clip a trajectory to a specified length.\n\n    Args:\n        traj (Union[SpatialTensor, SpatialArray, FourierTensor, FourierArray]): The trajectory to clip.\n            The trajectory can be a tensor or numpy array with shape [B, T, C, H, ...].\n        length (int): The length to clip the trajectory to.\n            The length should be less than the original length of the trajectory.\n\n    Returns:\n        Union[SpatialTensor, SpatialArray, FourierTensor, FourierArray]: The clipped trajectory.\n            The clipped trajectory has shape [B, length, C, H, ...].\n    \"\"\"\n    if isinstance(traj, np.ndarray):\n        traj = torch.from_numpy(traj)\n    new_traj = []\n    ori_len_time = traj.shape[1]\n    start = torch.randint(0, ori_len_time - length, (traj.shape[0],))\n    end = start + length\n    for i in range(traj.shape[0]):\n        new_traj.append(traj[i, start[i] : end[i]])\n    new_traj = torch.stack(new_traj, dim=0)\n    if isinstance(traj, np.ndarray):\n        new_traj = new_traj.numpy()\n    return new_traj\n</code></pre>"},{"location":"apis/utils/#torchfsm.utils.random_select_frames","title":"torchfsm.utils.random_select_frames","text":"<pre><code>random_select_frames(\n    traj: Union[\n        SpatialTensor[\"B T C H ...\"],\n        SpatialArray[\"B T C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n        FourierArray[\"B T C H ...\"],\n    ],\n    n_frames: int,\n) -&gt; Union[\n    SpatialTensor[\"B n_frames C H ...\"],\n    SpatialArray[\"B n_frames C H ...\"],\n    FourierTensor[\"B n_frames C H ...\"],\n    FourierArray[\"B n_frames C H ...\"],\n]\n</code></pre> <p>Randomly select a specified number of frames from a trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>Union[SpatialTensor, SpatialArray, FourierTensor, FourierArray]</code> <p>The trajectory to select frames from. The trajectory can be a tensor or numpy array with shape [B, T, C, H, ...].</p> required <code>n_frames</code> <code>int</code> <p>The number of frames to select. The number of frames should be less than the original length of the trajectory.</p> required <p>Returns:</p> Type Description <code>Union[SpatialTensor['B n_frames C H ...'], SpatialArray['B n_frames C H ...'], FourierTensor['B n_frames C H ...'], FourierArray['B n_frames C H ...']]</code> <p>Union[SpatialTensor, SpatialArray, FourierTensor, FourierArray]: The selected frames. The selected frames have shape [B, n_frames, C, H, ...].</p> Source code in <code>torchfsm/utils.py</code> <pre><code>def random_select_frames(\n    traj: Union[\n        SpatialTensor[\"B T C H ...\"],\n        SpatialArray[\"B T C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n        FourierArray[\"B T C H ...\"],\n    ],\n    n_frames: int,\n)-&gt; Union[\n        SpatialTensor[\"B n_frames C H ...\"],\n        SpatialArray[\"B n_frames C H ...\"],\n        FourierTensor[\"B n_frames C H ...\"],\n        FourierArray[\"B n_frames C H ...\"],\n    ]:\n    \"\"\"\n    Randomly select a specified number of frames from a trajectory.\n\n    Args:\n        traj (Union[SpatialTensor, SpatialArray, FourierTensor, FourierArray]): The trajectory to select frames from.\n            The trajectory can be a tensor or numpy array with shape [B, T, C, H, ...].\n        n_frames (int): The number of frames to select.\n            The number of frames should be less than the original length of the trajectory.\n\n    Returns:\n        Union[SpatialTensor, SpatialArray, FourierTensor, FourierArray]: The selected frames.\n            The selected frames have shape [B, n_frames, C, H, ...].\n    \"\"\"\n    if isinstance(traj, np.ndarray):\n        traj = torch.from_numpy(traj)\n    ori_len_time = traj.shape[1]\n    selected_frames = torch.randint(0, ori_len_time, (n_frames,))\n    new_traj = traj[:, selected_frames]\n    if isinstance(traj, np.ndarray):\n        new_traj = new_traj.numpy()\n    return new_traj\n</code></pre>"},{"location":"apis/utils/#torchfsm.utils.uniformly_select_frames","title":"torchfsm.utils.uniformly_select_frames","text":"<pre><code>uniformly_select_frames(\n    traj: Union[\n        SpatialTensor[\"B T C H ...\"],\n        SpatialArray[\"B T C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n        FourierArray[\"B T C H ...\"],\n    ],\n    n_frames: int,\n) -&gt; Union[\n    SpatialTensor[\"B n_frames C H ...\"],\n    SpatialArray[\"B n_frames C H ...\"],\n    FourierTensor[\"B n_frames C H ...\"],\n    FourierArray[\"B n_frames C H ...\"],\n]\n</code></pre> <p>Uniformly select a specified number of frames from a trajectory.</p> <p>Parameters:</p> Name Type Description Default <code>traj</code> <code>Union[SpatialTensor, SpatialArray, FourierTensor, FourierArray]</code> <p>The trajectory to select frames from. The trajectory can be a tensor or numpy array with shape [B, T, C, H, ...].</p> required <code>n_frames</code> <code>int</code> <p>The number of frames to select. The number of frames should be less than the original length of the trajectory.</p> required <p>Returns:</p> Type Description <code>Union[SpatialTensor['B n_frames C H ...'], SpatialArray['B n_frames C H ...'], FourierTensor['B n_frames C H ...'], FourierArray['B n_frames C H ...']]</code> <p>Union[SpatialTensor, SpatialArray, FourierTensor, FourierArray]: The selected frames. The selected frames have shape [B, n_frames, C, H, ...].</p> Source code in <code>torchfsm/utils.py</code> <pre><code>def uniformly_select_frames(\n    traj: Union[\n        SpatialTensor[\"B T C H ...\"],\n        SpatialArray[\"B T C H ...\"],\n        FourierTensor[\"B T C H ...\"],\n        FourierArray[\"B T C H ...\"],\n    ],\n    n_frames: int,\n)-&gt; Union[\n        SpatialTensor[\"B n_frames C H ...\"],\n        SpatialArray[\"B n_frames C H ...\"],\n        FourierTensor[\"B n_frames C H ...\"],\n        FourierArray[\"B n_frames C H ...\"],\n    ]:\n    \"\"\"\n    Uniformly select a specified number of frames from a trajectory.\n\n    Args:\n        traj (Union[SpatialTensor, SpatialArray, FourierTensor, FourierArray]): The trajectory to select frames from.\n            The trajectory can be a tensor or numpy array with shape [B, T, C, H, ...].\n        n_frames (int): The number of frames to select.\n            The number of frames should be less than the original length of the trajectory.\n\n    Returns:\n        Union[SpatialTensor, SpatialArray, FourierTensor, FourierArray]: The selected frames.\n            The selected frames have shape [B, n_frames, C, H, ...].\n    \"\"\"\n    if isinstance(traj, np.ndarray):\n        traj = torch.from_numpy(traj)\n    ori_len_time = traj.shape[1]\n    selected_frames = torch.linspace(0, ori_len_time - 1, n_frames).long()\n    new_traj = traj[:, selected_frames]\n    if isinstance(traj, np.ndarray):\n        new_traj = new_traj.numpy()\n    return new_traj  \n</code></pre>"},{"location":"assets/scripts/showcase/","title":"Showcase","text":"In\u00a0[\u00a0]: Copied! <pre>from torchfsm import *\nimport torch\n</pre> from torchfsm import * import torch In\u00a0[\u00a0]: Copied! <pre>def Burgers(nu:float) -&gt; Operator:\n    return nu*Laplacian()-Convection()\nburgers=Burgers(0.01)\nmesh=MeshGrid([(0,2*torch.pi,128)],device=\"cuda:0\")\nburgers.integrate(\n    u_0=torch.sin(mesh.bc_mesh_grid()),\n  \tmesh=mesh,\n    dt=0.01,step=200\n)\n</pre> def Burgers(nu:float) -&gt; Operator:     return nu*Laplacian()-Convection() burgers=Burgers(0.01) mesh=MeshGrid([(0,2*torch.pi,128)],device=\"cuda:0\") burgers.integrate(     u_0=torch.sin(mesh.bc_mesh_grid()),   \tmesh=mesh,     dt=0.01,step=200 )"},{"location":"tutorials/call_operator/","title":"2.1. Call the Operator","text":"<p><code>Operator</code> is the foundational building block of the <code>TorchFSM</code> library. You can directly call an operator to compute the spatial derivative of a tensor.</p> <p>For example, the following code calculates the gradient of <code>sin(x)</code> using the <code>Grad</code> operator:</p> In\u00a0[1]: Copied! <pre>from torchfsm.mesh import MeshGrid\nfrom torchfsm.operator import Grad\nfrom torchfsm.plot import plot_field\nimport torch\n\nmesh=MeshGrid([(0,2*torch.pi,100)])\nsin_x=torch.sin(mesh.bc_mesh_grid())\ngrad_operator=Grad()\ncos_x=grad_operator(sin_x,mesh=mesh)\nplot_field(cos_x)\n</pre> from torchfsm.mesh import MeshGrid from torchfsm.operator import Grad from torchfsm.plot import plot_field import torch  mesh=MeshGrid([(0,2*torch.pi,100)]) sin_x=torch.sin(mesh.bc_mesh_grid()) grad_operator=Grad() cos_x=grad_operator(sin_x,mesh=mesh) plot_field(cos_x) <p>The <code>__call__</code> function of an operator can accept additional parameters to improve efficiency. For example:</p> <ul> <li>It can take input values in Fourier space to avoid repeatedly applying the Fourier transform when the same tensor is used with multiple operators.</li> <li>It can also return results in Fourier space for further downstream computations.</li> </ul> <p>For a full list of supported options, refer to the API documentation.</p> <p>Additionally, we provide a <code>run_operator</code> function that allows you to apply a list of operators to the same tensor on the same device efficiently. Examples of this usage are shown in the next notebook.</p> <p>Similar to PyTorch, <code>TorchFSM</code> also provides a <code>torchfsm.functional</code> module, which includes several commonly used functions. For instance, the code example above can be rewritten using <code>torchfsm.functional</code> as follows:</p> In\u00a0[2]: Copied! <pre>from torchfsm.functional import grad\n\ncos_x=grad(sin_x,mesh=mesh)\nplot_field(cos_x)\n</pre> from torchfsm.functional import grad  cos_x=grad(sin_x,mesh=mesh) plot_field(cos_x) <p>As mentioned in the theory introduction, one of the major advantages of the Fourier spectral method is its high accuracy. To illustrate this, we can compare its results with those obtained using the finite difference method (FDM).</p> <p>For the FDM implementation, we use ConvDO, a library for convolution-based differential operators. In the following example, we compute the gradient of <code>sin(x)</code> using both the Fourier spectral method and the FDM, and compare the results across different mesh resolutions.</p> In\u00a0[35]: Copied! <pre>from ConvDO import ConvGrad, ScalarField, PeriodicDomain\nfrom matplotlib import pyplot as plt\n\nmesh=MeshGrid([(0,2*torch.pi,100)])\nx=mesh.mesh_grid()\ncos_x=torch.cos(x)\nplt.plot(x,cos_x.detach().numpy(),label=\"ground truth\",color=\"black\")\n\nns=[5,10,20]\ncolors=['#FF1F5B', '#009ADE', '#FFC61E']\n\nfor color,n in zip(colors,ns):\n\n    mesh=MeshGrid([(0,2*torch.pi,n)]*2)\n    x,y=mesh.bc_mesh_grid()\n    x_plot=x[0,0,:,0]\n    sin_x=torch.sin(x)\n    \n    cos_x_fsm=grad(sin_x,mesh=mesh)[0,0,:,0]\n    PendingDeprecationWarning\n    plt.scatter(x_plot,cos_x_fsm,label=f\"fsm {n}\",marker=\"o\",color=color)\n\n    # ConvDO has a different definition of the coordinate system, so we need to transpose the result\n    u=ScalarField(sin_x.transpose(-1,-2),domain=PeriodicDomain(delta_x=2*torch.pi/n))\n    conv_grad=ConvGrad(order=2,direction=\"x\")\n    cos_x_fdm=(conv_grad*u).value.transpose(-1,-2)[0,0,:,0]\n    plt.scatter(x_plot,cos_x_fdm,label=f\"fdm {n}\",marker=\"x\",color=color)\n\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.legend()\nplt.show()\n</pre> from ConvDO import ConvGrad, ScalarField, PeriodicDomain from matplotlib import pyplot as plt  mesh=MeshGrid([(0,2*torch.pi,100)]) x=mesh.mesh_grid() cos_x=torch.cos(x) plt.plot(x,cos_x.detach().numpy(),label=\"ground truth\",color=\"black\")  ns=[5,10,20] colors=['#FF1F5B', '#009ADE', '#FFC61E']  for color,n in zip(colors,ns):      mesh=MeshGrid([(0,2*torch.pi,n)]*2)     x,y=mesh.bc_mesh_grid()     x_plot=x[0,0,:,0]     sin_x=torch.sin(x)          cos_x_fsm=grad(sin_x,mesh=mesh)[0,0,:,0]     PendingDeprecationWarning     plt.scatter(x_plot,cos_x_fsm,label=f\"fsm {n}\",marker=\"o\",color=color)      # ConvDO has a different definition of the coordinate system, so we need to transpose the result     u=ScalarField(sin_x.transpose(-1,-2),domain=PeriodicDomain(delta_x=2*torch.pi/n))     conv_grad=ConvGrad(order=2,direction=\"x\")     cos_x_fdm=(conv_grad*u).value.transpose(-1,-2)[0,0,:,0]     plt.scatter(x_plot,cos_x_fdm,label=f\"fdm {n}\",marker=\"x\",color=color)  plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.show() <p>As shown in the example above, the Fourier spectral method converges to the exact solution significantly faster than the finite difference method.</p>"},{"location":"tutorials/cheatsheet/","title":"Cheat Sheet","text":""},{"location":"tutorials/cheatsheet/#data-types","title":"Data Types","text":"<ul> <li>\\([B,C,H,W,\\cdots]\\): [Batch, Channel, x, y, \\(\\cdots\\)]</li> <li>\\([B,T,C,H,W,\\cdots]\\): [Batch, Trajectory, Channel, x, y, \\(\\cdots\\)]</li> <li><code>SpatialTensor</code>/<code>SpatialArray</code>: A tensor/array in physical space.</li> <li><code>FourierTensor</code>/<code>FourierArray</code>: A tensor/array in Fourier space, i.e., the tensor is a complex tensor.</li> </ul>"},{"location":"tutorials/cheatsheet/#operators","title":"Operators","text":""},{"location":"tutorials/cheatsheet/#basic-operators","title":"Basic Operators","text":"<ul> <li>\\(\\mathbf{u}\\): \\(n\\) d vector field.</li> <li>\\(\\phi\\): scalar field (0d vector field.).</li> <li>\\(i\\): index of the coordinate.</li> <li>\\(I\\): maximum index of the coordinate.</li> <li>\\(u_i\\): \\(i\\) th component of the vector field.</li> </ul> Operator Equation Is linear operator SpatialDerivative \\(\\frac{\\partial ^n}{\\partial i} \\phi\\) True Gradient \\(\\nabla \\phi = \\left[\\begin{matrix}\\frac{\\partial \\phi}{\\partial x} \\\\\\frac{\\partial \\phi}{\\partial y} \\\\\\cdots \\\\\\frac{\\partial \\phi}{\\partial I} \\\\\\end{matrix}\\right]\\) True Divergence \\(\\nabla \\cdot \\mathbf{u} = \\sum_{i=0}^I \\frac{\\partial u_i}{\\partial i}\\) True Laplacian \\(\\nabla^2\\mathbf{u}=\\left[\\begin{matrix}\\sum_{i=0}^I \\frac{\\partial^2 u_x}{\\partial i^2 } \\\\ \\sum_{i=0}^I \\frac{\\partial^2 u_y}{\\partial i^2 } \\\\ \\cdots \\\\ \\sum_{i=0}^I \\frac{\\partial^2 u_I}{\\partial i^2 } \\\\ \\end{matrix} \\right]\\) True Biharmonic \\(\\nabla^4\\mathbf{u}=\\left[\\begin{matrix}(\\sum_{i=0}^I\\frac{\\partial^2}{\\partial i^2 })(\\sum_{j=0}^I\\frac{\\partial^2}{\\partial j^2 })u_x \\\\ (\\sum_{i=0}^I\\frac{\\partial^2}{\\partial i^2 })(\\sum_{j=0}^I\\frac{\\partial^2}{\\partial j^2 })u_y \\\\ \\cdots \\\\ (\\sum_{i=0}^I\\frac{\\partial^2}{\\partial i^2 })(\\sum_{j=0}^I\\frac{\\partial^2}{\\partial j^2 })u_i \\\\ \\end{matrix} \\right]\\) True Curl (2D input) \\(\\nabla \\times \\mathbf{u} = \\frac{\\partial u_y}{\\partial x}-\\frac{\\partial u_x}{\\partial y}\\) False Curl (3D input) \\(\\nabla \\times \\mathbf{u} = \\left[\\begin{matrix} \\frac{\\partial u_z}{\\partial y}-\\frac{\\partial u_y}{\\partial z} \\\\ \\frac{\\partial u_x}{\\partial z}-\\frac{\\partial u_z}{\\partial x} \\\\ \\frac{\\partial u_y}{\\partial x}-\\frac{\\partial u_x}{\\partial y} \\end{matrix} \\right]\\) False ConservativeConvection \\(\\nabla \\cdot \\mathbf{u}\\mathbf{u}=\\left[\\begin{matrix}\\sum_{i=0}^I \\frac{\\partial u_i u_x }{\\partial i} \\\\\\sum_{i=0}^I \\frac{\\partial u_i u_y }{\\partial i} \\\\ \\cdots\\\\ \\sum_{i=0}^I \\frac{\\partial u_i u_I }{\\partial i} \\\\ \\end{matrix} \\right]\\) False Convection \\(\\mathbf{u} \\cdot \\nabla  \\mathbf{u}=\\left[\\begin{matrix}\\sum_{i=0}^I u_i\\frac{\\partial u_x }{\\partial i} \\\\\\sum_{i=0}^I u_i\\frac{\\partial u_y }{\\partial i} \\\\\\cdots\\\\\\sum_{i=0}^I u_i\\frac{\\partial u_I }{\\partial i} \\\\\\end{matrix} \\right]\\) False KS Convection \\(\\frac{1}{2}\\|\\nabla \\phi\\|^2=\\frac{1}{2}\\sum_{i=0}^{I}(\\frac{\\partial \\phi}{\\partial i})^2\\) False <p>All the above operators can be imported from <code>torchfsm.operator</code> module. Corresponding functions that directly apply the operator to the input tensor are also available in <code>torchfsm.functional</code> module.</p>"},{"location":"tutorials/cheatsheet/#navier-stokes-operators","title":"Navier-Stokes Operators","text":"<ul> <li>\\(\\mathbf{u}\\): vector field.</li> <li>\\(u,v\\): components of 2d velocity field.</li> <li>\\(\\omega\\): vorticity scalar of a 2d velocity.</li> <li>\\(p\\): pressure.</li> </ul> Operator Equation VorticityConvection \\((\\mathbf{u}\\cdot\\nabla) \\omega\\) NSPressureConvection \\(-\\nabla (\\nabla^{-2} \\nabla \\cdot (\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}-f))-\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u} + \\mathbf{f}\\) Vorticity2Velocity \\([u,v]=[-\\frac{\\partial \\nabla^{-2}\\omega}{\\partial y},\\frac{\\partial \\nabla^{-2}\\omega}{\\partial x}]\\) Velocity2Pressure \\(-\\nabla^{-2} (\\nabla \\cdot (\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}-f))\\) Vorticity2Pressure \\(\\begin{matrix}\\mathbf{u}=[u,v]=[-\\frac{\\partial \\nabla^{-2}\\omega}{\\partial y},\\frac{\\partial \\nabla^{-2}\\omega}{\\partial x}]\\\\ p= -\\nabla^{-2} (\\nabla \\cdot (\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}-f))\\end{matrix}\\) <p>All the above operators can be imported from <code>torchfsm.operator</code> module. Corresponding functions for <code>VorticityConvection</code>, <code>Vorticity2Velocity</code>, <code>Velocity2Pressure</code> and <code>Vorticity2Pressure</code> are also available in <code>torchfsm.functional</code> module.</p>"},{"location":"tutorials/cheatsheet/#equations","title":"Equations","text":"Operator Equation Burgers \\(\\frac{\\partial \\mathbf{u}}{\\partial t} =-\\mathbf{u} \\cdot \\nabla \\mathbf{u} + \\nu \\nabla^2 \\mathbf{u}\\) KuramotoSivashinsky \\(\\frac{\\partial \\phi}{\\partial t}=-\\frac{\\partial^2 \\phi}{\\partial x^2} -\\frac{\\partial^4 \\phi}{\\partial x^4} - \\phi\\frac{\\partial\\phi}{\\partial x}\\) KuramotoSivashinskyHighDim \\(\\frac{\\partial \\mathbf{\\phi}}{\\partial t}=-\\nabla^2 \\phi- \\nabla^4 \\phi - \\frac{1}{2} \\| \\nabla \\phi \\|^2\\) KortewegDeVries \\(\\frac{\\partial \\phi}{\\partial t}=-c_1\\frac{\\partial^3 \\phi}{\\partial x^3} + c_2 \\phi\\frac{\\partial\\phi}{\\partial x}\\) NavierStokesVorticity \\(\\frac{\\partial \\omega}{\\partial t} + (\\mathbf{u}\\cdot\\nabla) \\omega = \\frac{1}{Re} \\nabla^2 \\omega + \\nabla \\times \\mathbf{f}\\) NavierStokes \\(\\frac{\\partial\\mathbf{u}}{\\partial t}=-\\nabla (\\nabla^{-2} \\nabla \\cdot (\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}-f))-\\left(\\mathbf{u}\\cdot\\nabla\\right)\\mathbf{u}+\\nu \\nabla^2 \\mathbf{u} + \\mathbf{f}\\)"},{"location":"tutorials/concepts/","title":"1. Concepts","text":"In\u00a0[\u00a0]: Copied! <pre>from torchfsm.operator import Operator, Convection, Laplacian\n\ndef Burgers(nu:float) -&gt; Operator:\n    return nu*Laplacian()-Convection()\nburgers=Burgers(0.01)\n</pre> from torchfsm.operator import Operator, Convection, Laplacian  def Burgers(nu:float) -&gt; Operator:     return nu*Laplacian()-Convection() burgers=Burgers(0.01) <p>There are three important functions for <code>Operator</code> classes:</p> <ul> <li><code>__call__</code>: Calling the operator as a function directly will return the result of applying the operator to the input. This is useful for evaluating complex spatial derivatives.</li> <li><code>integrate</code>: Integrates the operator over the time dimension. This is primarily used to solve time-dependent PDEs.</li> <li><code>solve</code>: Solves the linear operation given a right-hand side. This function only works for the <code>LinearOperator</code> class and is typically used for solving time-independent problems, such as the Poisson equation.</li> </ul> <p>In later sections, we will explain how to use these functions in detail.</p> <p>All available operators in <code>TorchFSM</code> are summarized in the cheat sheet.</p>"},{"location":"tutorials/concepts/#1-concepts","title":"1. Concepts\u00b6","text":"<p>Before we dive into the details of <code>TorchFSM</code>, let's introduce some key concepts used in the framework.</p>"},{"location":"tutorials/concepts/#11-data-types","title":"1.1 Data Types\u00b6","text":"<p><code>TorchFSM</code> is designed for deep learning applications, and all data is manipulated in the form of PyTorch Tensors. As a result, data shapes follow PyTorch conventions. There are two primary types of data shapes in <code>TorchFSM</code>:</p> <ul> <li><p><code>[B, C, H, ...]</code>: This is the most common data shape in <code>TorchFSM</code>. Here, <code>B</code> is the batch size, <code>C</code> is the number of channels, and <code>H, ...</code> represent spatial dimensions. For example, 32 2D vector fields on a 64\u00d764 mesh can be represented as <code>[32, 1, 64, 64]</code>. All inputs to the <code>Operator</code> class should conform to this shape.</p> </li> <li><p><code>[B, T, C, H, ...]</code>: This shape is used to store trajectory data, where <code>T</code> represents the number of time steps (solution frames) in the trajectory. For example, 32 2D vector fields on a 64\u00d764 mesh over 100 time steps can be represented as <code>[32, 100, 2, 64, 64]</code>. This shape is typically used as the output when solving time-dependent PDEs.</p> </li> </ul> <p>In <code>TorchFSM</code>, we also introduce type annotations to help users supply valid inputs to functions. These type annotations are defined as follows:</p> <ul> <li><code>SpatialTensor</code>: A tensor in physical space.</li> <li><code>SpatialArray</code>: A NumPy array in physical space.</li> <li><code>FourierTensor</code>: A tensor in Fourier space (i.e., a complex-valued tensor).</li> <li><code>FourierArray</code>: A NumPy array in Fourier space (i.e., a complex-valued array).</li> </ul> <p>These types can also be combined with shape annotations. For example, <code>SpatialTensor[\"B C H ...\"]</code> indicates a tensor in physical space with the shape <code>[B, C, H, ...]</code>.</p> <p>Note</p> <p>         \"SpatialTensor\" and \"FourierTensor\" are not actual PyTorch tensor types. They are type annotations intended to clarify the expected data format.     </p>"},{"location":"tutorials/concepts/#12-operator","title":"1.2 Operator\u00b6","text":"<p>The <code>Operator</code> is a central concept in <code>TorchFSM</code>. It represents a spatial operation applied to a variable. For example:</p> <ul> <li>The gradient operator computes the gradient of a variable.</li> <li>The divergence operator computes the divergence of a variable.</li> <li>The Laplacian operator computes the Laplacian of a variable.</li> </ul> <p>There are three main types of operator classes in <code>TorchFSM</code>:</p> <ul> <li><code>LinearOperator</code>: Represents linear terms in the context of the Fourier spectral method.</li> <li><code>NonlinearOperator</code>: Represents nonlinear terms.</li> <li><code>Operator</code>: A composite class that can include both linear and nonlinear components.</li> </ul> <p>For more details on linear terms, see our Theory Introduction.</p> <p>All <code>Operator</code> classes support basic linear algebra operations such as addition, subtraction, and multiplication. Thanks to the linearity of the Fourier transform, it's efficient to construct PDEs using combinations of different <code>Operator</code>s.</p> <p>For example, the Burgers' equation,</p> $$ \\frac{\\partial \\mathbf{u}}{\\partial t} = -\\mathbf{u} \\cdot \\nabla \\mathbf{u} + \\nu \\nabla^2 \\mathbf{u}, $$<p>can be constructed as follows:</p>"},{"location":"tutorials/concepts/#13-mesh","title":"1.3 Mesh\u00b6","text":"<p>In the Fourier spectral method, all boundary conditions are periodic, and internal obstacles within the domain are not supported. Therefore, <code>TorchFSM</code> uses a simplified <code>Mesh</code> to represent the spatial domain. The <code>Mesh</code> is another key concept in <code>TorchFSM</code>, encapsulating the domain size and grid resolution.</p> <p>All basic operations in an <code>Operator</code> class require a mesh as input. The mesh can be one of the following types:</p> <ul> <li><p><code>mesh_info</code> (<code>Sequence[tuple[float, float, int]]</code>): A sequence of tuples, where each tuple represents a spatial dimension. Each tuple contains three elements: the start of the domain, the end of the domain, and the number of grid points. For example, <code>mesh_info = [(0, 1, 64), (0, 1, 64)]</code> represents a 2D domain of size $[0,1] \\times [0,1]$ with grid spacing $dx = dy = 1/64$.</p> </li> <li><p><code>MeshGrid</code>: An iterable class that represents a mesh grid. This class is especially useful for generating initial conditions. Its length corresponds to the number of dimensions in the mesh. The attributes <code>x</code>, <code>y</code>, and <code>z</code> provide mesh grids for the first three dimensions. For additional dimensions, you can access the mesh grid via indexing (e.g., <code>mesh_grid[0]</code> for the first dimension, which is equivalent to <code>x</code>). There is no limit to the number of dimensions. If the number of points in each dimension is $n_1, n_2, n_3, \\dots, n_k$, the full mesh grid shape is <code>(n_1, n_2, n_3, ..., n_k)</code>. The shapes of attributes <code>x</code>, <code>y</code>, <code>z</code> are <code>(n_1)</code>, <code>(n_2)</code>, <code>(n_3)</code> respectively. <code>MeshGrid</code> can be initialized with a <code>mesh_info</code>, along with optional keywords to specify the device and data type.</p> </li> <li><p><code>FourierMesh</code>: A class that contains FFT frequency information and basic derivative operators used in the Fourier spectral method. This class is used internally by <code>Operator</code> objects. All other mesh types are converted to a <code>FourierMesh</code> inside an <code>Operator</code>. If you're using multiple operators and want to save memory, you should create and pass a <code>FourierMesh</code> directly. Otherwise, each operator will create its own <code>FourierMesh</code> instance with identical content. <code>FourierMesh</code> can be initialized using either a <code>mesh_info</code> or a <code>MeshGrid</code> object.</p> </li> </ul> <p>All these mesh types can be used in the three main functions of the <code>Operator</code> class mentioned above. They can also be assigned to an operator using the <code>register_mesh</code> method. Once a mesh is registered, you no longer need to pass it explicitly when calling operator functions. A mesh is automatically registered the first time it is passed to any operator method.</p>"},{"location":"tutorials/derivative_example/","title":"2.2. Examples","text":"<p>In this notebook, we provide examples of computing derivatives using the available operators in <code>TorchFSM</code>. We use simple trigonometric functions as test cases, since their analytical derivatives are easy to compute and serve as reliable ground truth.</p> <p>If you're implementing a new operator, it's a good practice to validate it using the simple experiments demonstrated here to ensure correctness. In addition to manually calculating the ground truth, you can also use the <code>sympy</code> library to compute derivatives symbolically</p> In\u00a0[1]: Copied! <pre>from sympy import *\nx=symbols(\"x\")\ndiff((sin(2*x)+sin(4*x))**2,x)\n</pre> from sympy import * x=symbols(\"x\") diff((sin(2*x)+sin(4*x))**2,x) Out[1]:  $\\displaystyle \\left(\\sin{\\left(2 x \\right)} + \\sin{\\left(4 x \\right)}\\right) \\left(4 \\cos{\\left(2 x \\right)} + 8 \\cos{\\left(4 x \\right)}\\right)$  <p>Now, let's start our experiments. We could first give some helper functions for plot and calculations:</p> In\u00a0[2]: Copied! <pre>import torch\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom torchfsm.mesh import MeshGrid\nfrom torchfsm.operator import run_operators\nfrom typing import List, Union\n\ndef plot(\n    gds: List[Union[torch.Tensor, np.ndarray]],\n    pds: List[Union[torch.Tensor, np.ndarray]],\n    x_label: List[str],\n    labels: List[str],\n):\n    n_fig=len(gds)\n    if n_fig!=len(pds) or n_fig!=len(x_label) or n_fig!=len(labels):\n        raise ValueError(\"The length of gds, pds, x_label, and labels should be the same.\")\n    if n_fig==1:\n        n_rows=1; n_cols=1\n    else:\n        if n_fig%2==0:\n            n_rows=n_fig//2; n_cols=2 if n_fig&gt;1 else 1\n        else:\n            n_rows=(n_fig)//3; n_cols=1 if n_fig==1 else 3\n    _, axs = plt.subplots(nrows=n_rows,ncols=n_cols,\n                            sharey=True,figsize=(4*n_cols,4*n_rows))\n    axs=axs.flat if n_fig&gt;1 else [axs]\n    for i,ax in enumerate(axs):\n        ax.plot(gds[i],label=labels[i])\n        ax.plot(pds[i],label=f\"{labels[i]} fsm\", linestyle='dashed')\n        ax.set_xlabel(x_label[i])\n        ax.grid(True)\n        ax.legend()\n    for i_row in range(n_rows):\n        axs[i_row*n_cols].set_ylabel(\"value\")\n</pre> import torch import matplotlib.pyplot as plt import numpy as np from torchfsm.mesh import MeshGrid from torchfsm.operator import run_operators from typing import List, Union  def plot(     gds: List[Union[torch.Tensor, np.ndarray]],     pds: List[Union[torch.Tensor, np.ndarray]],     x_label: List[str],     labels: List[str], ):     n_fig=len(gds)     if n_fig!=len(pds) or n_fig!=len(x_label) or n_fig!=len(labels):         raise ValueError(\"The length of gds, pds, x_label, and labels should be the same.\")     if n_fig==1:         n_rows=1; n_cols=1     else:         if n_fig%2==0:             n_rows=n_fig//2; n_cols=2 if n_fig&gt;1 else 1         else:             n_rows=(n_fig)//3; n_cols=1 if n_fig==1 else 3     _, axs = plt.subplots(nrows=n_rows,ncols=n_cols,                             sharey=True,figsize=(4*n_cols,4*n_rows))     axs=axs.flat if n_fig&gt;1 else [axs]     for i,ax in enumerate(axs):         ax.plot(gds[i],label=labels[i])         ax.plot(pds[i],label=f\"{labels[i]} fsm\", linestyle='dashed')         ax.set_xlabel(x_label[i])         ax.grid(True)         ax.legend()     for i_row in range(n_rows):         axs[i_row*n_cols].set_ylabel(\"value\") In\u00a0[3]: Copied! <pre>mesh_grid=MeshGrid([(0, 2*torch.pi, 32),(0, 4*torch.pi, 64), (0, 8*torch.pi, 128)])\nx,y,z=mesh_grid.bc_mesh_grid()\nphi=torch.sin(x)+torch.cos(y)+torch.sin(z)+torch.cos(z)\nu=torch.cat([torch.sin(x), \n             torch.cos(y), \n             torch.sin(z)+torch.cos(z)], \n            dim=1)\nu_3d=torch.cat([torch.sin(y)+torch.cos(z), \n                torch.cos(x)-torch.sin(z),\n                torch.cos(y)-torch.sin(x)], \n               dim=1)\nx=mesh_grid.x.numpy();y=mesh_grid.y.numpy();z=mesh_grid.z.numpy()\nx_mg,y_mg,z_mg=mesh_grid.bc_mesh_grid(numpy=True)\n\nmesh_grid_2d=MeshGrid([(0, 2*torch.pi, 32),(0, 4*torch.pi, 64)])\nx_2d,y_2d=mesh_grid_2d.bc_mesh_grid()\nu_2d=torch.cat([torch.sin(y_2d), torch.cos(x_2d)], dim=1)\nx_2d_mg,y_2d_mg=mesh_grid_2d.bc_mesh_grid(numpy=True)\n</pre> mesh_grid=MeshGrid([(0, 2*torch.pi, 32),(0, 4*torch.pi, 64), (0, 8*torch.pi, 128)]) x,y,z=mesh_grid.bc_mesh_grid() phi=torch.sin(x)+torch.cos(y)+torch.sin(z)+torch.cos(z) u=torch.cat([torch.sin(x),               torch.cos(y),               torch.sin(z)+torch.cos(z)],              dim=1) u_3d=torch.cat([torch.sin(y)+torch.cos(z),                  torch.cos(x)-torch.sin(z),                 torch.cos(y)-torch.sin(x)],                 dim=1) x=mesh_grid.x.numpy();y=mesh_grid.y.numpy();z=mesh_grid.z.numpy() x_mg,y_mg,z_mg=mesh_grid.bc_mesh_grid(numpy=True)  mesh_grid_2d=MeshGrid([(0, 2*torch.pi, 32),(0, 4*torch.pi, 64)]) x_2d,y_2d=mesh_grid_2d.bc_mesh_grid() u_2d=torch.cat([torch.sin(y_2d), torch.cos(x_2d)], dim=1) x_2d_mg,y_2d_mg=mesh_grid_2d.bc_mesh_grid(numpy=True) In\u00a0[4]: Copied! <pre>from torchfsm.operator import SpatialDerivative\nphi_x, phi_y, phi_z, phi_yy = run_operators(\n    phi,\n    [SpatialDerivative(0,1), SpatialDerivative(1,1), SpatialDerivative(2,1), SpatialDerivative(1,2)],\n    mesh_grid\n)\n</pre> from torchfsm.operator import SpatialDerivative phi_x, phi_y, phi_z, phi_yy = run_operators(     phi,     [SpatialDerivative(0,1), SpatialDerivative(1,1), SpatialDerivative(2,1), SpatialDerivative(1,2)],     mesh_grid ) In\u00a0[5]: Copied! <pre>labels=[\"$\\phi'_x$\",\"$\\phi'_y$\",\"$\\phi'_z$\",\"$\\phi''_{yy}$\"]\nx_label = [\"x\",\"y\",\"z\",\"y\"]\ngds = [\n    np.cos(x),\n    -1*np.sin(y),\n    np.cos(z)-np.sin(z),\n    -1*np.cos(y)\n]\npds = [\n    phi_x[0,0,:,15,15],\n    phi_y[0,0,15,:,15],\n    phi_z[0,0,15,15,:],\n    phi_yy[0,0,15,:,15]\n]\nplot(gds, pds, x_label, labels)\n</pre> labels=[\"$\\phi'_x$\",\"$\\phi'_y$\",\"$\\phi'_z$\",\"$\\phi''_{yy}$\"] x_label = [\"x\",\"y\",\"z\",\"y\"] gds = [     np.cos(x),     -1*np.sin(y),     np.cos(z)-np.sin(z),     -1*np.cos(y) ] pds = [     phi_x[0,0,:,15,15],     phi_y[0,0,15,:,15],     phi_z[0,0,15,15,:],     phi_yy[0,0,15,:,15] ] plot(gds, pds, x_label, labels) In\u00a0[6]: Copied! <pre>from torchfsm.operator import Grad\ngrad=Grad()\ngrad_phi=grad(phi,mesh=mesh_grid)\n</pre> from torchfsm.operator import Grad grad=Grad() grad_phi=grad(phi,mesh=mesh_grid) In\u00a0[7]: Copied! <pre>labels=[\"$\\phi'_x$\",\"$\\phi'_y$\",\"$\\phi'_z$\"]\nx_label = [\"x\",\"y\",\"z\"]\ngds = [\n    np.cos(x),\n    -1*np.sin(y),\n    np.cos(z)-np.sin(z),\n]\npds = [\n    grad_phi[0,0,:,15,15],\n    grad_phi[0,1,15,:,15],\n    grad_phi[0,2,15,15,:],\n]\nplot(gds, pds, x_label, labels)\n</pre> labels=[\"$\\phi'_x$\",\"$\\phi'_y$\",\"$\\phi'_z$\"] x_label = [\"x\",\"y\",\"z\"] gds = [     np.cos(x),     -1*np.sin(y),     np.cos(z)-np.sin(z), ] pds = [     grad_phi[0,0,:,15,15],     grad_phi[0,1,15,:,15],     grad_phi[0,2,15,15,:], ] plot(gds, pds, x_label, labels) In\u00a0[8]: Copied! <pre>from torchfsm.operator import Div\ndiv=Div()\ndiv_u=div(u,mesh=mesh_grid)\n</pre> from torchfsm.operator import Div div=Div() div_u=div(u,mesh=mesh_grid) In\u00a0[9]: Copied! <pre>labels=[r\"$\\nabla \\cdot \\mathbf{u}$\"]\ngds = [\n    (np.cos(x_mg)-1*np.sin(y_mg)+np.cos(z_mg)-np.sin(z_mg))[0,0,:,15,15]\n]\npds = [\n    div_u[0,0,:,15,15],\n]\nx_label = [\"x\"]\nplot(gds, pds, x_label, labels)\n</pre> labels=[r\"$\\nabla \\cdot \\mathbf{u}$\"] gds = [     (np.cos(x_mg)-1*np.sin(y_mg)+np.cos(z_mg)-np.sin(z_mg))[0,0,:,15,15] ] pds = [     div_u[0,0,:,15,15], ] x_label = [\"x\"] plot(gds, pds, x_label, labels) In\u00a0[10]: Copied! <pre>from torchfsm.operator import Laplacian\nlaplacian=Laplacian()\nlap_u=laplacian(u,mesh=mesh_grid)\n</pre> from torchfsm.operator import Laplacian laplacian=Laplacian() lap_u=laplacian(u,mesh=mesh_grid) In\u00a0[11]: Copied! <pre>labels=[\n    r\"$[\\nabla \\cdot (\\nabla\\mathbf{u})]_x$\",\n    r\"$[\\nabla \\cdot (\\nabla\\mathbf{u})]_y$\",\n    r\"$[\\nabla \\cdot (\\nabla\\mathbf{u})]_z$\",\n]\nx_label=[\"$x$\",\"$y$\",\"$z$\"]\ngds=[\n    -np.sin(x),\n    -np.cos(y),\n    (-np.sin(z)-np.cos(z)),\n]\npds=[\n    lap_u[0,0,:,15,15],\n    lap_u[0,1,15,:,15],\n    lap_u[0,2,15,15,:],\n]\nplot(gds, pds, x_label, labels)\n</pre> labels=[     r\"$[\\nabla \\cdot (\\nabla\\mathbf{u})]_x$\",     r\"$[\\nabla \\cdot (\\nabla\\mathbf{u})]_y$\",     r\"$[\\nabla \\cdot (\\nabla\\mathbf{u})]_z$\", ] x_label=[\"$x$\",\"$y$\",\"$z$\"] gds=[     -np.sin(x),     -np.cos(y),     (-np.sin(z)-np.cos(z)), ] pds=[     lap_u[0,0,:,15,15],     lap_u[0,1,15,:,15],     lap_u[0,2,15,15,:], ] plot(gds, pds, x_label, labels) In\u00a0[12]: Copied! <pre>from torchfsm.operator import Biharmonic\nbiharmonic=Biharmonic()\nbiharmonic_u=biharmonic(u,mesh=mesh_grid)\n</pre> from torchfsm.operator import Biharmonic biharmonic=Biharmonic() biharmonic_u=biharmonic(u,mesh=mesh_grid) In\u00a0[13]: Copied! <pre>labels=[\n    r\"$[\\nabla^4\\mathbf{u}]_x$\",\n    r\"$[\\nabla^4\\mathbf{u}]_y$\",\n    r\"$[\\nabla^4\\mathbf{u}]_z$\",\n]\nx_label=[\"$x$\",\"$y$\",\"$z$\"]\ngds=[\n    np.sin(x),\n    np.cos(y),\n    np.sin(z)+np.cos(z),\n]\npds=[\n    biharmonic_u[0,0,:,15,15],\n    biharmonic_u[0,1,15,:,15],\n    biharmonic_u[0,2,15,15,:],\n]\nplot(gds, pds, x_label, labels)\n</pre> labels=[     r\"$[\\nabla^4\\mathbf{u}]_x$\",     r\"$[\\nabla^4\\mathbf{u}]_y$\",     r\"$[\\nabla^4\\mathbf{u}]_z$\", ] x_label=[\"$x$\",\"$y$\",\"$z$\"] gds=[     np.sin(x),     np.cos(y),     np.sin(z)+np.cos(z), ] pds=[     biharmonic_u[0,0,:,15,15],     biharmonic_u[0,1,15,:,15],     biharmonic_u[0,2,15,15,:], ] plot(gds, pds, x_label, labels) In\u00a0[14]: Copied! <pre>from torchfsm.operator import Curl\ncurl=Curl()\ncurl_u_2d=curl(u_2d,mesh=mesh_grid_2d)\n</pre> from torchfsm.operator import Curl curl=Curl() curl_u_2d=curl(u_2d,mesh=mesh_grid_2d) In\u00a0[15]: Copied! <pre>labels=[\n    r\"$\\nabla \\times (\\nabla\\mathbf{u})$\",\n    r\"$\\nabla \\times (\\nabla\\mathbf{u})$\",\n]\nx_label=[\"$x$\",\"$y$\"]\ngd=-1*torch.sin(x_2d_mg)-torch.cos(y_2d_mg)\ngds=[\n    gd[0,0,:,15],\n    gd[0,0,15,:],\n]\npds=[\n    curl_u_2d[0,0,:,15],\n    curl_u_2d[0,0,15,:],\n]\nplot(gds, pds, x_label, labels)\n</pre> labels=[     r\"$\\nabla \\times (\\nabla\\mathbf{u})$\",     r\"$\\nabla \\times (\\nabla\\mathbf{u})$\", ] x_label=[\"$x$\",\"$y$\"] gd=-1*torch.sin(x_2d_mg)-torch.cos(y_2d_mg) gds=[     gd[0,0,:,15],     gd[0,0,15,:], ] pds=[     curl_u_2d[0,0,:,15],     curl_u_2d[0,0,15,:], ] plot(gds, pds, x_label, labels) <ul> <li>3d vector field:</li> </ul> $$ \\nabla \\times \\mathbf{u}  = \\left[\\begin{matrix} \\frac{\\partial u_z}{\\partial y}-\\frac{\\partial u_y}{\\partial z} \\\\ \\frac{\\partial u_x}{\\partial z}-\\frac{\\partial u_z}{\\partial x} \\\\ \\frac{\\partial u_y}{\\partial x}-\\frac{\\partial u_x}{\\partial y} \\end{matrix} \\right] $$  In\u00a0[16]: Copied! <pre>curl_u=curl(u_3d,mesh=mesh_grid)\n</pre> curl_u=curl(u_3d,mesh=mesh_grid) In\u00a0[17]: Copied! <pre>labels=[\n    r\"$[\\nabla \\times (\\nabla\\mathbf{u})]_x$\",\n    r\"$[\\nabla \\times (\\nabla\\mathbf{u})]_y$\",\n    r\"$[\\nabla \\times (\\nabla\\mathbf{u})]_z$\",\n]\nx_label=[\"$y$\",\"$z$\",\"$x$\"]\ngd=np.concatenate( [-np.sin(y_mg)+np.cos(z_mg),\n     -np.sin(z_mg)+np.cos(x_mg),\n     -np.sin(x_mg)-np.cos(y_mg)],\n     axis=1)\ngds=[\n    gd[0,0,15,:,15],\n    gd[0,1,15,15,:],\n    gd[0,2,:,15,15],\n]\npds=[\n    curl_u[0,0,15,:,15],\n    curl_u[0,1,15,15,:],\n    curl_u[0,2,:,15,15],\n]\nplot(gds, pds, x_label, labels)\n</pre> labels=[     r\"$[\\nabla \\times (\\nabla\\mathbf{u})]_x$\",     r\"$[\\nabla \\times (\\nabla\\mathbf{u})]_y$\",     r\"$[\\nabla \\times (\\nabla\\mathbf{u})]_z$\", ] x_label=[\"$y$\",\"$z$\",\"$x$\"] gd=np.concatenate( [-np.sin(y_mg)+np.cos(z_mg),      -np.sin(z_mg)+np.cos(x_mg),      -np.sin(x_mg)-np.cos(y_mg)],      axis=1) gds=[     gd[0,0,15,:,15],     gd[0,1,15,15,:],     gd[0,2,:,15,15], ] pds=[     curl_u[0,0,15,:,15],     curl_u[0,1,15,15,:],     curl_u[0,2,:,15,15], ] plot(gds, pds, x_label, labels) In\u00a0[18]: Copied! <pre>from torchfsm.operator import ConservativeConvection\nfull_convection=ConservativeConvection()\nfull_conv_u=full_convection(u,mesh=mesh_grid)\n</pre> from torchfsm.operator import ConservativeConvection full_convection=ConservativeConvection() full_conv_u=full_convection(u,mesh=mesh_grid) In\u00a0[19]: Copied! <pre>labels=[\n    r\"$[\\nabla \\cdot \\mathbf{u}\\mathbf{u}]_x$\",\n    r\"$[\\nabla \\cdot \\mathbf{u}\\mathbf{u}]_y$\",\n    r\"$[\\nabla \\cdot \\mathbf{u}\\mathbf{u}]_z$\",\n]\nx_label=[\"$x$\",\"$y$\",\"$z$\"]\ngd=torch.cat(\n    [(-torch.sin(z_mg) + torch.cos(z_mg))*torch.sin(x_mg) - torch.sin(x_mg)*torch.sin(y_mg) + 2*torch.sin(x_mg)*torch.cos(x_mg),\n     (-torch.sin(z_mg) + torch.cos(z_mg))*torch.cos(y_mg) - 2*torch.sin(y_mg)*torch.cos(y_mg) + torch.cos(x_mg)*torch.cos(y_mg),\n     (-2*torch.sin(z_mg) + 2*torch.cos(z_mg))*(torch.sin(z_mg) + torch.cos(z_mg)) - (torch.sin(z_mg) + torch.cos(z_mg))*torch.sin(y_mg) + (torch.sin(z_mg) + torch.cos(z_mg))*torch.cos(x_mg)],\n    dim=1\n)\ngds=[\n    gd[0,0,:,15,15],\n    gd[0,1,15,:,15],\n    gd[0,2,15,15,:],\n]\npds=[\n    full_conv_u[0,0,:,15,15],\n    full_conv_u[0,1,15,:,15],\n    full_conv_u[0,2,15,15,:],\n]\nplot(gds, pds, x_label, labels)\n</pre> labels=[     r\"$[\\nabla \\cdot \\mathbf{u}\\mathbf{u}]_x$\",     r\"$[\\nabla \\cdot \\mathbf{u}\\mathbf{u}]_y$\",     r\"$[\\nabla \\cdot \\mathbf{u}\\mathbf{u}]_z$\", ] x_label=[\"$x$\",\"$y$\",\"$z$\"] gd=torch.cat(     [(-torch.sin(z_mg) + torch.cos(z_mg))*torch.sin(x_mg) - torch.sin(x_mg)*torch.sin(y_mg) + 2*torch.sin(x_mg)*torch.cos(x_mg),      (-torch.sin(z_mg) + torch.cos(z_mg))*torch.cos(y_mg) - 2*torch.sin(y_mg)*torch.cos(y_mg) + torch.cos(x_mg)*torch.cos(y_mg),      (-2*torch.sin(z_mg) + 2*torch.cos(z_mg))*(torch.sin(z_mg) + torch.cos(z_mg)) - (torch.sin(z_mg) + torch.cos(z_mg))*torch.sin(y_mg) + (torch.sin(z_mg) + torch.cos(z_mg))*torch.cos(x_mg)],     dim=1 ) gds=[     gd[0,0,:,15,15],     gd[0,1,15,:,15],     gd[0,2,15,15,:], ] pds=[     full_conv_u[0,0,:,15,15],     full_conv_u[0,1,15,:,15],     full_conv_u[0,2,15,15,:], ] plot(gds, pds, x_label, labels) In\u00a0[20]: Copied! <pre>from torchfsm.operator import Convection\nconvection=Convection()\nconv_u=convection(u,mesh=mesh_grid)\n</pre> from torchfsm.operator import Convection convection=Convection() conv_u=convection(u,mesh=mesh_grid) In\u00a0[21]: Copied! <pre>labels=[\n    r\"$[\\mathbf{u} \\cdot \\nabla  \\mathbf{u}]_x$\",\n    r\"$[\\mathbf{u} \\cdot \\nabla  \\mathbf{u}]_y$\",\n    r\"$[\\mathbf{u} \\cdot \\nabla  \\mathbf{u}]_z$\",\n]\nx_label=[\"$x$\",\"$y$\",\"$z$\"]\ngds = [\n    np.sin(x)*np.cos(x),\n    -1*np.sin(y)*np.cos(y),\n    np.cos(z)**2-np.sin(z)**2,\n]\npds=[\n    conv_u[0,0,:,15,15],\n    conv_u[0,1,15,:,15],\n    conv_u[0,2,15,15,:],\n]\nplot(gds, pds, x_label, labels)\n</pre> labels=[     r\"$[\\mathbf{u} \\cdot \\nabla  \\mathbf{u}]_x$\",     r\"$[\\mathbf{u} \\cdot \\nabla  \\mathbf{u}]_y$\",     r\"$[\\mathbf{u} \\cdot \\nabla  \\mathbf{u}]_z$\", ] x_label=[\"$x$\",\"$y$\",\"$z$\"] gds = [     np.sin(x)*np.cos(x),     -1*np.sin(y)*np.cos(y),     np.cos(z)**2-np.sin(z)**2, ] pds=[     conv_u[0,0,:,15,15],     conv_u[0,1,15,:,15],     conv_u[0,2,15,15,:], ] plot(gds, pds, x_label, labels)"},{"location":"tutorials/derivative_example/#notation","title":"Notation\u00b6","text":"<ul> <li>$\\mathbf{u}$: $n$ d vector field.</li> <li>$\\phi$: scalar field (0d vector field.).</li> <li>$i$: index of the coordinate.</li> <li>$I$: maximum index of the coordinate.</li> <li>$u_i$: $i$ th component of the vector field.</li> </ul>"},{"location":"tutorials/derivative_example/#spatial-derivative","title":"Spatial Derivative\u00b6","text":"<p><code>SpatialDeritivate</code> calculates the spatial derivative of a scalar field w.r.t to a spatial dimension:</p> $$ \\frac{\\partial ^n}{\\partial i} \\phi $$<p>where $n=1, 2, 3, \\cdots$</p>"},{"location":"tutorials/derivative_example/#gradient","title":"Gradient\u00b6","text":"<p><code>Grad</code> calculates the spatial gradient of a scalar field:</p> $$ \\nabla \\phi = \\left[\\begin{matrix} \\frac{\\partial \\phi}{\\partial x} \\\\ \\frac{\\partial \\phi}{\\partial y} \\\\ \\cdots \\\\ \\frac{\\partial \\phi}{\\partial I} \\\\ \\end{matrix} \\right] $$"},{"location":"tutorials/derivative_example/#divergence","title":"Divergence\u00b6","text":"<p><code>Div</code> calculates the divergence of a vector field:</p> $$ \\nabla \\cdot \\mathbf{u} = \\sum_{i=0}^I \\frac{\\partial u_i}{\\partial i} $$"},{"location":"tutorials/derivative_example/#laplacian","title":"Laplacian\u00b6","text":"<p><code>Laplacian</code> calculates the Laplacian of a vector field:</p> $$ \\nabla \\cdot (\\nabla\\mathbf{u}) =  \\nabla^2\\mathbf{u} = \\left[\\begin{matrix} \\sum_{i=0}^I \\frac{\\partial^2 u_x}{\\partial i^2 } \\\\ \\sum_{i=0}^I \\frac{\\partial^2 u_y}{\\partial i^2 } \\\\ \\cdots \\\\ \\sum_{i=0}^I \\frac{\\partial^2 u_I}{\\partial i^2 } \\\\ \\end{matrix} \\right] $$"},{"location":"tutorials/derivative_example/#biharmonic","title":"Biharmonic\u00b6","text":"<p><code>Biharmonic</code> calculates the Biharmonic of a vector field:</p> $$  \\nabla^4\\mathbf{u} = \\left[\\begin{matrix}  (\\sum_{i=0}^I\\frac{\\partial^2}{\\partial i^2 })(\\sum_{j=0}^I\\frac{\\partial^2}{\\partial j^2 })u_x \\\\ (\\sum_{i=0}^I\\frac{\\partial^2}{\\partial i^2 })(\\sum_{j=0}^I\\frac{\\partial^2}{\\partial j^2 })u_y \\\\ \\cdots \\\\ (\\sum_{i=0}^I\\frac{\\partial^2}{\\partial i^2 })(\\sum_{j=0}^I\\frac{\\partial^2}{\\partial j^2 })u_i \\\\ \\end{matrix} \\right] $$"},{"location":"tutorials/derivative_example/#curl","title":"Curl\u00b6","text":"<p><code>Curl</code> calculates the curl of a 2d vector or 3d vector field:</p> <ul> <li>2d vector field:</li> </ul> $$ \\nabla \\times \\mathbf{u} = \\frac{\\partial u_y}{\\partial x}-\\frac{\\partial u_x}{\\partial y} $$"},{"location":"tutorials/derivative_example/#conservativeconvection","title":"ConservativeConvection\u00b6","text":"<p><code>ConservativeConvection</code> calculates the convection of a vector field on itself.</p> $$ \\nabla \\cdot \\mathbf{u}\\mathbf{u} = \\left[\\begin{matrix} \\sum_{i=0}^I \\frac{\\partial u_i u_x }{\\partial i} \\\\ \\sum_{i=0}^I \\frac{\\partial u_i u_y }{\\partial i} \\\\ \\cdots\\\\ \\sum_{i=0}^I \\frac{\\partial u_i u_I }{\\partial i} \\\\ \\end{matrix} \\right] $$"},{"location":"tutorials/derivative_example/#convection","title":"Convection\u00b6","text":"<p><code>Convection</code> calculates the convection of a vector field on itself if the vector field is divergence free, i.e., $\\nabla \\cdot \\mathbf{u} =0$.</p> $$ \\mathbf{u} \\cdot \\nabla  \\mathbf{u} = \\left[\\begin{matrix} \\sum_{i=0}^I u_i\\frac{\\partial u_x }{\\partial i} \\\\ \\sum_{i=0}^I u_i\\frac{\\partial u_y }{\\partial i} \\\\ \\cdots\\\\ \\sum_{i=0}^I u_i\\frac{\\partial u_I }{\\partial i} \\\\ \\end{matrix} \\right] $$"},{"location":"tutorials/derivative_example/#conservative-convection-and-convection","title":"Conservative convection and convection\u00b6","text":"<p>In the above, we have <code>ConservativeConvection</code>: $\\nabla \\cdot \\mathbf{u}\\mathbf{u}$ and <code>Convection</code>: $\\mathbf{u} \\cdot \\nabla  \\mathbf{u}$.</p> <p>They have the following relationship:</p> $$ \\nabla \\cdot \\mathbf{u}\\mathbf{u}=\\mathbf{u} \\cdot \\nabla  \\mathbf{u}+ \\mathbf{u} \\nabla \\cdot \\mathbf{u} $$<ul> <li>$\\nabla \\cdot \\mathbf{u}\\mathbf{u}=\\mathbf{u} \\cdot \\nabla  \\mathbf{u}$ when $\\mathbf{u}$ is divergence free, i.e., $\\nabla \\cdot \\mathbf{u}=0$.</li> <li>$\\nabla \\cdot \\mathbf{u}\\mathbf{u}=2 \\mathbf{u} \\cdot \\nabla  \\mathbf{u}$ in 1d case.</li> </ul>"},{"location":"tutorials/introduction/","title":"0. Introduction","text":"TorchFSM Fourier Spectral Method with PyTorch"},{"location":"tutorials/introduction/#tldr","title":"TL;DR","text":"<p><code>TorchFSM</code> is a PyTorch-based library for solving PDEs using Fourier spectral method. It is designed for physics-based deep learning and differentiable simulations.</p>"},{"location":"tutorials/introduction/#simple-example","title":"Simple Example","text":"<p>Build a Burger equation with provided operators (the Burgers equation is also available at <code>torchfsm.pde</code>): <pre><code>from torchfsm.operator import Operator, Convection, Laplacian\n\ndef Burgers(nu:float) -&gt; Operator:\n    return nu*Laplacian()-Convection()\nburgers=Burgers(0.01)\n</code></pre> Simulate the Burgers equation at 1D mesh: <pre><code>from torchfsm.mesh import MeshGrid\nfrom torchfsm.plot import plot_traj\nfrom torchfsm.traj_recorder import AutoRecorder\nimport torch\n\ndevice='cuda' if torch.cuda.is_available() else 'cpu'\nL=1.0; N=128; \nmesh=MeshGrid([(0,L,N)],device=device)\nx=mesh.bc_mesh_grid()\nu_0=torch.sin(2*torch.pi*x/L)+0.5\n\ntraj=burgers.integrate(u_0=u_0,mesh=mesh,\n    dt=0.01,step=200,\n    trajectory_recorder=AutoRecorder(),\n)\nplot_traj(traj,animation=False,cmap=\"managua\")\n</code></pre> </p> <p>Directly simulate the Burgers on 2D mesh with the same operator: <pre><code>mesh=MeshGrid([(0,L,N),(0,L,N)],device=device)\nx,y=mesh.bc_mesh_grid()\nu_0=torch.cat([torch.sin(2*torch.pi*x/L)*torch.cos(4*torch.pi*y/L),\n               torch.cos(2*torch.pi*x/L)*torch.sin(4*torch.pi*y/L)],\n              dim=1)\n\ntraj=burgers.integrate(u_0=u_0,mesh=mesh,\n    dt=0.01,step=50,\n    trajectory_recorder=AutoRecorder(),\n)\n\nplot_traj(traj,animation=False,cmap=\"managua\")\n</code></pre> </p>"},{"location":"tutorials/introduction/#feature","title":"Feature","text":"<ul> <li> <p>Modular by design: TorchFSM offers a modular architecture with essential mathematical operators\u2014like divergence, gradient, and convection\u2014so you can build custom solvers like stacking building blocks, quickly and intuitively.</p> </li> <li> <p>GPU-accelerated: TorchFSM leverages GPU computing to speed up simulations dramatically. Run complex 3D PDEs in minutes, not hours, with seamless hardware acceleration.</p> </li> <li> <p>Batched simulation support: Built on PyTorch, TorchFSM enables batched simulations with varied initial conditions\u2014ideal for parameter sweeps, uncertainty quantification, or ensemble analysis.</p> </li> <li> <p>Differentiable and ML-ready: Fully differentiable by design, TorchFSM integrates naturally with machine learning workflows\u2014for residual operators, differentiable physics, or dataset generation.</p> </li> </ul>"},{"location":"tutorials/introduction/#installation","title":"Installation","text":"<ul> <li>Install through pip: <code>pip install torchfsm</code></li> <li>Install the latest version through pip: <code>pip install git+https://github.com/qiauil/torchfsm</code></li> <li>Install locally: Download the repository and run <code>pip install .</code></li> </ul>"},{"location":"tutorials/introduction/#documentations","title":"Documentations","text":"<p>Check \ud83d\udc49 here.</p>"},{"location":"tutorials/introduction/#citation","title":"Citation","text":"<p>We will be happy if you use <code>TorchFSM</code> in your research. If you find our work useful, please consider citing our repository:</p> <pre><code>@software{liu_2025_15350210,\n  author       = {Liu, Qiang and\n                  Koehler, Felix and\n                  Thuerey, Nils},\n  title        = {TorchFSM: Fourier Spectral Method with PyTorch},\n  month        = may,\n  year         = 2025,\n  publisher    = {Zenodo},\n  doi          = {10.5281/zenodo.15350210},\n  url          = {https://doi.org/10.5281/zenodo.15350210},\n}\n</code></pre>"},{"location":"tutorials/introduction/#further-information","title":"Further Information","text":"<ul> <li><code>TorchFSM</code> is mainly built by Qiang Liu, Felix Koehler, and Nils Thuerey at Physics Based Simulation Group, Technical University of Munich </li> <li>If you are more familiar with Jax, please check our Jax alternative Exponax</li> </ul>"},{"location":"tutorials/solve_de/","title":"3.1. Solve Differential Equations","text":"<p>As discussed in the theory introduction, the Fourier spectral method can be used to solve time-independent equations that consist only of linear terms.</p> <p>A classic example is Poisson\u2019s equation:</p> $$ \\nabla^2 \\phi(\\mathbf{x}) = s(\\mathbf{x}), $$<p>which can be solved in the Fourier domain as:</p> $$ \\phi(\\mathbf{x}) = \\mathcal{F}^{-1}\\left[\\frac{\\mathcal{F}[s(\\mathbf{x})]}{(2\\pi i \\mathbf{f})^2}\\right]. $$<p>In <code>TorchFSM</code>, this is achieved using the <code>solve</code> function of a <code>LinearOperator</code>. The <code>solve</code> function takes a right-hand-side tensor and returns the corresponding solution tensor.</p> <p>The following example demonstrates how to solve Poisson\u2019s equation with a given source tensor.</p> In\u00a0[\u00a0]: Copied! <pre>from torchfsm.operator import Laplacian\nfrom torchfsm.mesh import MeshGrid\nfrom torchfsm.plot import plot_field\nimport torch\n\nmesh=MeshGrid([(1,2*torch.pi,100)]*2)\nx,y=mesh.bc_mesh_grid()\ny=torch.cos(x)+torch.cos(y)\nplot_field(y)\nlaplacian=Laplacian()\nx=laplacian.solve(y,mesh=mesh,n_channel=1)\nplot_field(laplacian.solve(y,mesh=mesh,n_channel=1))\n</pre> from torchfsm.operator import Laplacian from torchfsm.mesh import MeshGrid from torchfsm.plot import plot_field import torch  mesh=MeshGrid([(1,2*torch.pi,100)]*2) x,y=mesh.bc_mesh_grid() y=torch.cos(x)+torch.cos(y) plot_field(y) laplacian=Laplacian() x=laplacian.solve(y,mesh=mesh,n_channel=1) plot_field(laplacian.solve(y,mesh=mesh,n_channel=1)) In\u00a0[6]: Copied! <pre>from torchfsm.field import wave_1d\nfrom torchfsm.mesh import MeshGrid\nfrom torchfsm.operator import Laplacian\nfrom torchfsm.traj_recorder import AutoRecorder\nfrom torchfsm.plot import plot_traj\n\nmesh=MeshGrid([(0,1,100)])\nx=mesh.bc_mesh_grid()\ndiffusion=0.01*Laplacian()\nu0=wave_1d(x)\nus=diffusion.integrate(u0,dt=0.01,step=20,mesh=mesh,trajectory_recorder=AutoRecorder())\nplot_traj(us,animation=True)\n</pre> from torchfsm.field import wave_1d from torchfsm.mesh import MeshGrid from torchfsm.operator import Laplacian from torchfsm.traj_recorder import AutoRecorder from torchfsm.plot import plot_traj  mesh=MeshGrid([(0,1,100)]) x=mesh.bc_mesh_grid() diffusion=0.01*Laplacian() u0=wave_1d(x) us=diffusion.integrate(u0,dt=0.01,step=20,mesh=mesh,trajectory_recorder=AutoRecorder()) plot_traj(us,animation=True) Out[6]:    Your browser does not support the video tag."},{"location":"tutorials/solve_de/#time-independent-problem","title":"Time Independent Problem\u00b6","text":""},{"location":"tutorials/solve_de/#time-dependent-problem","title":"Time-Dependent Problem\u00b6","text":"<p>For a time-dependent problem of the form:</p> $$ \\frac{\\partial \\mathbf{u}}{\\partial t} = F(u), $$<p>where $F(u)$ is a function that can be represented by an <code>Operator</code>, we can directly solve it using the <code>integrate</code> function of the <code>Operator</code> class.</p> <p>The following example demonstrates how to solve a simple 1D diffusion problem:</p>"},{"location":"tutorials/pdes/burgers/","title":"Burgers","text":"In\u00a0[1]: Copied! <pre>from torchfsm.operator import Operator, Convection, Laplacian\n\ndef Burgers(nu:float) -&gt; Operator:\n    return nu*Laplacian()-Convection()\nburgers=Burgers(0.01)\n</pre> from torchfsm.operator import Operator, Convection, Laplacian  def Burgers(nu:float) -&gt; Operator:     return nu*Laplacian()-Convection() burgers=Burgers(0.01) In\u00a0[2]: Copied! <pre>import torch\nfrom torchfsm.mesh import MeshGrid\nfrom torchfsm.plot import plot_traj\nfrom torchfsm.traj_recorder import AutoRecorder\ndevice='cuda' if torch.cuda.is_available() else 'cpu'\nL=1.0; N=128; \n</pre> import torch from torchfsm.mesh import MeshGrid from torchfsm.plot import plot_traj from torchfsm.traj_recorder import AutoRecorder device='cuda' if torch.cuda.is_available() else 'cpu' L=1.0; N=128;  In\u00a0[3]: Copied! <pre>mesh=MeshGrid([(0,L,N)],device=device)\nx=mesh.bc_mesh_grid()\nu_0=torch.sin(2*torch.pi*x/L)+0.5\ntraj=burgers.integrate(\n    u_0=u_0,\n    mesh=mesh,\n    dt=0.01,\n    step=200,\n    trajectory_recorder=AutoRecorder(),\n)\n</pre> mesh=MeshGrid([(0,L,N)],device=device) x=mesh.bc_mesh_grid() u_0=torch.sin(2*torch.pi*x/L)+0.5 traj=burgers.integrate(     u_0=u_0,     mesh=mesh,     dt=0.01,     step=200,     trajectory_recorder=AutoRecorder(), ) In\u00a0[4]: Copied! <pre>plot_traj(traj,animation=False)\n</pre> plot_traj(traj,animation=False) <p>We also randomly generate a batch of initial conditions and solve the Burgers equation in a batched manner:</p> In\u00a0[17]: Copied! <pre>from torchfsm.field import wave_1d\nx=mesh.bc_mesh_grid(batch_size=3)\nu_0=wave_1d(x,\n            batched=True,\n            min_k=2,max_k=3,\n            min_amplitude=0.1,\n            max_amplitude=0.5,\n            mean_shift_coef=2)\ntraj=burgers.integrate(\n    u_0=u_0,\n    mesh=mesh,\n    dt=0.005,\n    step=200,\n    trajectory_recorder=AutoRecorder(),\n)\n</pre> from torchfsm.field import wave_1d x=mesh.bc_mesh_grid(batch_size=3) u_0=wave_1d(x,             batched=True,             min_k=2,max_k=3,             min_amplitude=0.1,             max_amplitude=0.5,             mean_shift_coef=2) traj=burgers.integrate(     u_0=u_0,     mesh=mesh,     dt=0.005,     step=200,     trajectory_recorder=AutoRecorder(), ) In\u00a0[18]: Copied! <pre>plot_traj(traj,animation=False)\n</pre> plot_traj(traj,animation=False) In\u00a0[5]: Copied! <pre>mesh=MeshGrid([(0,L,N),(0,L,N)],device=device)\nx,y=mesh.bc_mesh_grid()\nu_0=torch.cat([torch.sin(2*torch.pi*x/L)*torch.cos(4*torch.pi*y/L),\n               torch.cos(2*torch.pi*x/L)*torch.sin(4*torch.pi*y/L)],\n              dim=1)\ntraj=burgers.integrate(\n    u_0=u_0,\n    mesh=mesh,\n    dt=0.01,\n    step=50,\n    trajectory_recorder=AutoRecorder(),\n)\n</pre> mesh=MeshGrid([(0,L,N),(0,L,N)],device=device) x,y=mesh.bc_mesh_grid() u_0=torch.cat([torch.sin(2*torch.pi*x/L)*torch.cos(4*torch.pi*y/L),                torch.cos(2*torch.pi*x/L)*torch.sin(4*torch.pi*y/L)],               dim=1) traj=burgers.integrate(     u_0=u_0,     mesh=mesh,     dt=0.01,     step=50,     trajectory_recorder=AutoRecorder(), ) In\u00a0[6]: Copied! <pre>plot_traj(traj)\n</pre> plot_traj(traj) Out[6]:    Your browser does not support the video tag.  In\u00a0[7]: Copied! <pre>mesh=MeshGrid([(0,L,N),(0,L,N),(0,L,N)],device=device)\nx,y,z=mesh.bc_mesh_grid()\nu_0=torch.cat([torch.sin(2*torch.pi*x/L)*torch.cos(4*torch.pi*y/L)*torch.sin(6*torch.pi*z/L),\n               torch.cos(2*torch.pi*x/L)*torch.sin(4*torch.pi*y/L)*torch.cos(6*torch.pi*z/L),\n               torch.sin(2*torch.pi*x/L)*torch.cos(4*torch.pi*y/L)*torch.sin(6*torch.pi*z/L)],\n              dim=1)\ntraj=burgers.integrate(\n    u_0=u_0,\n    mesh=mesh,\n    dt=0.01,\n    step=50,\n    trajectory_recorder=AutoRecorder(),\n)\n</pre> mesh=MeshGrid([(0,L,N),(0,L,N),(0,L,N)],device=device) x,y,z=mesh.bc_mesh_grid() u_0=torch.cat([torch.sin(2*torch.pi*x/L)*torch.cos(4*torch.pi*y/L)*torch.sin(6*torch.pi*z/L),                torch.cos(2*torch.pi*x/L)*torch.sin(4*torch.pi*y/L)*torch.cos(6*torch.pi*z/L),                torch.sin(2*torch.pi*x/L)*torch.cos(4*torch.pi*y/L)*torch.sin(6*torch.pi*z/L)],               dim=1) traj=burgers.integrate(     u_0=u_0,     mesh=mesh,     dt=0.01,     step=50,     trajectory_recorder=AutoRecorder(), ) In\u00a0[8]: Copied! <pre>plot_traj(traj)\n</pre> plot_traj(traj) Out[8]:    Your browser does not support the video tag."},{"location":"tutorials/pdes/burgers/#burgers-equation","title":"Burgers Equation\u00b6","text":"<p>Burgers equation:</p> $$ \\frac{\\partial \\mathbf{u}}{\\partial t} =-\\mathbf{u} \\cdot \\nabla \\mathbf{u} + \\nu \\nabla^2 \\mathbf{u} $$"},{"location":"tutorials/pdes/burgers/#solution-in-1d","title":"Solution in 1D\u00b6","text":""},{"location":"tutorials/pdes/burgers/#solution-in-2d","title":"Solution in 2D\u00b6","text":""},{"location":"tutorials/pdes/burgers/#solution-in-3d","title":"Solution in 3D\u00b6","text":""},{"location":"tutorials/pdes/burgers_example/","title":"Burgers example","text":"In\u00a0[\u00a0]: Copied! <pre>from torchfsm.operator import Operator, Convection, Laplacian\n\ndef Burgers(nu:float) -&gt; Operator:\n    return nu*Laplacian()-Convection()\nburgers=Burgers(0.01)\n</pre> from torchfsm.operator import Operator, Convection, Laplacian  def Burgers(nu:float) -&gt; Operator:     return nu*Laplacian()-Convection() burgers=Burgers(0.01) In\u00a0[\u00a0]: Copied! <pre>from torchfsm.mesh import MeshGrid\nfrom torchfsm.plot import plot_traj\nfrom torchfsm.traj_recorder import AutoRecorder\nimport torch\n\ndevice='cuda' if torch.cuda.is_available() else 'cpu'\nL=1.0; N=128; \nmesh=MeshGrid([(0,L,N)],device=device)\nx=mesh.bc_mesh_grid()\nu_0=torch.sin(2*torch.pi*x/L)+0.5\ntraj=burgers.integrate(u_0=u_0,mesh=mesh,\n    dt=0.01,step=200,\n    trajectory_recorder=AutoRecorder(),\n)\nplot_traj(traj,animation=False,cmap=\"managua\")\n</pre> from torchfsm.mesh import MeshGrid from torchfsm.plot import plot_traj from torchfsm.traj_recorder import AutoRecorder import torch  device='cuda' if torch.cuda.is_available() else 'cpu' L=1.0; N=128;  mesh=MeshGrid([(0,L,N)],device=device) x=mesh.bc_mesh_grid() u_0=torch.sin(2*torch.pi*x/L)+0.5 traj=burgers.integrate(u_0=u_0,mesh=mesh,     dt=0.01,step=200,     trajectory_recorder=AutoRecorder(), ) plot_traj(traj,animation=False,cmap=\"managua\") In\u00a0[\u00a0]: Copied! <pre>mesh=MeshGrid([(0,L,N),(0,L,N)],device=device)\nx,y=mesh.bc_mesh_grid()\nu_0=torch.cat([torch.sin(2*torch.pi*x/L)*torch.cos(4*torch.pi*y/L),\n               torch.cos(2*torch.pi*x/L)*torch.sin(4*torch.pi*y/L)],\n              dim=1)\ntraj=burgers.integrate(u_0=u_0,mesh=mesh,\n    dt=0.01,step=50,\n    trajectory_recorder=AutoRecorder(),\n)\nplot_traj(traj,animation=False,cmap=\"managua\")\n</pre> mesh=MeshGrid([(0,L,N),(0,L,N)],device=device) x,y=mesh.bc_mesh_grid() u_0=torch.cat([torch.sin(2*torch.pi*x/L)*torch.cos(4*torch.pi*y/L),                torch.cos(2*torch.pi*x/L)*torch.sin(4*torch.pi*y/L)],               dim=1) traj=burgers.integrate(u_0=u_0,mesh=mesh,     dt=0.01,step=50,     trajectory_recorder=AutoRecorder(), ) plot_traj(traj,animation=False,cmap=\"managua\")"},{"location":"tutorials/pdes/korteweg_de_vries/","title":"Korteweg de Vries","text":"In\u00a0[1]: Copied! <pre>from torchfsm.operator import Operator, Convection, SpatialDerivative\n\ndef KortewegDeVries(dispersion_coef=1,convection_coef:float=6.0) -&gt; Operator:\n    return -dispersion_coef*SpatialDerivative(0,3)+convection_coef*Convection()\n\n# same configuration as the animation in wikipedia\nkdv=KortewegDeVries(0.022**2,-1)\n</pre> from torchfsm.operator import Operator, Convection, SpatialDerivative  def KortewegDeVries(dispersion_coef=1,convection_coef:float=6.0) -&gt; Operator:     return -dispersion_coef*SpatialDerivative(0,3)+convection_coef*Convection()  # same configuration as the animation in wikipedia kdv=KortewegDeVries(0.022**2,-1) In\u00a0[2]: Copied! <pre>import torch\nfrom torchfsm.mesh import MeshGrid\nfrom torchfsm.plot import plot_traj\nfrom torchfsm.traj_recorder import AutoRecorder,IntervalController\ndevice='cuda' if torch.cuda.is_available() else 'cpu'\nL=2.0; N=256; \n\nmesh=MeshGrid([(0,L,N)],device=device)\nx=mesh.bc_mesh_grid()\nu_0=torch.cos(torch.pi*x)\ntraj=kdv.integrate(\n    u_0=u_0,\n    mesh=mesh,\n    dt=0.001,\n    step=2000,\n    trajectory_recorder=AutoRecorder(IntervalController(10))\n)\n</pre> import torch from torchfsm.mesh import MeshGrid from torchfsm.plot import plot_traj from torchfsm.traj_recorder import AutoRecorder,IntervalController device='cuda' if torch.cuda.is_available() else 'cpu' L=2.0; N=256;   mesh=MeshGrid([(0,L,N)],device=device) x=mesh.bc_mesh_grid() u_0=torch.cos(torch.pi*x) traj=kdv.integrate(     u_0=u_0,     mesh=mesh,     dt=0.001,     step=2000,     trajectory_recorder=AutoRecorder(IntervalController(10)) ) In\u00a0[3]: Copied! <pre>plot_traj(traj)\n# check https://en.wikipedia.org/wiki/File:KdV_equation.gif for comparison\n</pre> plot_traj(traj) # check https://en.wikipedia.org/wiki/File:KdV_equation.gif for comparison Out[3]:    Your browser does not support the video tag."},{"location":"tutorials/pdes/korteweg_de_vries/#kortewegde-vries-equation","title":"Korteweg\u2013De Vries equation\u00b6","text":"<p>The Korteweg\u2013De Vries equation is defined on 1D space with the following form:</p> $$ \\frac{\\partial \\phi}{\\partial t} =-c_1\\frac{\\partial^3 \\phi}{\\partial x^3} + c_2 \\phi\\frac{\\partial\\phi}{\\partial x} $$<p>where $c_1$ and $c_2$ are constants.</p>"},{"location":"tutorials/pdes/kuramoto_sivashinsky/","title":"Kuramoto Sivashinsky","text":"In\u00a0[1]: Copied! <pre>from torchfsm.operator import Operator, Laplacian, Biharmonic, Convection\n\ndef KuramotoSivashinsky() -&gt; Operator:\n    ks_eqn = -Laplacian()- Biharmonic()-Convection()\n    ks_eqn.regisiter_additional_check(lambda dim_value,dim_mesh: dim_value ==1 and dim_mesh ==1)\n    return ks_eqn\nks_eqn=KuramotoSivashinsky()\n</pre> from torchfsm.operator import Operator, Laplacian, Biharmonic, Convection  def KuramotoSivashinsky() -&gt; Operator:     ks_eqn = -Laplacian()- Biharmonic()-Convection()     ks_eqn.regisiter_additional_check(lambda dim_value,dim_mesh: dim_value ==1 and dim_mesh ==1)     return ks_eqn ks_eqn=KuramotoSivashinsky() In\u00a0[2]: Copied! <pre>import torch\nfrom torchfsm.mesh import MeshGrid\nfrom torchfsm.traj_recorder import AutoRecorder, IntervalController\nfrom torchfsm.plot import plot_traj\ndevice='cuda' if torch.cuda.is_available() else 'cpu'\nL=60.0; N=100; \n\nmesh=MeshGrid([(0,L,N)],device=device)\nx=mesh.bc_mesh_grid()\nu_0=torch.randn_like(x)\ntraj=ks_eqn.integrate(\n    u_0=u_0,\n    mesh=mesh,\n    dt=0.5,\n    step=200,\n    trajectory_recorder=AutoRecorder(),\n)\n</pre> import torch from torchfsm.mesh import MeshGrid from torchfsm.traj_recorder import AutoRecorder, IntervalController from torchfsm.plot import plot_traj device='cuda' if torch.cuda.is_available() else 'cpu' L=60.0; N=100;   mesh=MeshGrid([(0,L,N)],device=device) x=mesh.bc_mesh_grid() u_0=torch.randn_like(x) traj=ks_eqn.integrate(     u_0=u_0,     mesh=mesh,     dt=0.5,     step=200,     trajectory_recorder=AutoRecorder(), ) In\u00a0[3]: Copied! <pre>plot_traj(traj,animation=False)\n</pre> plot_traj(traj,animation=False) <p>If you add different coefficients to the terms, you can control the behavior of the solution. For example, a benchmark KS problem $^{[1,2]}$ in PINNs has the following form:</p> $$  \\frac{\\partial \\phi}{\\partial t}=-\\frac{100}{16^2}\\frac{\\partial^2 \\phi}{\\partial x^2}-\\frac{100}{16^4}\\frac{\\partial^4 \\phi}{\\partial x^4}-\\frac{100}{16}\\phi\\frac{\\partial \\phi}{\\partial x} $$ <p>[1] Zhongkai Hao, Jiachen Yao, Chang Su, et al.. \"PINNacle: A Comprehensive Benchmark of Physics-Informed Neural Networks for Solving PDEs.\" Arxiv preprint 2306.08827.</p> <p>[2] Sifan Wang, Shyam Sankaran, and Paris Perdikaris. \u201cRespecting causality for training physics-informed neural networks.\u201d Computer Methods in Applied Mechanics and Engineering 421 (2024): 116813.</p> <p>With these coefficients, you can observe the transition to a chaotic state within a short time:</p> In\u00a0[4]: Copied! <pre>def KuramotoSivashinsky_Coef(a=100/16**2,b=100/16**4,c=100/16) -&gt; Operator:\n    ks_eqn = -a*Laplacian() - b*Biharmonic() - c*Convection()\n    ks_eqn.regisiter_additional_check(lambda dim_value,dim_mesh: dim_value ==1 and dim_mesh ==1)\n    return ks_eqn\nks_eqn=KuramotoSivashinsky_Coef()\n</pre> def KuramotoSivashinsky_Coef(a=100/16**2,b=100/16**4,c=100/16) -&gt; Operator:     ks_eqn = -a*Laplacian() - b*Biharmonic() - c*Convection()     ks_eqn.regisiter_additional_check(lambda dim_value,dim_mesh: dim_value ==1 and dim_mesh ==1)     return ks_eqn ks_eqn=KuramotoSivashinsky_Coef() In\u00a0[5]: Copied! <pre>mesh=MeshGrid([(0,2*torch.pi,N)],device=device)\nx=mesh.bc_mesh_grid()\nu_0=torch.cos(x)*(1+torch.sin(x))\ntraj=ks_eqn.integrate(\n    u_0=u_0,\n    mesh=mesh,\n    dt=0.01,\n    step=100,\n    trajectory_recorder=AutoRecorder(),\n)\n</pre> mesh=MeshGrid([(0,2*torch.pi,N)],device=device) x=mesh.bc_mesh_grid() u_0=torch.cos(x)*(1+torch.sin(x)) traj=ks_eqn.integrate(     u_0=u_0,     mesh=mesh,     dt=0.01,     step=100,     trajectory_recorder=AutoRecorder(), ) In\u00a0[6]: Copied! <pre>plot_traj(traj,animation=False)\n</pre> plot_traj(traj,animation=False) In\u00a0[7]: Copied! <pre>from torchfsm.operator import KSConvection\ndef KuramotoSivashinskyHighDim() -&gt; Operator:\n    return -Laplacian()- Biharmonic()-KSConvection()\nks_eqn=KuramotoSivashinskyHighDim()\n</pre> from torchfsm.operator import KSConvection def KuramotoSivashinskyHighDim() -&gt; Operator:     return -Laplacian()- Biharmonic()-KSConvection() ks_eqn=KuramotoSivashinskyHighDim() In\u00a0[8]: Copied! <pre>mesh=MeshGrid([(0,L,N),(0,L,N)],device=device)\nx,y=mesh.bc_mesh_grid()\nu_0=torch.randn_like(x)\ntraj=ks_eqn.integrate(\n    u_0=u_0,\n    mesh=mesh,\n    dt=0.5,\n    step=200,\n    trajectory_recorder=AutoRecorder(IntervalController(start=50),\n                                     include_initial_state=False),\n)\n</pre> mesh=MeshGrid([(0,L,N),(0,L,N)],device=device) x,y=mesh.bc_mesh_grid() u_0=torch.randn_like(x) traj=ks_eqn.integrate(     u_0=u_0,     mesh=mesh,     dt=0.5,     step=200,     trajectory_recorder=AutoRecorder(IntervalController(start=50),                                      include_initial_state=False), ) In\u00a0[9]: Copied! <pre>plot_traj(traj,animation=True)\n</pre> plot_traj(traj,animation=True) Out[9]:    Your browser does not support the video tag.  In\u00a0[10]: Copied! <pre>mesh=MeshGrid([(0,L,N),(0,L,N),(0,L,N)],device=device)\nx,_,_=mesh.bc_mesh_grid()\nu_0=torch.randn_like(x)\ntraj=ks_eqn.integrate(\n    u_0=u_0,\n    mesh=mesh,\n    dt=0.5,\n    step=200,\n    trajectory_recorder=AutoRecorder(IntervalController(start=50),\n                                     include_initial_state=False),\n)\n</pre> mesh=MeshGrid([(0,L,N),(0,L,N),(0,L,N)],device=device) x,_,_=mesh.bc_mesh_grid() u_0=torch.randn_like(x) traj=ks_eqn.integrate(     u_0=u_0,     mesh=mesh,     dt=0.5,     step=200,     trajectory_recorder=AutoRecorder(IntervalController(start=50),                                      include_initial_state=False), ) In\u00a0[11]: Copied! <pre>plot_traj(traj)\n</pre> plot_traj(traj) Out[11]:    Your browser does not support the video tag."},{"location":"tutorials/pdes/kuramoto_sivashinsky/#kuramotosivashinsky-equation","title":"Kuramoto\u2013Sivashinsky Equation\u00b6","text":"<p>Usually, the Kuramoto\u2013Sivashinsky equation is defined on 1D space with the following form:</p> $$ \\frac{\\partial \\phi}{\\partial t} =-\\frac{\\partial^2 \\phi}{\\partial x^2} -\\frac{\\partial^4 \\phi}{\\partial x^4} - \\phi\\frac{\\partial\\phi}{\\partial x} $$"},{"location":"tutorials/pdes/kuramoto_sivashinsky/#solution-in-1d","title":"Solution in 1D\u00b6","text":""},{"location":"tutorials/pdes/kuramoto_sivashinsky/#solution-in-2d","title":"Solution in 2D\u00b6","text":"<p>The Kuramoto\u2013Sivashinsky equation can also be generalized to higher dimensions. In spatially periodic domains, one possibility is</p> $$ \\frac{\\partial \\mathbf{\\phi}}{\\partial t} =-\\nabla^2 \\phi- \\nabla^4 \\phi - \\frac{1}{2}|\\nabla \\phi|^2 $$<p>Note that the above two equations are also not equivalent in 1D space.</p> <p>We can solve the 2D KS equation using the same approach as in the 1D case:</p>"},{"location":"tutorials/pdes/kuramoto_sivashinsky/#solution-in-3d","title":"Solution in 3D\u00b6","text":""},{"location":"tutorials/pdes/ns_velocity/","title":"2.3.4.1 Velocity Based","text":"In\u00a0[1]: Copied! <pre>from torchfsm.operator import Laplacian,Operator,NSPressureConvection\n\ndef NavierStokes(Re:float)-&gt;Operator:\n    return NSPressureConvection()+1/Re*Laplacian()\n</pre> from torchfsm.operator import Laplacian,Operator,NSPressureConvection  def NavierStokes(Re:float)-&gt;Operator:     return NSPressureConvection()+1/Re*Laplacian() In\u00a0[2]: Copied! <pre>from torchfsm.mesh import MeshGrid\nfrom torchfsm.traj_recorder import CPURecorder,IntervalController\nimport numpy as np\nimport torch\n\nmesh=MeshGrid([(0,2*np.pi,128),\n               (0,2*np.pi,128),\n               (0,2*np.pi,128)],\n               device='cuda')\nx,y,z=mesh.bc_mesh_grid()\nu=torch.cat(\n    [torch.sin(x)*torch.cos(y)*torch.cos(z),\n     -torch.cos(x)*torch.sin(y)*torch.cos(z),\n     torch.zeros_like(x)],\n    dim=1)\nns=NavierStokes(1600)\ntraj=ns.integrate(\n    u,\n    dt=0.001,\n    step=10000,\n    mesh=mesh,\n    trajectory_recorder=CPURecorder(control_func=IntervalController(200)),\n    progressive=True\n)\n</pre> from torchfsm.mesh import MeshGrid from torchfsm.traj_recorder import CPURecorder,IntervalController import numpy as np import torch  mesh=MeshGrid([(0,2*np.pi,128),                (0,2*np.pi,128),                (0,2*np.pi,128)],                device='cuda') x,y,z=mesh.bc_mesh_grid() u=torch.cat(     [torch.sin(x)*torch.cos(y)*torch.cos(z),      -torch.cos(x)*torch.sin(y)*torch.cos(z),      torch.zeros_like(x)],     dim=1) ns=NavierStokes(1600) traj=ns.integrate(     u,     dt=0.001,     step=10000,     mesh=mesh,     trajectory_recorder=CPURecorder(control_func=IntervalController(200)),     progressive=True ) <pre>Integrating:   0%|          | 0/10000 [00:00&lt;?, ?it/s]</pre> In\u00a0[3]: Copied! <pre>from torchfsm.plot import plot_traj\nplot_traj(traj)\n</pre> from torchfsm.plot import plot_traj plot_traj(traj) Out[3]:    Your browser does not support the video tag.  <p>The pressure filed can be obtained through postprocess:</p> <p>In <code>TorchFSM</code> we use the <code>ETDRK</code> integrator by default. The <code>ETDRK</code> integrator can accurately solve the PDE with large time step while requiring high memory, which could be a server issue for 3D turbulence simulation. Thus, we also provide the classical Runge-Kutta integrator, which is more memory efficient but less accurate. For example, we can use the simple Euler integrator for the above simulation:</p>"},{"location":"tutorials/pdes/ns_velocity/#pressure-poisson-equation","title":"Pressure Poisson Equation\u00b6","text":"<p>In this notebook, we provide examples of directly solving the Navier-Stokes equations in velocity space. To do this, we need to derive the pressure Poisson equation from the Navier-Stokes equations. Given the Navier-Stokes equations:</p> $$ \\begin{align} \\frac{\\partial\\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} &amp;= -\\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f}, \\\\ \\nabla \\cdot \\mathbf{u} &amp;= 0, \\end{align} $$<p>we can take the divergence of the first equation and use the second equation to eliminate some terms:</p> <ul> <li>The divergence of the time derivative term:</li> </ul> $$ \\nabla \\cdot \\frac{\\partial \\mathbf{u}}{\\partial t} = \\frac{\\partial}{\\partial t} (\\nabla \\cdot \\mathbf{u}) = 0. $$<ul> <li>The divergence of the pressure gradient term:</li> </ul> $$ \\nabla \\cdot \\nabla p = \\nabla^2 p. $$<ul> <li>The divergence of the viscous term:</li> </ul> $$ \\nabla \\cdot \\nu \\nabla^2 \\mathbf{u} = \\nu \\nabla^2 (\\nabla \\cdot \\mathbf{u}) = 0. $$<p>The convection term and the external force term are not divergence-free, so we retain them. Thus, we have:</p> $$ \\nabla \\cdot \\left[ (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} - \\mathbf{f} \\right] = -\\nabla^2 p. $$<p>This is the Poisson equation for the pressure. The solution of the Poisson equation gives us the pressure field, which we can use to compute the velocity field.</p> <p>In <code>TorchFSM</code>, we directly integrate the Poisson equation into the momentum equation to obtain the velocity:</p> $$ \\frac{\\partial \\mathbf{u}}{\\partial t} =  - \\nabla \\left( \\nabla^{-2} \\nabla \\cdot \\left[ (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} - \\mathbf{f} \\right] \\right) - (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f}. $$<p>The pressure is then solved by solving the Poisson equation in a postprocessing step. Since the convection term and the external force term are also involved in solving the pressure, we integrate these three terms together to avoid recomputing them. The <code>NSPressureConvection</code> is defined as:</p> $$ - \\nabla \\left( \\nabla^{-2} \\nabla \\cdot \\left[ (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} - \\mathbf{f} \\right] \\right) - (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} + \\mathbf{f}. $$"},{"location":"tutorials/pdes/ns_velocity/#3d-taylor-green-flow","title":"3D Taylor-Green Flow\u00b6","text":"<p>In the following example, we demonstrate a 3D Taylor-Green vortex decay. The initial velocity field is given by a series of sine and cosine functions.</p>"},{"location":"tutorials/pdes/ns_velocity/#3d-isotropic-turbulence","title":"3D isotropic turbulence\u00b6","text":"<p>To be updated...</p>"},{"location":"tutorials/pdes/ns_velocity_example/","title":"Ns velocity example","text":"In\u00a0[1]: Copied! <pre>from torchfsm.operator import Laplacian,Operator,NSPressureConvection\n\ndef NavierStokes(Re:float)-&gt;Operator:\n    return NSPressureConvection()+1/Re*Laplacian()\n</pre> from torchfsm.operator import Laplacian,Operator,NSPressureConvection  def NavierStokes(Re:float)-&gt;Operator:     return NSPressureConvection()+1/Re*Laplacian() In\u00a0[2]: Copied! <pre>from torchfsm.mesh import MeshGrid\nfrom torchfsm.traj_recorder import CPURecorder,IntervalController\nimport numpy as np\nimport torch\n\nmesh=MeshGrid([(0,2*np.pi,128),\n               (0,2*np.pi,128),\n               (0,2*np.pi,128)],\n               device='cuda')\nx,y,z=mesh.bc_mesh_grid()\nu=torch.cat(\n    [torch.sin(x)*torch.cos(y)*torch.cos(z),\n     -torch.cos(x)*torch.sin(y)*torch.cos(z),\n     torch.zeros_like(x)],\n    dim=1)\nns=NavierStokes(1600)\ntraj=ns.integrate(\n    u,\n    dt=0.001,\n    step=10000,\n    mesh=mesh,\n    trajectory_recorder=CPURecorder(control_func=IntervalController(200)),\n    progressive=True\n)\n</pre> from torchfsm.mesh import MeshGrid from torchfsm.traj_recorder import CPURecorder,IntervalController import numpy as np import torch  mesh=MeshGrid([(0,2*np.pi,128),                (0,2*np.pi,128),                (0,2*np.pi,128)],                device='cuda') x,y,z=mesh.bc_mesh_grid() u=torch.cat(     [torch.sin(x)*torch.cos(y)*torch.cos(z),      -torch.cos(x)*torch.sin(y)*torch.cos(z),      torch.zeros_like(x)],     dim=1) ns=NavierStokes(1600) traj=ns.integrate(     u,     dt=0.001,     step=10000,     mesh=mesh,     trajectory_recorder=CPURecorder(control_func=IntervalController(200)),     progressive=True ) <pre>Integrating:   0%|          | 0/10000 [00:00&lt;?, ?it/s]</pre> In\u00a0[4]: Copied! <pre>import seaborn as sns\ncmap = sns.color_palette(\"twilight\", as_cmap=True)\n</pre> import seaborn as sns cmap = sns.color_palette(\"twilight\", as_cmap=True) In\u00a0[7]: Copied! <pre>from torchfsm.plot import plot_traj\nplot_traj(traj,cmap=\"twilight\",channel_names=[\"u\",\"v\",\"w\"],fps=10)\n</pre> from torchfsm.plot import plot_traj plot_traj(traj,cmap=\"twilight\",channel_names=[\"u\",\"v\",\"w\"],fps=10) Out[7]:    Your browser does not support the video tag."},{"location":"tutorials/pdes/ns_vorticity/","title":"2.3.4.1 Vorticity Based","text":"In\u00a0[1]: Copied! <pre>from torchfsm.operator import Laplacian,Operator,VorticityConvection\nfrom typing import Optional\n\ndef NavierStokesVorticity(Re:float=100,force:Optional[Operator]=None)-&gt;Operator:\n    ns_vorticity=-VorticityConvection() + 1/Re*Laplacian()\n    if force is not None:\n        ns_vorticity+=force\n    return ns_vorticity\n</pre> from torchfsm.operator import Laplacian,Operator,VorticityConvection from typing import Optional  def NavierStokesVorticity(Re:float=100,force:Optional[Operator]=None)-&gt;Operator:     ns_vorticity=-VorticityConvection() + 1/Re*Laplacian()     if force is not None:         ns_vorticity+=force     return ns_vorticity In\u00a0[2]: Copied! <pre>import torch\nfrom torchfsm.mesh import MeshGrid\nfrom torchfsm.plot import plot_traj,plot_field\nfrom torchfsm.field import kolm_force,diffused_noise\nfrom torchfsm.traj_recorder import AutoRecorder,IntervalController\ndevice='cuda' if torch.cuda.is_available() else 'cpu'\nL=torch.pi*2; N=128; \n\nmesh=MeshGrid([(0,L,N),(0,L,N)],device=device)\nx,y=mesh.bc_mesh_grid()\n</pre> import torch from torchfsm.mesh import MeshGrid from torchfsm.plot import plot_traj,plot_field from torchfsm.field import kolm_force,diffused_noise from torchfsm.traj_recorder import AutoRecorder,IntervalController device='cuda' if torch.cuda.is_available() else 'cpu' L=torch.pi*2; N=128;   mesh=MeshGrid([(0,L,N),(0,L,N)],device=device) x,y=mesh.bc_mesh_grid() In\u00a0[3]: Copied! <pre>decayed=NavierStokesVorticity(Re=1000)\nu0=diffused_noise(mesh,device=device,n_batch=2,\n                  zero_centered=False,\n                  unit_magnitude=True,\n                  unit_variance=False,\n                  diffusion_coef=0.05)\ntraj=decayed.integrate(\n        u_0=u0,\n        mesh=mesh,\n        dt=0.1,\n        step=100*50,\n        trajectory_recorder=AutoRecorder(IntervalController(interval=50)),\n        progressive=True\n    )\n</pre> decayed=NavierStokesVorticity(Re=1000) u0=diffused_noise(mesh,device=device,n_batch=2,                   zero_centered=False,                   unit_magnitude=True,                   unit_variance=False,                   diffusion_coef=0.05) traj=decayed.integrate(         u_0=u0,         mesh=mesh,         dt=0.1,         step=100*50,         trajectory_recorder=AutoRecorder(IntervalController(interval=50)),         progressive=True     ) <pre>Integrating:   0%|          | 0/5000 [00:00&lt;?, ?it/s]</pre> In\u00a0[4]: Copied! <pre>plot_traj(traj)\n</pre> plot_traj(traj) Out[4]:    Your browser does not support the video tag.  In\u00a0[5]: Copied! <pre>kolm=NavierStokesVorticity(Re=100,force=kolm_force(y),)\nu0=diffused_noise(mesh,device=device,n_batch=2)\ntraj=kolm.integrate(\n        u_0=u0,\n        mesh=mesh,\n        dt=0.5/50,\n        step=100*50,\n        trajectory_recorder=AutoRecorder(IntervalController(interval=50))\n    )\n</pre> kolm=NavierStokesVorticity(Re=100,force=kolm_force(y),) u0=diffused_noise(mesh,device=device,n_batch=2) traj=kolm.integrate(         u_0=u0,         mesh=mesh,         dt=0.5/50,         step=100*50,         trajectory_recorder=AutoRecorder(IntervalController(interval=50))     ) <p>Note that the force term in <code>NavierStokesVorticity</code> is actually the curl of the original force term in the Navier-Stokes equations, i.e., $\\nabla \\times \\mathbf{f}$</p> In\u00a0[6]: Copied! <pre>plot_traj(traj)\n</pre> plot_traj(traj) Out[6]:    Your browser does not support the video tag.  In\u00a0[7]: Copied! <pre>from torchfsm.operator import Vorticity2Velocity\n\nv2v=Vorticity2Velocity()\nori_shape=traj.shape\ntraj=traj.view(-1,*ori_shape[2:]) # move the time dimension to the batch dimension for parallelism\nvelocity=v2v(traj,mesh=mesh).view(*ori_shape[0:2],2,*ori_shape[3:])\n</pre> from torchfsm.operator import Vorticity2Velocity  v2v=Vorticity2Velocity() ori_shape=traj.shape traj=traj.view(-1,*ori_shape[2:]) # move the time dimension to the batch dimension for parallelism velocity=v2v(traj,mesh=mesh).view(*ori_shape[0:2],2,*ori_shape[3:]) In\u00a0[8]: Copied! <pre>plot_traj(velocity,channel_names=['$u_x$','$u_y$'])\n</pre> plot_traj(velocity,channel_names=['$u_x$','$u_y$']) Out[8]:    Your browser does not support the video tag.  <p>Meanwhile, the pressure can also be solved through the Pressure Poisson equation, which we will discuss in the next section. But here we can show how we do it using our operator.</p> In\u00a0[9]: Copied! <pre>from torchfsm.operator import Vorticity2Pressure\nv2p=Vorticity2Pressure(kolm_force(y))\npressure=v2p(traj,mesh=mesh).view(*ori_shape[0:2],1,*ori_shape[3:])\n</pre> from torchfsm.operator import Vorticity2Pressure v2p=Vorticity2Pressure(kolm_force(y)) pressure=v2p(traj,mesh=mesh).view(*ori_shape[0:2],1,*ori_shape[3:]) In\u00a0[10]: Copied! <pre>plot_traj(pressure,channel_names=['$p$'])\n</pre> plot_traj(pressure,channel_names=['$p$']) Out[10]:    Your browser does not support the video tag."},{"location":"tutorials/pdes/ns_vorticity/#introduction-to-the-navier-stokes-equations","title":"Introduction to the Navier-Stokes Equations\u00b6","text":"<p>The Navier-Stokes equations describe the motion of fluid. In this context, we focus on the incompressible form of the Navier-Stokes equations:</p> $$ \\begin{align} \\frac{\\partial\\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla)\\mathbf{u} &amp;= -\\nabla p + \\nu \\nabla^2 \\mathbf{u} + \\mathbf{f}, \\\\ \\nabla \\cdot \\mathbf{u} &amp;= 0, \\end{align} $$<p>where:</p> <ul> <li>$\\mathbf{u}$ is the velocity field,</li> <li>$p$ is the pressure field,</li> <li>$\\rho$ is the fluid density,</li> <li>$\\nu$ is the kinematic viscosity, and</li> <li>$\\mathbf{f}$ is the external force field.</li> </ul> <p>The first equation is the momentum equation, and the second is the continuity equation.</p> <p>Solving the Navier-Stokes equations is a challenging task due to the non-linearity of the equations. The non-linearity arises from the convective term $(\\mathbf{u} \\cdot \\nabla)\\mathbf{u}$, which makes the equations difficult to solve analytically. However, the equations can be solved numerically using various methods. Here, we introduce two common methods used in Fourier Spectral Methods:</p>"},{"location":"tutorials/pdes/ns_vorticity/#vorticity-based-formulation","title":"Vorticity-Based Formulation\u00b6","text":"<p>The vorticity-streamfunction formulation is a common method for solving the Navier-Stokes equations in two dimensions. The vorticity, $\\boldsymbol{\\omega}$, is defined as the curl of the velocity field:</p> $$ \\boldsymbol{\\omega} = \\nabla \\times \\mathbf{u}. $$<p>For two-dimensional, incompressible flow, the vorticity is a scalar quantity, and its transport equation is given by:</p> $$ \\frac{\\partial \\omega}{\\partial t} + (\\mathbf{u} \\cdot \\nabla) \\omega = \\nu \\nabla^2 \\omega + \\nabla \\times \\mathbf{f}. $$<p>The derivation of the above vorticity transport equation can be found here.</p> <p>Here, we provide two examples of solving the vorticity transport equation:</p>"},{"location":"tutorials/pdes/ns_vorticity/#decaying-flow","title":"Decaying Flow\u00b6","text":"<p>In this example, we consider a decaying flow in a periodic domain. There is no external force, and the initial flow is randomly generated. The flow decays over time due to viscosity.</p>"},{"location":"tutorials/pdes/ns_vorticity/#kolmogorov-flow","title":"Kolmogorov flow\u00b6","text":"<p>Another good example is the Kolmogorov flow. Compared to previous decayed flow, kolmogorov flow is driven by a sinusoidal force and exhibit a more complex flow structure.</p>"},{"location":"tutorials/pdes/ns_vorticity/#obtain-velocity-and-pressure-from-vorticity","title":"Obtain velocity and pressure from vorticity\u00b6","text":"<p>In the vorticity based formulation, we only solve the vorticity transport equation. To obtain the velocity, we can do some simple post-processing.</p> <p>For a 2d velocity field $\\mathbf{u}=(u,v)$, there exists a streamfunction $\\psi$ such that: $$ \\begin{align} u &amp;= -\\frac{\\partial \\psi}{\\partial y},\\\\ v &amp;= \\frac{\\partial \\psi}{\\partial x}. \\end{align} $$</p> <p>and the vorticity can be then expressed as</p> $$ \\omega = \\frac{\\partial v}{\\partial x} - \\frac{\\partial u}{\\partial y} = \\nabla^2 \\psi. $$<p>Thus, we could first obtain the streamfunction $\\psi$ from the vorticity $\\omega$ by solving the Poisson equation and then obtain the velocity field $\\mathbf{u}$ from the streamfunction $\\psi$. Here, we directly provide an operator for all these post-processing steps.</p>"}]}